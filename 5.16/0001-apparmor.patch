From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 97F67C433FE
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:43:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234302AbhKXBqw (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:46:52 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:37539
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S234183AbhKXBqv (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:46:51 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718222; bh=mVfWG+Ma1KNOaCMEU57U3q2jN/cdOxcwG/bHXWANaeo=; h=From:To:Cc:Subject:Date:References:From:Subject:Reply-To; b=n+jEmutzE8xHlkr5m3MUZ+fPYbdYdG5qkBoEXRNQ/fo1DLOLbFcJOrKDBxWA9UrQr3dgyzRefxs5wNgYZOyImdIkdsD3VFkF7M+3FPTnzOWiJ9Ci9NX5WSSJi90p6bWNj/0oiGU9DSMmkzUV0DjSUtTMjKlokkPD274YgIBCrajjP+LW7T92sH2NNfPV462me3iB9pzWOvPicVamZ0z5KIWRmepTFGnk+/0hx/zKVolg7jXv57c3kTOEKsCJzajK00MQLoqQigKM4hTpR3wTjQUfX1x4+yagh9q4oBpHiUbWUXjzzLSI8OFMzvI2oXTsrVVSx28/JWNxHG+lRZMVSQ==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718222; bh=tksjpqN3epJ7qBmC+zfXNz918yogDPcwfzmbNjvgAO3=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=h1Zv5i9ovoGL0SxLOcGTLx4YfgTJdvG+vnKzH4yizfzCf7BWv2KKF72n74c5cRTrussWXQoaHpcL2mGciupFl7HTcBqWeXHNPqHpDMwKi1Ve1lRfcGMZwFMQcn+Q8XcBfHbsBL0+tn2hhNR0lKSv/FJ1Wq4YvZbE4ZjUeKmLqJ4UIKaRHKDfJIJblO9UgQCai3Ql0Umm1IEipWxjPBFY/6yakrX5X0z7IMJDBGnHBp8ny5GzoDns1pcToBmnJ3+vlBG2eQvV22DIxY7dqUceEdN9YXuhtcNwi4vdNJFoF8P+yKZhywnThLvvLCqAGv1nHcnuf5nKUIrWVDKRDUXs/A==
X-YMail-OSG: blCk5pEVM1n26KSJewdrFdLkhUcRGm9vidHtMueOwPV3GxmuiyINlSIisDuL6TR
 NNY6sal.veMLXX2Wa95LZsYmgpyaGX.9HjMad231cIormUs04VA0VreVFt7L6NbF10fQk7EkV568
 2yrGG3wh.pqMWK6IR3YHcRSLc5v1mp8Ln2f.O3ti.bfOhrkSqNYeykF8gqj.1fNuL1KqC29A_7H9
 5E4SXTtTJ.WZ8tAnWjrTLMocUGgOz_AKVLYzrYB545LmkTlggUpN2BVTfFw6PrlipIc7U5F7HtKN
 VEj3VmmwldcIJCvHY8q3TErMoCrxJ1uz93nXIerDbalA5ZRl65HSe9hI3BgW06HGtHb0OCC_15HF
 zr4l1kr6XD.kUsdgQUEYdKmZLH7oS6t3rNwD92d.BDK7Q17mmfWluJW0EF8db0BuPso_F6jJM4FX
 XyFoMN4LWARJDnZ49MEBuViCmoTO8jxslxaP4PH7jIeYNGaRtGnXs2gikyeiyqfXLKMWU9Jn7I.i
 TYbo.eBjzHhx2O1tfuQefg1eFnlQX4wwX6m7.iSWmf0JoyueIfCbtvqjBo4yKO.aKsYCa0PVO5.5
 sESiS6sM7inND9XlI4nIi9m0Jk9MNQw4d7oMeEaKo4rtjb3t_wWHBq19KC9q6Bz5UzbM8ji971mL
 vqac5fs2LCMLiBFLlbQZgTP5TeFgWo1xo.QweJedPGdIdrE26gM.123q2G2xugIz0BywqyYC2UIV
 XecLLxpM1GxEq6NTLBwGwSTjlu.CBL0dQweKbLF5yQYhKLh70yIKKFdpgSZ.zJvbJXayFm_OD4uU
 jSsJv_RKD3aUCxf5yvuQWGxslI3uFdouO68PHL2FV21_HUennCz9VZaNTKnnklXKcNY3Rj3RCXKc
 F_fVOWhrIHx0iwYgeUjA07wtVNT3d4pcMt6P7cK3wgFXJMt048agtAqGr0sm7gWZvGR5gJWdAPlo
 5f7YUphkltz5TJ8BxZ_f1.5yTqtqk1qkhFddOi3F34t6y4p9a_8L5TcybFHyseo3rfLH7uvTpeQo
 NyMd7_2wuyv0En3fk8.IqlchDI0Vfu5hZU1Km_fko_AODVjErFRDR4ge0yuCmdQjKDzqHeagbSox
 km4p1Ofu4rrL_PkCToYIDku5NXAP_I8vLB.5fZUEvLdi7xQV1JKSBXS9IbJDMXrDir2ClQnX13Az
 sm_6MUeaIukjRl0eWLHzEG39W1XLQm7PnLe3PN6.hRz7SDdXJFlN5be5dGO8vM6n8JcRKt3capA2
 w3vUe2gbHr8.wOCEjc0bVsH5BgEahkaspuFWzRrvK46JMZkwuzceNnYSL3FAVSFrN7D7ntcQGF3z
 Kx560irvRES_VAbJMXNQjiSHmsU3rbkid9xULUw7Al4H_9Eu.LdLsnNO77Wm4TQvkzX7PYpcelOJ
 6CpFW10Kc.BSR.avp_xwXA9Z7jvfOdHskMSc2pfdOJfWbAKh_qlz1RVXClt78QuOuGVAQR0KcDxA
 dX6RDzDFjGmisvhFVpnMn8r.w_6A58lv4ztppLwmvwpH7fVpiHc2ObjB.Xld0GN1p6OFwG_XMsLm
 kXV5ATyIUErWG6lMRtBWedP7VVplitsiOPEtjxVcxC3Ssh9tlajTS0cfOp_2B33f3kao52fWbdbc
 vIGX3IPZ0kVXiOr8y.WenPlICdP7XrQ57L156p.3vK5yqLfKCCpZ7ZymwUx6d4ooFJEUXcP9qQJ.
 7.E0LviWkVytpqsFGW_4Je4.oZdGrx4zs164_kKmYZcWWn.tH7wppnwH857GlOwUUeA56TOn1vY5
 JnbQ9n4fmmAeSOGkQnMuAzboLNa5XIl9jv0DXGAUhRejaZz5OmYb4VLSDOvUij_y6eTWd3LvPh6s
 B3f75YcUZickrW3qk97U0L_MDRLsrwQ3qcwOqBfm6fCU03kvfhoQ4.4duZ53sy1pW6t1f8ou9XId
 lBEmC2Ji8pL06liT_HIJ2SLorH5hO7Ayob1i8EP040hig5nZ2Qck3SL3p69ZVqaRQcF2apKFp0Qf
 LJcJBzFiUZ3z37I7RPQw1xMtyOuDig9E4.aguMXPE7sqxjhAt9ArfImH_HHHXtUNTOzYVgk7SxJn
 nqfnL14tsL0XGQX9meI3sb2cbpJyKVZ.3SJVQNWSStzZnrLF0D4SvZLXW1Q8VLsUl2pjdtPqCUCP
 TeQXSsobnJ3t9aBdsZghBzeqRzV0yfKzBWZaAsGFiWr8ue8ObLmLCSRnPz2o_oL2XNqDGIzTNeuM
 BWELWynjRyb624Y.wsw--
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:43:42 +0000
Received: by kubenode550.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID b2aaa5ff8b6fa8da98d80de77949c743;
          Wed, 24 Nov 2021 01:43:37 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 00/28] LSM: Module stacking for AppArmor
Date:   Tue, 23 Nov 2021 17:43:04 -0800
Message-Id: <20211124014332.36128-1-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
References: <20211124014332.36128-1-casey.ref@schaufler-ca.com>
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

This patchset provides the changes required for
the AppArmor security module to stack safely with any other.

v30: Rebase to 5.16-rc1
     Replace the integrity sub-system reuse of the audit
     subsystem event matching functions with IMA specific
     functions. This is done because audit needs to maintain
     information about multiple security modules in audit
     rules while IMA to restricts the information to a single
     security module.
     The binder hooks have been changed and are no longer
     called with sufficient information to identify the
     interface_lsm. Pass that information in the binder
     message, and use that in the compatibility decision.
     Refactor the audit changes.
v29: Rebase to 5.15-rc1
     Rework the supplimental audit record generation. Attach
     a list of supplimental data to the audit_buffer and
     generate the auxiliary records as needed on event end.
     This should be usable for other auxiliary data, such as
     container IDs. There is other ongoing audit work that
     will require integration with this.
v28: Rebase to 5.14-rc2
     Provide IMA rules bounds checking (patch 04)
     Quote contexts in MAC_TASK_CONTEXTS and MAC_OBJ_CONTEXTS
     audit records because of AppArmor's use of '=' in context
     values. (patch 22,23)
v27: Fixes for landlock (patch 02)
     Rework the subject audit record generation. This version is
     simpler and reflects feedback from Paul Moore. (patch 22)
v26: Rebase to 5.13-rc1
     Include the landlock security module.
     Accomodate change from security_task_getsecid() to
     security_task_getsecid_obj() and security_task_getsecid_subj().
v25: Rebase to 5.12-rc2
     Incorporate feedback from v24
     - The IMA team suggested improvements to the integrity rule
       processing.
v24: Rebase to 5.11-rc1
     Incorporate feedback from v23
     - Address the IMA team's concerns about "label collisions".
       A label collision occurs when there is ambiguity about
       which of multiple LSMs is being targeted in the definition
       of an integrity check rule.  A system with Smack and
       AppArmor would be unable to distinguish which LSM is
       important to an integrity rule referrencing the label
       "unconfined" as that label is meaningful to both.
       Provide a boot option to specify which LSM will be used in
       IMA rules when multiple LSMs are present. (patch 04)
       Pull LSM "slot" identification from later audit patches in
       in support of this (patch 03).
     - Pick up a few audit events that need to include supplimental
       subject context records that had been missed in the
       previous version.
v23: Rebase to 5.10-rc4
     Incorporate feedback from v22
     - Change /proc/*/attr/display to /proc/*/attr/interface_lsm to
       make the purpose clearer. (patch 0012)
     - Include ABI documentation. (patch 0012, 0022)
     - Introduce LSM documentation updates with the patches where
       the interfaces are added rather than at the end. (patch 0012, 0022)
     Include more maintainers and mail lists in To: and Cc: directives.
v22: Rebase to 5.10-rc1
v21: Rebase to 5.9-rc4
     Incorporate feedback from v20
     - Further revert UDS SO_PEERSEC to use scaffolding around
       the interfaces that use lsmblobs and store only a single
       secid. The possibility of multiple security modules
       requiring data here is still a future problem.
     - Incorporate Richard Guy Briggs' non-syscall auxiliary
       records patch (patch 0019-0021) in place of my "supplimental"
       records implementation. [I'm not sure I've given proper
       attestation. I will correct as appropriate]
v20: Rebase to 5.9-rc1
     Change the BPF security module to use the lsmblob data. (patch 0002)
     Repair length logic in subject label processing (patch 0015)
     Handle -EINVAL from the empty BPF setprocattr hook (patch 0020)
     Correct length processing in append_ctx() (patch 0022)
v19: Rebase to 5.8-rc6
     Incorporate feedback from v18
     - Revert UDS SO_PEERSEC implementation to use lsmblobs
       directly, rather than allocating as needed. The correct
       treatment of out-of-memory conditions in the later case
       is difficult to define. (patch 0005)
     - Use a size_t in append_ctx() (patch 0021)
     - Fix a memory leak when creating compound contexts. (patch 0021)
     Fix build error when CONFIG_SECURITY isn't set (patch 0013)
     Fix build error when CONFIG_SECURITY isn't set (patch 0020)
     Fix build error when CONFIG_SECURITY isn't set (patch 0021)
v18: Rebase to 5.8-rc3
     Incorporate feedback from v17
     - Null pointer checking in UDS (patch 0005)
     Match changes in IMA code (patch 0012)
     Fix the behavior of LSM context supplimental audit
     records so that there's always exactly one when it's
     appropriate for there to be one. This is a substantial
     change that requires extention of the audit_context beyond
     syscall events. (patch 0020)
v17: Rebase to 5.7-rc4
v16: Rebase to 5.6
     Incorporate feedback from v15 - Thanks Stephen, Mimi and Paul
     - Generally improve commit messages WRT scaffolding
     - Comment ima_lsm_isset() (patch 0002)
     - Some question may remain on IMA warning (patch 0002)
     - Mark lsm_slot as __lsm_ro_after_init not __init_data (patch 0002)
     - Change name of lsmblob variable in ima_match_rules() (patch 0003)
     - Instead of putting a struct lsmblob into the unix_skb_parms
       structure put a pointer to an allocated instance. There is
       currently only space for 5 u32's in unix_skb_parms and it is
       likely to get even tighter. Fortunately, the lifecycle
       management of the allocated lsmblob is simple. (patch 0005)
     - Dropped Acks due to the above change (patch 0005)
     - Improved commentary on secmark labeling scaffolding. (patch 0006)
     - Reduced secmark related labeling scaffolding. (patch 0006)
     - Replace use of the zeroth entry of an lsmblob in scaffolding
       with a function lsmblob_value() to hopefully make it less
       obscure. (patch 0006)
     - Convert security_secmark_relabel_packet to use lsmblob as
       this reduces much of the most contentious scaffolding. (patch 0006)
     - Dropped Acks due to the above change (patch 0006)
     - Added BUILD_BUG_ON() for CIPSO tag 6. (patch 0018)
     - Reworked audit subject information. Instead of adding fields in
       the middle of existing records add a new record to the event. When
       a separate record is required use subj="?". (patch 0020)
     - Dropped Acks due to the above change (patch 0020)
     - Reworked audit object information. Instead of adding fields in
       the middle of existing records add a new record to the event. When
       a separate record is required use obj="?". (patch 0021)
     - Dropped Acks due to the above change (patch 0021)
     - Enhanced documentation (patch 0022)
     - Removed unnecessary error code check in security_getprocattr()
       (patch 0021)
v15: Rebase to 5.6-rc1
     - Revise IMA data use (patch 0002)
     Incorporate feedback from v14
     - Fix lockdown module registration naming (patch 0002)
     - Revise how /proc/self/attr/context is gathered. (patch 0022)
     - Revise access modes on /proc/self/attr/context. (patch 0022)
     - Revise documentation on LSM external interfaces. (patch 0022)
v14: Rebase to 5.5-rc5
     Incorporate feedback from v13
     - Use an array of audit rules (patch 0002)
     - Significant change, removed Acks (patch 0002)
     - Remove unneeded include (patch 0013)
     - Use context.len correctly (patch 0015)
     - Reorder code to be more sensible (patch 0016)
     - Drop SO_PEERCONTEXT as it's not needed yet (patch 0023)
v13: Rebase to 5.5-rc2
     Incorporate feedback from v12
     - Print lsmblob size with %z (Patch 0002)
     - Convert lockdown LSM initialization. (Patch 0002)
     - Restore error check in nft_secmark_compute_secid (Patch 0006)
     - Correct blob scaffolding in ima_must_appraise() (Patch 0009)
     - Make security_setprocattr() clearer (Patch 0013)
     - Use lsm_task_display more widely (Patch 0013)
     - Use passed size in lsmcontext_init() (Patch 0014)
     - Don't add a smack_release_secctx() hook (Patch 0014)
     - Don't print warning in security_release_secctx() (Patch 0014)
     - Don't duplicate the label in nfs4_label_init_security() (Patch 0016)
     - Remove reviewed-by as code has significant change (Patch 0016)
     - Send the entire lsmblob for Tag 6 (Patch 0019)
     - Fix description of socket_getpeersec_stream parameters (Patch 0023)
     - Retain LSMBLOB_FIRST. What was I thinking? (Patch 0023)
     - Add compound context to LSM documentation (Patch 0023)
v12: Rebase to 5.5-rc1
     Fixed a couple of incorrect contractions in the text.
v11: Rebase to 5.4-rc6
     Incorporate feedback from v10
     - Disambiguate reading /proc/.../attr/display by restricting
       all use of the interface to the current process.
     - Fix a merge error in AppArmor's display attribute check
v10: Ask the security modules if the display can be changed.
v9: There is no version 9
v8: Incorporate feedback from v7
    - Minor clean-up in display value management
    - refactor "compound" context creation to use a common
      append_ctx() function.
v7: Incorporate feedback from v6
    - Make setting the display a privileged operation. The
      availability of compound contexts reduces the need for
      setting the display.
v6: Incorporate feedback from v5
    - Add subj_<lsm>= and obj_<lsm>= fields to audit records
    - Add /proc/.../attr/context to get the full context in
      lsmname\0value\0... format as suggested by Simon McVittie
    - Add SO_PEERCONTEXT for getsockopt() to get the full context
      in the same format, also suggested by Simon McVittie.
    - Add /sys/kernel/security/lsm_display_default to provide
      the display default value.
v5: Incorporate feedback from v4
    - Initialize the lsmcontext in security_secid_to_secctx()
    - Clear the lsmcontext in all security_release_secctx() cases
    - Don't use the "display" on strictly internal context
      interfaces.
    - The SELinux binder hooks check for cases where the context
      "display" isn't compatible with SELinux.
v4: Incorporate feedback from v3
    - Mark new lsm_<blob>_alloc functions static
    - Replace the lsm and slot fields of the security_hook_list
      with a pointer to a LSM allocated lsm_id structure. The
      LSM identifies if it needs a slot explicitly. Use the
      lsm_id rather than make security_add_hooks return the
      slot value.
    - Validate slot values used in security.c
    - Reworked the "display" process attribute handling so that
      it works right and doesn't use goofy list processing.
    - fix display value check in dentry_init_security
    - Replace audit_log of secids with '?' instead of deleting
      the audit log
v3: Incorporate feedback from v2
    - Make lsmblob parameter and variable names more
      meaningful, changing "le" and "l" to "blob".
    - Improve consistency of constant naming.
    - Do more sanity checking during LSM initialization.
    - Be a bit clearer about what is temporary scaffolding.
    - Rather than clutter security_getpeersec_dgram with
      otherwise unnecessary checks remove the apparmor
      stub, which does nothing useful.

Patch 01 separates the audit rule processing from the
integrity rule processing. They were never really the
same, but void pointers could hide that. The changes
following use the rule pointers differently in audit
and IMA, so keeping the code common is not a good idea.

Patch 02 moves management of the sock security blob
from the individual modules to the infrastructure.

Patches 03-04 introduce a structure "lsmblob" that will gradually
replace the "secid" as a shorthand for security module information.
At this point lsmblob contains an array of u32 secids, one "slot"
for each of the security modules compiled into the kernel that
used secids. A "slot" is allocated when a security module requests
one.

Patch 05 provides mechanism for the IMA subsystem to identify
explicitly which LSM is subject to IMA policy. This includes
a boot option for specifying the default and an additional option
in IMA rules "lsm=".

Patches 06-15 change LSM interfaces to use the lsmblob instead
of secids. It is important that the lsmblob be a fixed size entity
that does not have to be allocated. Several of the places
where it is used would have performance and/or locking
issues with dynamic allocation.

Patch 15 provides a mechanism for a process to identify which
security module's hooks should be used when displaying or
converting a security context string.  A new interface
/proc/self/attr/interface_lsm contains the name of the security
module to show. Reading from this file will present the name of
the module, while writing to it will set the value. Only names
of active security modules are accepted. Internally, the name
is translated to the appropriate "slot" number for the module
which is then stored in the task security blob. Setting the
display requires that all modules using the /proc interfaces
allow the transition. The interface LSM of other processess
can be neither read nor written. All suggested cases for
reading the interface LSM of a different process have race
conditions.

Patch 16 Starts the process of changing how a security
context is represented. Since it is possible for a
security context to have been generated by more than one
security module it is now necessary to note which module
created a security context so that the correct "release"
hook can be called. There are several places where the
module that created a security context cannot be inferred.

This is achieved by introducing a "lsmcontext" structure
which contains the context string, its length and the
"slot" number of the security module that created it.
The security_release_secctx() interface is changed,
replacing the (string,len) pointer pair with a lsmcontext
pointer.

Patches 17-18 convert the security interfaces from
(string,len) pointer pairs to a lsmcontext pointer.
The slot number identifying the creating module is
added by the infrastructure. Where the security context
is stored for extended periods the data type is changed.

The Netlabel code is converted to save lsmblob structures
instead of secids in Patch 19. This is not strictly
necessary as there can only be one security module that
uses Netlabel at this point. Using a lsmblob is much
cleaner, as the interfaces that use the data have all
been converted.

Patch 20 adds checks to the binder hooks which verify
that both ends of a transaction use the same interface LSM.

Patch 21 adds a parameter to security_secid_to_secctx()
that indicates which of the security modules should be used
to provide the context.

Patches 22-24 provide mechanism to keeping a list of auxiliary
record data in an audit_buffer. The list is read when the
audit record is ended, and supplimental records are created
as needed.

Patch 25 adds a supplimental audit record for subject
LSM data when there are multiple security modules with such data.
The AUDIT_MAC_TASK_CONTEXTS record is used in conjuction with a
"subj=?" field to identify the subject data. The
AUDIT_MAC_TASK_CONTEXTS record identifies the security module
with the data: subj_selinux="xyz_t" subj_apparmor="abc".

An example of the MAC_TASK_CONTEXTS (1420) record is:

    type=UNKNOWN[1420]
    msg=audit(1600880931.832:113)
    subj_apparmor="=unconfined"
    subj_smack="_"

Patch 26 adds a supplimental audit record for object
LSM data when there are multiple security modules with such data.
The AUDIT_MAC_OBJ_CONTEXTS record is used in conjuction The
with a "obj=?" field to identify the object data.
The AUDIT_MAC_OBJ_CONTEXTS record identifies the security module
with the data: obj_selinux="xyz_t obj_apparmor="abc".  While
AUDIT_MAC_TASK_CONTEXTS records will always contain an entry
for each possible security modules, AUDIT_MAC_OBJ_CONTEXTS
records will only contain entries for security modules for
which the object in question has data.

An example of the MAC_OBJ_CONTEXTS (1421) record is:

    type=UNKNOWN[1421]
    msg=audit(1601152467.009:1050):
    obj_selinux="unconfined_u:object_r:user_home_t:s0"

Patch 27 adds a new interface for getting the compound security
contexts, /proc/self/attr/context.  An example of the content
of this file is:

    selinux\0one_u:one_r:one_t:s0-s0:c0.c1023\0apparmor\0unconfined\0

Finally, with all interference on the AppArmor hooks removed,
Patch 28 removes the exclusive bit from AppArmor. An unnecessary
stub hook was also removed.

The Ubuntu project is using an earlier version of this patchset in
their distribution to enable stacking for containers.

Performance measurements to date have the change within the "noise".
The sockperf and dbench results are on the order of 0.2% to 0.8%
difference, with better performance being as common as worse. The
benchmarks were run with AppArmor and Smack on Ubuntu.

https://github.com/cschaufler/lsm-stacking.git#stack-5.16-rc1-v30

Casey Schaufler (28):
  integrity: disassociate ima_filter_rule from security_audit_rule
  LSM: Infrastructure management of the sock security
  LSM: Add the lsmblob data structure.
  LSM: provide lsm name and id slot mappings
  IMA: avoid label collisions with stacked LSMs
  LSM: Use lsmblob in security_audit_rule_match
  LSM: Use lsmblob in security_kernel_act_as
  LSM: Use lsmblob in security_secctx_to_secid
  LSM: Use lsmblob in security_secid_to_secctx
  LSM: Use lsmblob in security_ipc_getsecid
  LSM: Use lsmblob in security_task_getsecid
  LSM: Use lsmblob in security_inode_getsecid
  LSM: Use lsmblob in security_cred_getsecid
  LSM: Specify which LSM to display
  LSM: Ensure the correct LSM context releaser
  LSM: Use lsmcontext in security_secid_to_secctx
  LSM: Use lsmcontext in security_inode_getsecctx
  LSM: security_secid_to_secctx in netlink netfilter
  NET: Store LSM netlabel data in a lsmblob
  binder: Pass LSM identifier for confirmation
  LSM: Extend security_secid_to_secctx to include module selection
  Audit: Keep multiple LSM data in audit_names
  Audit: Create audit_stamp structure
  Audit: Add framework for auxiliary records
  Audit: Add record for multiple task security contexts
  Audit: Add record for multiple object security contexts
  LSM: Add /proc attr entry for full LSM context
  AppArmor: Remove the exclusive flag

 Documentation/ABI/testing/ima_policy          |   8 +-
 .../ABI/testing/procfs-attr-lsm_display       |  22 +
 Documentation/security/lsm.rst                |  28 +
 drivers/android/binder.c                      |  47 +-
 drivers/android/binder_internal.h             |   1 +
 fs/ceph/xattr.c                               |   6 +-
 fs/nfs/nfs4proc.c                             |   8 +-
 fs/nfsd/nfs4xdr.c                             |  20 +-
 fs/proc/base.c                                |   2 +
 include/linux/audit.h                         |  15 +-
 include/linux/cred.h                          |   3 +-
 include/linux/lsm_hooks.h                     |  19 +-
 include/linux/security.h                      | 244 ++++++-
 include/net/netlabel.h                        |   8 +-
 include/net/scm.h                             |  15 +-
 include/uapi/linux/audit.h                    |   2 +
 kernel/audit.c                                | 257 ++++++--
 kernel/audit.h                                |  18 +-
 kernel/auditfilter.c                          |  30 +-
 kernel/auditsc.c                              | 130 ++--
 kernel/cred.c                                 |  12 +-
 net/ipv4/cipso_ipv4.c                         |  26 +-
 net/ipv4/ip_sockglue.c                        |  12 +-
 net/netfilter/nf_conntrack_netlink.c          |  24 +-
 net/netfilter/nf_conntrack_standalone.c       |  11 +-
 net/netfilter/nfnetlink_queue.c               |  38 +-
 net/netfilter/nft_meta.c                      |  10 +-
 net/netfilter/xt_SECMARK.c                    |   7 +-
 net/netlabel/netlabel_kapi.c                  |   6 +-
 net/netlabel/netlabel_unlabeled.c             | 101 ++-
 net/netlabel/netlabel_unlabeled.h             |   2 +-
 net/netlabel/netlabel_user.c                  |  13 +-
 net/netlabel/netlabel_user.h                  |   6 +-
 security/apparmor/include/apparmor.h          |   3 +-
 security/apparmor/include/net.h               |   6 +-
 security/apparmor/include/procattr.h          |   2 +-
 security/apparmor/lsm.c                       | 105 ++--
 security/apparmor/procattr.c                  |  22 +-
 security/bpf/hooks.c                          |  12 +-
 security/commoncap.c                          |   7 +-
 security/integrity/ima/ima.h                  |  26 -
 security/integrity/ima/ima_appraise.c         |  12 +-
 security/integrity/ima/ima_main.c             |  63 +-
 security/integrity/ima/ima_policy.c           |  58 +-
 security/landlock/cred.c                      |   2 +-
 security/landlock/fs.c                        |   2 +-
 security/landlock/ptrace.c                    |   2 +-
 security/landlock/setup.c                     |   5 +
 security/landlock/setup.h                     |   1 +
 security/loadpin/loadpin.c                    |   8 +-
 security/lockdown/lockdown.c                  |   7 +-
 security/safesetid/lsm.c                      |   8 +-
 security/security.c                           | 595 ++++++++++++++++--
 security/selinux/hooks.c                      |  99 +--
 security/selinux/include/classmap.h           |   2 +-
 security/selinux/include/objsec.h             |   5 +
 security/selinux/include/security.h           |   1 +
 security/selinux/netlabel.c                   |  25 +-
 security/selinux/ss/services.c                |   4 +-
 security/smack/smack.h                        |   6 +
 security/smack/smack_access.c                 |   2 +-
 security/smack/smack_lsm.c                    |  91 +--
 security/smack/smack_netfilter.c              |   4 +-
 security/smack/smackfs.c                      |  10 +-
 security/tomoyo/tomoyo.c                      |   8 +-
 security/yama/yama_lsm.c                      |   7 +-
 66 files changed, 1740 insertions(+), 621 deletions(-)
 create mode 100644 Documentation/ABI/testing/procfs-attr-lsm_display

--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 990C4C433FE
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:45:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237269AbhKXBsq (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:48:46 -0500
Received: from sonic308-16.consmr.mail.ne1.yahoo.com ([66.163.187.39]:41748
        "EHLO sonic308-16.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S236192AbhKXBsp (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:48:45 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718333; bh=tYmviFOOq/cdxOdS7Z3hPoBGtoE7FfN71PBaagT21F0=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=Kw2vsXFkYkx+jBIHMcNFOujchzZlRwtOvQ91PGpjulXQKwuQj4YWJB1T4iGa6LAlsevHrJQGCac7xgw7uCwWDYPe1XRA1eEj2dVOppYB/+j3zyhL5Hwzx4zq7zVeFsMOrqgO9qY9MBbLEaB9WtIk46JO4ghTdSTwLd/HUyRDoWCl93aavxVGrlzDYwRzJadcdJc6ZOrBSt4JZBRsgAs1YRhfImS3RZk7x8jXy2q3+byCVBSV54q6TNfuOLY+c0SU//utlym2DhjnQ+bUpQZYKbxQBWeXSiHvOfZ9zGEyP9iNaCNuz0B336HQDGOtXfTH0ZHtZFxuQ1fvC5T3inlnTg==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718333; bh=u0FHKw56I2nb+SmEG3SqZqHpT7KeR7K/luV17G4601i=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=kD18qMN8fJ+aKs8/x8ovlXIsirFm1sB1HqUedzWW4wCv9t8rMq4MyVUrsrOEWu+W3QtjaZcEh5Z/YOwM8hmS8SsFJ33Axcvm69fXuz8TK0gqx4T0S1UExY8DN2JUGRSB8ZNIq346jxIBxhVay1dgTIWX1mpkXpwqwr5ik6ohiblCDBlPfHkEPNs3J9twOdVvXp93Bo/oIbNZph1C2zYhPcxWCLQx8eJFsZpdwSW5svi5Xt8N+1UTrJUmpGzuAK8bye1GnlNtmFT+JaQQwB5pVzrGNu+su91ZP/vf+rAkdMHunFpn+2z/4nhlkOwH82iHuZlqDCu2zEBRp9oig8CKOQ==
X-YMail-OSG: l6yDQxIVM1n_8nTwQ6UfrPKMsuO1t_VWcbETcM.t98NZ74YZK9FaZWdjX5IKmLz
 Qff.IxrMC_i6s8dV2XhiX0Ax.8bdudV97Ico7aIWZuY1LRr2VeKXQRp.pa2i0ZwZilUyppUF4Lnj
 Cr_B9eGwKwwCni0CFFZlG1G1aiSsaq7w7pRvABBQkklcOlJB53844XiKNqeb_V76_Ra_X64Xfmhs
 jL.VO.HTOcho8K.GDcxbszXmAYD08Fv4dh2kCTSSGBgaRcUvnnuCveqZvJhWau5p60Uxu8yDsKr4
 D7EorCiswMsrCHtDGVW82HqNlYsGLsYPP0Xu0eKuLYlmNZC0SAAd1iLLRFsOyHVyuxtbZzfnp7oh
 _PFxupOD1osfxfPFgSNm5wVlLBEcFcVnWwsosV6Ov4qLIqDNhM9D.oiB_YQxZtg9DfW1ok1WoOVU
 4ACTDWZ26r0wwFZXhEqjGFPfxqelb20osfDL8vBOJMDaq9qd91gryx3oNCg2gAuv0eIcZHqYQnTY
 TVnki3jxDW01CH5nIyzACXA2tD8Dio6r3uQnerHDy4eggOF8gxMVDdnItDgXW.Z_fNQKQcfpxlAM
 u78BeS.NeIsxmW8_5J4JGTIC6aT.t8Uue8ZIVzX6U.UMc2p.qFVy249EvELeR1L_DO0M_9THPBX.
 SUDRQLMsJA0QQCO2CvnOy6Jiuk_0YXggY_1nc1LGKvyThZNA3Ssw_ONVLXRXqzI_WvZ_Ss7ps7nw
 03O6CM_yR2o6uWzOvhKykNJoWyDsDmfE7wFxLlPr8QJp11Tzm4gIqu9IzUKzJIVbXZjXMQXoGnno
 FB7yqcXK3l7lmI.HGZZhhGdHIAXnf3uUyeRJ9k7FVgRwYlPaiDG9doNOt1Y2gmgOS210lGW0Xp1B
 xLYaFTgtl.d_uCPGI33sMr20Dm3rCMC.nXcd.8hT3Ct2Lzjwl05E8NBLGW554W00rdkblblf2cNA
 hb_5FdHyiarnYOeCCBkS04rozshUYRVHQfp1eMqen4aM9HnTLamsmwXSnUSRoimsNgXmzMWz0Jkl
 WHc1cbwIM0W2IoVQ7ROkiWLlrK6F0LXudIzkZN5lTjziehBTqNkEfev8SbYyAOFR8TaxcP8K84_C
 VKkVPBoROimXmMVmskCJ3udVKkOSOdNsUXIDuVhKyTkGWfmVcnRTp3iYnNE.AbtNfS1oOuWtGjhg
 2yELCcKz2RC4oAlkc7mTW3uwBPRcv9YtmnDsn.YMfpaOFu37LJPuRuOenNJYNI8h5.BVAEzGvfNU
 g_l0RIZ6EKtD9uzzeUAg_WHaGXzxYPp6roL1AfXIp3Odtoau7cNK7y2hugE_yNpscXnlNfmbIEAG
 Xonj8EkqMXKVuEkEXUo0JSHxrXm27PhvuHjI.PvB6bJOXddyA7kj6ElGTxZFSabmCIM8BBk1jcKw
 uK7WnK2lGn_9m0qLTROYzE_fh_W1bT7lDdocMpiPb7X2IwSwjy9ObR4AY4HBAUrFhN9TA7wPcCRI
 jbOpEK8PYD3LbzvIKJJIxUShueIBEIZRD4Xpv.MD5GSi1bsxYqkixNk3Medq63c3KCYglTOz2sl.
 JseusQDkZOtgW28TB8upC.4sjrlzCNiYiI0JYm0GkJOXFgB_NR0OdUbh.moghai_ygpc6iJM81El
 nugeIyJCuQ0IJUiLaNGSh5TONmEK9XvUkdbkDaYIN1J0PGHqMaSUW3P7G2LIx_nWzUNUWd3iM48M
 PK6dKY8Bn5brr3U8VtEdHbtLA5t.HrQcvudzghogcIfFD0GyFXRIeFRqIRrhVz7MepE0_2126cGZ
 GILLAIfLI9020LekiPF2LMwVZ4VuUsQ98b1_MdxAlrYlWaeCDGq5lPeGBhjbVTBNlU3WmKhzba5I
 SURNsCDW_cMhwG8jzDv_xQqzHUkwpGUhBMEtMTOJtDuUwkgMteGhJLMkHdVBNPHMwpa2TfZ8Btj8
 Sl895TL7X_.9.yCOuE5jiIHDVUGL6f34Q0GFsmNBHOwaIcSyW_SaRehH.4Bcp.0JYrCHbNj0Z02b
 iA4y3h0cHO8vez4jGLYVF6OwxWc9PCq_KuYi18TN1hYS8ckLTUHuqeUhn20FoSZcB.kWLo1iqYCl
 Fe9xUSuXcot_BexVTrJf.dB6uf9NA7RqWvGRq0XpYe6DrOLdSj6VncMJHgD_pz78IgaLkLEgsqbh
 x6gnqgpwAvn5bdA23xmEYRRNiENfE8LdGczEnhTGSCw0g3QRqocQRmMa7irSmlhMg60SX68oAci4
 wp3JJleawI9QBAR75OfQEtiIJWnc-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic308.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:45:33 +0000
Received: by kubenode536.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID fe85aae97f01a62fa1c76c1f4afa6f87;
          Wed, 24 Nov 2021 01:44:43 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 01/28] integrity: disassociate ima_filter_rule from security_audit_rule
Date:   Tue, 23 Nov 2021 17:43:05 -0800
Message-Id: <20211124014332.36128-2-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Create real functions for the ima_filter_rule interfaces.
These replace #defines that obscure the reuse of audit
interfaces. The new fuctions are put in security.c because
they use security module registered hooks that we don't
want exported.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 include/linux/security.h     | 26 ++++++++++++++++++++++++++
 security/integrity/ima/ima.h | 26 --------------------------
 security/security.c          | 21 +++++++++++++++++++++
 3 files changed, 47 insertions(+), 26 deletions(-)

diff --git a/include/linux/security.h b/include/linux/security.h
index bbf44a466832..71eac35bfa21 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1917,6 +1917,32 @@ static inline void security_audit_rule_free(void *lsmrule)
 #endif /* CONFIG_SECURITY */
 #endif /* CONFIG_AUDIT */

+#ifdef CONFIG_IMA_LSM_RULES
+#ifdef CONFIG_SECURITY
+int ima_filter_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule);
+int ima_filter_rule_match(u32 secid, u32 field, u32 op, void *lsmrule);
+void ima_filter_rule_free(void *lsmrule);
+
+#else
+
+static inline int ima_filter_rule_init(u32 field, u32 op, char *rulestr,
+					   void **lsmrule)
+{
+	return 0;
+}
+
+static inline int ima_filter_rule_match(u32 secid, u32 field, u32 op,
+					    void *lsmrule)
+{
+	return 0;
+}
+
+static inline void ima_filter_rule_free(void *lsmrule)
+{ }
+
+#endif /* CONFIG_SECURITY */
+#endif /* CONFIG_IMA_LSM_RULES */
+
 #ifdef CONFIG_SECURITYFS

 extern struct dentry *securityfs_create_file(const char *name, umode_t mode,
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index be965a8715e4..1b5d70ac2dc9 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -418,32 +418,6 @@ static inline void ima_free_modsig(struct modsig *modsig)
 }
 #endif /* CONFIG_IMA_APPRAISE_MODSIG */

-/* LSM based policy rules require audit */
-#ifdef CONFIG_IMA_LSM_RULES
-
-#define ima_filter_rule_init security_audit_rule_init
-#define ima_filter_rule_free security_audit_rule_free
-#define ima_filter_rule_match security_audit_rule_match
-
-#else
-
-static inline int ima_filter_rule_init(u32 field, u32 op, char *rulestr,
-				       void **lsmrule)
-{
-	return -EINVAL;
-}
-
-static inline void ima_filter_rule_free(void *lsmrule)
-{
-}
-
-static inline int ima_filter_rule_match(u32 secid, u32 field, u32 op,
-					void *lsmrule)
-{
-	return -EINVAL;
-}
-#endif /* CONFIG_IMA_LSM_RULES */
-
 #ifdef	CONFIG_IMA_READ_POLICY
 #define	POLICY_FILE_FLAGS	(S_IWUSR | S_IRUSR)
 #else
diff --git a/security/security.c b/security/security.c
index c88167a414b4..063c9cbbcea6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2563,6 +2563,27 @@ int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule)
 }
 #endif /* CONFIG_AUDIT */

+#ifdef CONFIG_IMA_LSM_RULES
+/*
+ * The integrity subsystem uses the same hooks as
+ * the audit subsystem.
+ */
+int ima_filter_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)
+{
+	return call_int_hook(audit_rule_init, 0, field, op, rulestr, lsmrule);
+}
+
+void ima_filter_rule_free(void *lsmrule)
+{
+	call_void_hook(audit_rule_free, lsmrule);
+}
+
+int ima_filter_rule_match(u32 secid, u32 field, u32 op, void *lsmrule)
+{
+	return call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule);
+}
+#endif /* CONFIG_IMA_LSM_RULES */
+
 #ifdef CONFIG_BPF_SYSCALL
 int security_bpf(int cmd, union bpf_attr *attr, unsigned int size)
 {
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 993A9C433F5
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:46:09 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237150AbhKXBtR (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:49:17 -0500
Received: from sonic302-26.consmr.mail.ne1.yahoo.com ([66.163.186.152]:46869
        "EHLO sonic302-26.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S235541AbhKXBtF (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:49:05 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718355; bh=mqrxP8YbMqpdwGpiKDP5pDA2udZP8b7nOi28pU94VwE=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=VOZj8Oq9cgyDYGeD7dfP537N/GptqhbVmrKJDexQF6/A6E+7TX4wdLlEkSfPjoj9iMunZAB54vH8Ca3RKTJKBTWkghtpJNxAYoy2E0rYdbk+DNMxKLspT7MkSfIV4VEf3bTTOGnHPktIMon1dcAEykChX3r9gtJmzOVU7P/6Y08/77/jZGmlf5jRmKCE2ntG7J/v85Mz+X+pDWW2Wv6GjiiQrSdmKQnOt+sbnEbbupYuz3MnkmoS3A0fim53dpSSVK+DyWZDJi45gMvHJbAC26Z6KKYkIDvTqGhUR2S2X0xb8tn4NaLHchZdKyVadSG1Rt3ZEBwEYUBf1MWHeVKFoQ==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718355; bh=LoKXN4feJVYfcRDsFfEAO2ns713w9uL69XJ0w1fZowH=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=XaJMwp03ObYj7GTfHK8RSx5AbuCYjTvZuIOz4oTpJWHPPJpL2s/NptNKiL8bb4zT0+EirE8bbc+vQ8e7sLyf38WJzpgAIUr/CtKtnbklD9ZfypjacD1/iBe54ynbXls3k/PNzvrvHxsPA9Lx98U8yB7PklDy+2eghSlNTncY+cx0aHY9/bR2BxT9YfPkvME+Ddvhh8jFTqamvu/UWof7B1lQy3v7zxx1VGGdt2K64/AUlsx/i+L5YIP2kRQ6fiPchJqmAzhK7ot1uwKizGcc4aUHbidsnJ422VV752to9lBcU1V2rQT8lH353PiAfDhY4vPzB1f4fDaIzrHtRNsjWQ==
X-YMail-OSG: qhezSQsVM1njxiAiyJyZYSdeOrSEbceU2Z6yaFr8AWMwFaJGC5N82xRZ.gGi.Tt
 ohLesh423x5_qr_dLH4VfpT7iQwuKM5x_I7VFFOKqnDeVyI3OPZGY9Ydj2RniW.OffdUZtsZWCvL
 hvy7a2pLbS6oTzuYTbIzu5uOxDAnIXSmBZBUXFLiF491u1gG1UD66uSHHcv9dnJ98CzawPnEbpQr
 lZKT.T7flGhUmNvf2xvImqvPyU7hC.nMOLz6ACkqRIAky_1qVrcxuTav6So0j7Zhe8tMQehXkzui
 o8SzgbGvOxjmWiyS0mJq_ku6V3IkIpbbDVA3zZUw_uq2pNGFAbQw44e0za4MkE0L4cUGoB.bLVeb
 Kc0.cxQ6ZspBSBPdZB.zZ4LfnfOq1n5ikRT9Rz3X.hS14d5F8NwTf7XmBS7SAOp7U8cCmM4xIdsD
 U2By0EhEhsKaMdOQHbOMO0QMA45kzyoCrxW6DXNfVi3YlI8CwpMgBOi7z3rruYGkuWEdmlVUe5uM
 VLoZLgDRNnc_yp_wQ0TyRiIqOZ39h5D9WrhGxURaSZl2hsfOqHH_5DjnkAHcI5QB1K1kumS4bAV8
 mBxINP5F7MNk4t_hh7NEOCo_3AobPDi6zMKITU.qTxWU70tTdpbi8muwDwAZdVsBsIaqI.1a.QlE
 sKnJfeiHZp_hPCJ2LwmY2yGRo7pWy2X8T53cTd5NjzIBJDpSC.xmXaXhmcttS5OntH.4snYjEAUE
 3p2n273SCFENFIu1nZLNq0h8etn5LEgy0cn7p.IbuKbTRa7NqkLZ2KR2c9qo3gsKeP_9yPpP7mlo
 fYrrAVe3jpEKCLdNu2zFCRH2bJ0CuUavxtl.3DvRYSN7ANaEI0HycDHo_N_gdn7eYO2gCkoqaSyQ
 Chvg7D8zoR_weREQaboTwiBfR0bOCff8cfnbEfU3Je11NXdwuvQ.UBi0qVSUGnH_S0qWzZD5wooN
 PZyI0zGlMbx_XzraG0zyl20uJU6cLfmVxDIVeU.NsW324qVp8i8qWB7S_8.5DvzR6lZk7gY_H5Mh
 4fbbgewE4uaszKjwK3xtHyirRB6r3dBxUIMXLGV4.wkqjpHJ0j9ieksw2kNLhkDUck3iMKHSLUy2
 EMaz10fX0FiE3TtH.NAQ_v7AZcaIli7hlnuBumEjn01d5LgmAkz26y5u5Hhs1B8euWTcwB184rKk
 s8dVy9Nq0CmGkcvZK2ZhB5zbq_ijdC5NQjimaYa8hG._r_BkncCiQ49Pdi5e87V_kwadNQzdfcWD
 GMgsOCZ0EHIpnJMzEBoCz9XG0n2hdBBWy8lZ1sMhiGl6CpJdQXQOkYM2N8O8fAbzQUm60IaCWkJa
 GHar8HXdVukUGX0zzYchusREsvyvsaYDk_1VrKQVRrJ5VQ8IY7w3SBCPUkGZWm0.WBm3yJI0CJqx
 YvkFNqIxPfk1m9WXafd.1laTVUc7_lI1a83JadYKGfGZU99uy9DtK6Isk8sbnwyrNmwdfcqFdm0Q
 WJ9CXsi9o8H81vwwyCDi7JA38hsohe65N29OwPQI6FWB5pI4boHw.ytWgvtqUJg6Sj7yTl90ELyS
 HF9llBgEx.jwCQ97MECz_Tx26u_ipKhOPWjO59hBngBIuQPmSr8CNuzLj4HjhoKkUlR1yGVsdzQk
 ky91NAbp173uSneJDMeY1CTS0P9jOWwamMDD0oY8MFYrH1B1_GWIKn2xuM9wiGM4L5uMyC87POnF
 9YQkL1DPjttMD3ehdsB6U8Whw9jHHrsXJPfCG7KRPI8994OMMqbT0.F0XJe6coM.pth4COzPVmnn
 hp48QQ_SNSXylEEXXW.tPfzXjrT7eBl9x2VTPNUrl_wKkarJRsg67LkMxEZ_6HFQ9Pl9lkPO_mqx
 _YK03y84Cfj.rZBs284mUGFrQf.92ml2iVdye8oV8CBNX7oH7iPuSMpPqvIr8HB9fIkqYmTz1Isw
 Z6CSt1E.C7cMl2hdIHmleKbTpJmz9lrGy.DsBBjLZGSknkiGPxeh6.112pB49xrmGBHSNDcVGsxN
 RML2dafLnStnSeqHMadspc8DQarqSWgG4A8C8p1hmPE_MxRidwJ9Y8LU4P1zOIsVlf8ItoPG92ov
 WMjW.ePhamzOleJZDKqKTDS2XAHmmYUzFBIiOKMLw9ryvqiOPsZbUJFinSXJVL_YF0ZRb__C4F7I
 lZ8suf0Y7kr1FCSv9qYPy5_k7bPbCtHJmj6zTG2R2wMtGYyhm.frYBNQx6HDrNnOSN4d5uVWWThe
 xyKmGwFLp5JmqYnix1Zqaq5AIyFt4qyzSoGhgv9mxN934NHHeOrF4qEXj4elVHGryNnSPNahCSOL
 altPYbTc-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic302.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:45:55 +0000
Received: by kubenode514.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 63f8438e8d5e330f02280db70ed18b3d;
          Wed, 24 Nov 2021 01:45:50 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>
Subject: [PATCH v30 02/28] LSM: Infrastructure management of the sock security
Date:   Tue, 23 Nov 2021 17:43:06 -0800
Message-Id: <20211124014332.36128-3-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Move management of the sock->sk_security blob out
of the individual security modules and into the security
infrastructure. Instead of allocating the blobs from within
the modules the modules tell the infrastructure how much
space is required, and the space is allocated there.

Acked-by: Paul Moore <paul@paul-moore.com>
Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 include/linux/lsm_hooks.h         |  1 +
 security/apparmor/include/net.h   |  6 ++-
 security/apparmor/lsm.c           | 38 ++++-----------
 security/security.c               | 36 +++++++++++++-
 security/selinux/hooks.c          | 78 +++++++++++++++----------------
 security/selinux/include/objsec.h |  5 ++
 security/selinux/netlabel.c       | 23 ++++-----
 security/smack/smack.h            |  5 ++
 security/smack/smack_lsm.c        | 66 ++++++++++++--------------
 security/smack/smack_netfilter.c  |  4 +-
 10 files changed, 143 insertions(+), 119 deletions(-)

diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
index d45b6f6e27fd..89b8e40186f8 100644
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@ -1604,6 +1604,7 @@ struct lsm_blob_sizes {
 	int	lbs_cred;
 	int	lbs_file;
 	int	lbs_inode;
+	int	lbs_sock;
 	int	lbs_superblock;
 	int	lbs_ipc;
 	int	lbs_msg_msg;
diff --git a/security/apparmor/include/net.h b/security/apparmor/include/net.h
index aadb4b29fb66..fac8999ba7a3 100644
--- a/security/apparmor/include/net.h
+++ b/security/apparmor/include/net.h
@@ -51,7 +51,11 @@ struct aa_sk_ctx {
 	struct aa_label *peer;
 };

-#define SK_CTX(X) ((X)->sk_security)
+static inline struct aa_sk_ctx *aa_sock(const struct sock *sk)
+{
+	return sk->sk_security + apparmor_blob_sizes.lbs_sock;
+}
+
 #define SOCK_ctx(X) SOCK_INODE(X)->i_security
 #define DEFINE_AUDIT_NET(NAME, OP, SK, F, T, P)				  \
 	struct lsm_network_audit NAME ## _net = { .sk = (SK),		  \
diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c
index 0d6585056f3d..343631e20c2b 100644
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -775,33 +775,15 @@ static int apparmor_task_kill(struct task_struct *target, struct kernel_siginfo
 	return error;
 }

-/**
- * apparmor_sk_alloc_security - allocate and attach the sk_security field
- */
-static int apparmor_sk_alloc_security(struct sock *sk, int family, gfp_t flags)
-{
-	struct aa_sk_ctx *ctx;
-
-	ctx = kzalloc(sizeof(*ctx), flags);
-	if (!ctx)
-		return -ENOMEM;
-
-	SK_CTX(sk) = ctx;
-
-	return 0;
-}
-
 /**
  * apparmor_sk_free_security - free the sk_security field
  */
 static void apparmor_sk_free_security(struct sock *sk)
 {
-	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	struct aa_sk_ctx *ctx = aa_sock(sk);

-	SK_CTX(sk) = NULL;
 	aa_put_label(ctx->label);
 	aa_put_label(ctx->peer);
-	kfree(ctx);
 }

 /**
@@ -810,8 +792,8 @@ static void apparmor_sk_free_security(struct sock *sk)
 static void apparmor_sk_clone_security(const struct sock *sk,
 				       struct sock *newsk)
 {
-	struct aa_sk_ctx *ctx = SK_CTX(sk);
-	struct aa_sk_ctx *new = SK_CTX(newsk);
+	struct aa_sk_ctx *ctx = aa_sock(sk);
+	struct aa_sk_ctx *new = aa_sock(newsk);

 	if (new->label)
 		aa_put_label(new->label);
@@ -867,7 +849,7 @@ static int apparmor_socket_post_create(struct socket *sock, int family,
 		label = aa_get_current_label();

 	if (sock->sk) {
-		struct aa_sk_ctx *ctx = SK_CTX(sock->sk);
+		struct aa_sk_ctx *ctx = aa_sock(sock->sk);

 		aa_put_label(ctx->label);
 		ctx->label = aa_get_label(label);
@@ -1052,7 +1034,7 @@ static int apparmor_socket_shutdown(struct socket *sock, int how)
  */
 static int apparmor_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
-	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	struct aa_sk_ctx *ctx = aa_sock(sk);

 	if (!skb->secmark)
 		return 0;
@@ -1065,7 +1047,7 @@ static int apparmor_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)

 static struct aa_label *sk_peer_label(struct sock *sk)
 {
-	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	struct aa_sk_ctx *ctx = aa_sock(sk);

 	if (ctx->peer)
 		return ctx->peer;
@@ -1149,7 +1131,7 @@ static int apparmor_socket_getpeersec_dgram(struct socket *sock,
  */
 static void apparmor_sock_graft(struct sock *sk, struct socket *parent)
 {
-	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	struct aa_sk_ctx *ctx = aa_sock(sk);

 	if (!ctx->label)
 		ctx->label = aa_get_current_label();
@@ -1159,7 +1141,7 @@ static void apparmor_sock_graft(struct sock *sk, struct socket *parent)
 static int apparmor_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
 				      struct request_sock *req)
 {
-	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	struct aa_sk_ctx *ctx = aa_sock(sk);

 	if (!skb->secmark)
 		return 0;
@@ -1176,6 +1158,7 @@ struct lsm_blob_sizes apparmor_blob_sizes __lsm_ro_after_init = {
 	.lbs_cred = sizeof(struct aa_task_ctx *),
 	.lbs_file = sizeof(struct aa_file_ctx),
 	.lbs_task = sizeof(struct aa_task_ctx),
+	.lbs_sock = sizeof(struct aa_sk_ctx),
 };

 static struct security_hook_list apparmor_hooks[] __lsm_ro_after_init = {
@@ -1212,7 +1195,6 @@ static struct security_hook_list apparmor_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(getprocattr, apparmor_getprocattr),
 	LSM_HOOK_INIT(setprocattr, apparmor_setprocattr),

-	LSM_HOOK_INIT(sk_alloc_security, apparmor_sk_alloc_security),
 	LSM_HOOK_INIT(sk_free_security, apparmor_sk_free_security),
 	LSM_HOOK_INIT(sk_clone_security, apparmor_sk_clone_security),

@@ -1764,7 +1746,7 @@ static unsigned int apparmor_ip_postroute(void *priv,
 	if (sk == NULL)
 		return NF_ACCEPT;

-	ctx = SK_CTX(sk);
+	ctx = aa_sock(sk);
 	if (!apparmor_secmark_check(ctx->label, OP_SENDMSG, AA_MAY_SEND,
 				    skb->secmark, sk))
 		return NF_ACCEPT;
diff --git a/security/security.c b/security/security.c
index 063c9cbbcea6..7f2bed1b2d6c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -29,6 +29,7 @@
 #include <linux/string.h>
 #include <linux/msg.h>
 #include <net/flow.h>
+#include <net/sock.h>

 #define MAX_LSM_EVM_XATTR	2

@@ -204,6 +205,7 @@ static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
 	lsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);
 	lsm_set_blob_size(&needed->lbs_ipc, &blob_sizes.lbs_ipc);
 	lsm_set_blob_size(&needed->lbs_msg_msg, &blob_sizes.lbs_msg_msg);
+	lsm_set_blob_size(&needed->lbs_sock, &blob_sizes.lbs_sock);
 	lsm_set_blob_size(&needed->lbs_superblock, &blob_sizes.lbs_superblock);
 	lsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);
 }
@@ -340,6 +342,7 @@ static void __init ordered_lsm_init(void)
 	init_debug("inode blob size      = %d\n", blob_sizes.lbs_inode);
 	init_debug("ipc blob size        = %d\n", blob_sizes.lbs_ipc);
 	init_debug("msg_msg blob size    = %d\n", blob_sizes.lbs_msg_msg);
+	init_debug("sock blob size       = %d\n", blob_sizes.lbs_sock);
 	init_debug("superblock blob size = %d\n", blob_sizes.lbs_superblock);
 	init_debug("task blob size       = %d\n", blob_sizes.lbs_task);

@@ -659,6 +662,28 @@ static int lsm_msg_msg_alloc(struct msg_msg *mp)
 	return 0;
 }

+/**
+ * lsm_sock_alloc - allocate a composite sock blob
+ * @sock: the sock that needs a blob
+ * @priority: allocation mode
+ *
+ * Allocate the sock blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+static int lsm_sock_alloc(struct sock *sock, gfp_t priority)
+{
+	if (blob_sizes.lbs_sock == 0) {
+		sock->sk_security = NULL;
+		return 0;
+	}
+
+	sock->sk_security = kzalloc(blob_sizes.lbs_sock, priority);
+	if (sock->sk_security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
 /**
  * lsm_early_task - during initialization allocate a composite task blob
  * @task: the task that needs a blob
@@ -2260,12 +2285,21 @@ EXPORT_SYMBOL(security_socket_getpeersec_dgram);

 int security_sk_alloc(struct sock *sk, int family, gfp_t priority)
 {
-	return call_int_hook(sk_alloc_security, 0, sk, family, priority);
+	int rc = lsm_sock_alloc(sk, priority);
+
+	if (unlikely(rc))
+		return rc;
+	rc = call_int_hook(sk_alloc_security, 0, sk, family, priority);
+	if (unlikely(rc))
+		security_sk_free(sk);
+	return rc;
 }

 void security_sk_free(struct sock *sk)
 {
 	call_void_hook(sk_free_security, sk);
+	kfree(sk->sk_security);
+	sk->sk_security = NULL;
 }

 void security_sk_clone(const struct sock *sk, struct sock *newsk)
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 62d30c0a30c2..90a140ea439d 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -4629,7 +4629,7 @@ static int socket_sockcreate_sid(const struct task_security_struct *tsec,

 static int sock_has_perm(struct sock *sk, u32 perms)
 {
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	struct common_audit_data ad;
 	struct lsm_network_audit net = {0,};

@@ -4686,7 +4686,7 @@ static int selinux_socket_post_create(struct socket *sock, int family,
 	isec->initialized = LABEL_INITIALIZED;

 	if (sock->sk) {
-		sksec = sock->sk->sk_security;
+		sksec = selinux_sock(sock->sk);
 		sksec->sclass = sclass;
 		sksec->sid = sid;
 		/* Allows detection of the first association on this socket */
@@ -4702,8 +4702,8 @@ static int selinux_socket_post_create(struct socket *sock, int family,
 static int selinux_socket_socketpair(struct socket *socka,
 				     struct socket *sockb)
 {
-	struct sk_security_struct *sksec_a = socka->sk->sk_security;
-	struct sk_security_struct *sksec_b = sockb->sk->sk_security;
+	struct sk_security_struct *sksec_a = selinux_sock(socka->sk);
+	struct sk_security_struct *sksec_b = selinux_sock(sockb->sk);

 	sksec_a->peer_sid = sksec_b->sid;
 	sksec_b->peer_sid = sksec_a->sid;
@@ -4718,7 +4718,7 @@ static int selinux_socket_socketpair(struct socket *socka,
 static int selinux_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
 {
 	struct sock *sk = sock->sk;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	u16 family;
 	int err;

@@ -4853,7 +4853,7 @@ static int selinux_socket_connect_helper(struct socket *sock,
 					 struct sockaddr *address, int addrlen)
 {
 	struct sock *sk = sock->sk;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	int err;

 	err = sock_has_perm(sk, SOCKET__CONNECT);
@@ -5032,9 +5032,9 @@ static int selinux_socket_unix_stream_connect(struct sock *sock,
 					      struct sock *other,
 					      struct sock *newsk)
 {
-	struct sk_security_struct *sksec_sock = sock->sk_security;
-	struct sk_security_struct *sksec_other = other->sk_security;
-	struct sk_security_struct *sksec_new = newsk->sk_security;
+	struct sk_security_struct *sksec_sock = selinux_sock(sock);
+	struct sk_security_struct *sksec_other = selinux_sock(other);
+	struct sk_security_struct *sksec_new = selinux_sock(newsk);
 	struct common_audit_data ad;
 	struct lsm_network_audit net = {0,};
 	int err;
@@ -5066,8 +5066,8 @@ static int selinux_socket_unix_stream_connect(struct sock *sock,
 static int selinux_socket_unix_may_send(struct socket *sock,
 					struct socket *other)
 {
-	struct sk_security_struct *ssec = sock->sk->sk_security;
-	struct sk_security_struct *osec = other->sk->sk_security;
+	struct sk_security_struct *ssec = selinux_sock(sock->sk);
+	struct sk_security_struct *osec = selinux_sock(other->sk);
 	struct common_audit_data ad;
 	struct lsm_network_audit net = {0,};

@@ -5109,7 +5109,7 @@ static int selinux_sock_rcv_skb_compat(struct sock *sk, struct sk_buff *skb,
 				       u16 family)
 {
 	int err = 0;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	u32 sk_sid = sksec->sid;
 	struct common_audit_data ad;
 	struct lsm_network_audit net = {0,};
@@ -5142,7 +5142,7 @@ static int selinux_sock_rcv_skb_compat(struct sock *sk, struct sk_buff *skb,
 static int selinux_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	int err;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	u16 family = sk->sk_family;
 	u32 sk_sid = sksec->sid;
 	struct common_audit_data ad;
@@ -5210,13 +5210,15 @@ static int selinux_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 	return err;
 }

-static int selinux_socket_getpeersec_stream(struct socket *sock, char __user *optval,
-					    int __user *optlen, unsigned len)
+static int selinux_socket_getpeersec_stream(struct socket *sock,
+					    char __user *optval,
+					    int __user *optlen,
+					    unsigned int len)
 {
 	int err = 0;
 	char *scontext;
 	u32 scontext_len;
-	struct sk_security_struct *sksec = sock->sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sock->sk);
 	u32 peer_sid = SECSID_NULL;

 	if (sksec->sclass == SECCLASS_UNIX_STREAM_SOCKET ||
@@ -5276,34 +5278,27 @@ static int selinux_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *

 static int selinux_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
 {
-	struct sk_security_struct *sksec;
-
-	sksec = kzalloc(sizeof(*sksec), priority);
-	if (!sksec)
-		return -ENOMEM;
+	struct sk_security_struct *sksec = selinux_sock(sk);

 	sksec->peer_sid = SECINITSID_UNLABELED;
 	sksec->sid = SECINITSID_UNLABELED;
 	sksec->sclass = SECCLASS_SOCKET;
 	selinux_netlbl_sk_security_reset(sksec);
-	sk->sk_security = sksec;

 	return 0;
 }

 static void selinux_sk_free_security(struct sock *sk)
 {
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);

-	sk->sk_security = NULL;
 	selinux_netlbl_sk_security_free(sksec);
-	kfree(sksec);
 }

 static void selinux_sk_clone_security(const struct sock *sk, struct sock *newsk)
 {
-	struct sk_security_struct *sksec = sk->sk_security;
-	struct sk_security_struct *newsksec = newsk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
+	struct sk_security_struct *newsksec = selinux_sock(newsk);

 	newsksec->sid = sksec->sid;
 	newsksec->peer_sid = sksec->peer_sid;
@@ -5317,7 +5312,7 @@ static void selinux_sk_getsecid(struct sock *sk, u32 *secid)
 	if (!sk)
 		*secid = SECINITSID_ANY_SOCKET;
 	else {
-		struct sk_security_struct *sksec = sk->sk_security;
+		struct sk_security_struct *sksec = selinux_sock(sk);

 		*secid = sksec->sid;
 	}
@@ -5327,7 +5322,7 @@ static void selinux_sock_graft(struct sock *sk, struct socket *parent)
 {
 	struct inode_security_struct *isec =
 		inode_security_novalidate(SOCK_INODE(parent));
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);

 	if (sk->sk_family == PF_INET || sk->sk_family == PF_INET6 ||
 	    sk->sk_family == PF_UNIX)
@@ -5342,7 +5337,7 @@ static void selinux_sock_graft(struct sock *sk, struct socket *parent)
 static int selinux_sctp_assoc_request(struct sctp_association *asoc,
 				      struct sk_buff *skb)
 {
-	struct sk_security_struct *sksec = asoc->base.sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(asoc->base.sk);
 	struct common_audit_data ad;
 	struct lsm_network_audit net = {0,};
 	u8 peerlbl_active;
@@ -5493,8 +5488,8 @@ static int selinux_sctp_bind_connect(struct sock *sk, int optname,
 static void selinux_sctp_sk_clone(struct sctp_association *asoc, struct sock *sk,
 				  struct sock *newsk)
 {
-	struct sk_security_struct *sksec = sk->sk_security;
-	struct sk_security_struct *newsksec = newsk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
+	struct sk_security_struct *newsksec = selinux_sock(newsk);

 	/* If policy does not support SECCLASS_SCTP_SOCKET then call
 	 * the non-sctp clone version.
@@ -5511,7 +5506,7 @@ static void selinux_sctp_sk_clone(struct sctp_association *asoc, struct sock *sk
 static int selinux_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
 				     struct request_sock *req)
 {
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	int err;
 	u16 family = req->rsk_ops->family;
 	u32 connsid;
@@ -5532,7 +5527,7 @@ static int selinux_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
 static void selinux_inet_csk_clone(struct sock *newsk,
 				   const struct request_sock *req)
 {
-	struct sk_security_struct *newsksec = newsk->sk_security;
+	struct sk_security_struct *newsksec = selinux_sock(newsk);

 	newsksec->sid = req->secid;
 	newsksec->peer_sid = req->peer_secid;
@@ -5549,7 +5544,7 @@ static void selinux_inet_csk_clone(struct sock *newsk,
 static void selinux_inet_conn_established(struct sock *sk, struct sk_buff *skb)
 {
 	u16 family = sk->sk_family;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);

 	/* handle mapped IPv4 packets arriving via IPv6 sockets */
 	if (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))
@@ -5633,7 +5628,7 @@ static int selinux_tun_dev_attach_queue(void *security)
 static int selinux_tun_dev_attach(struct sock *sk, void *security)
 {
 	struct tun_security_struct *tunsec = security;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);

 	/* we don't currently perform any NetLabel based labeling here and it
 	 * isn't clear that we would want to do so anyway; while we could apply
@@ -5762,7 +5757,7 @@ static unsigned int selinux_ip_output(void *priv, struct sk_buff *skb,
 			return NF_ACCEPT;

 		/* standard practice, label using the parent socket */
-		sksec = sk->sk_security;
+		sksec = selinux_sock(sk);
 		sid = sksec->sid;
 	} else
 		sid = SECINITSID_KERNEL;
@@ -5785,7 +5780,7 @@ static unsigned int selinux_ip_postroute_compat(struct sk_buff *skb,
 	sk = skb_to_full_sk(skb);
 	if (sk == NULL)
 		return NF_ACCEPT;
-	sksec = sk->sk_security;
+	sksec = selinux_sock(sk);

 	ad.type = LSM_AUDIT_DATA_NET;
 	ad.u.net = &net;
@@ -5878,7 +5873,7 @@ static unsigned int selinux_ip_postroute(void *priv,
 		u32 skb_sid;
 		struct sk_security_struct *sksec;

-		sksec = sk->sk_security;
+		sksec = selinux_sock(sk);
 		if (selinux_skb_peerlbl_sid(skb, family, &skb_sid))
 			return NF_DROP;
 		/* At this point, if the returned skb peerlbl is SECSID_NULL
@@ -5907,7 +5902,7 @@ static unsigned int selinux_ip_postroute(void *priv,
 	} else {
 		/* Locally generated packet, fetch the security label from the
 		 * associated socket. */
-		struct sk_security_struct *sksec = sk->sk_security;
+		struct sk_security_struct *sksec = selinux_sock(sk);
 		peer_sid = sksec->sid;
 		secmark_perm = PACKET__SEND;
 	}
@@ -5956,7 +5951,7 @@ static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)
 	unsigned int data_len = skb->len;
 	unsigned char *data = skb->data;
 	struct nlmsghdr *nlh;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	u16 sclass = sksec->sclass;
 	u32 perm;

@@ -6956,6 +6951,7 @@ struct lsm_blob_sizes selinux_blob_sizes __lsm_ro_after_init = {
 	.lbs_inode = sizeof(struct inode_security_struct),
 	.lbs_ipc = sizeof(struct ipc_security_struct),
 	.lbs_msg_msg = sizeof(struct msg_security_struct),
+	.lbs_sock = sizeof(struct sk_security_struct),
 	.lbs_superblock = sizeof(struct superblock_security_struct),
 };

diff --git a/security/selinux/include/objsec.h b/security/selinux/include/objsec.h
index 2953132408bf..007d1ae7ee27 100644
--- a/security/selinux/include/objsec.h
+++ b/security/selinux/include/objsec.h
@@ -194,4 +194,9 @@ static inline struct superblock_security_struct *selinux_superblock(
 	return superblock->s_security + selinux_blob_sizes.lbs_superblock;
 }

+static inline struct sk_security_struct *selinux_sock(const struct sock *sock)
+{
+	return sock->sk_security + selinux_blob_sizes.lbs_sock;
+}
+
 #endif /* _SELINUX_OBJSEC_H_ */
diff --git a/security/selinux/netlabel.c b/security/selinux/netlabel.c
index 1321f15799e2..800ab4b4239e 100644
--- a/security/selinux/netlabel.c
+++ b/security/selinux/netlabel.c
@@ -17,6 +17,7 @@
 #include <linux/gfp.h>
 #include <linux/ip.h>
 #include <linux/ipv6.h>
+#include <linux/lsm_hooks.h>
 #include <net/sock.h>
 #include <net/netlabel.h>
 #include <net/ip.h>
@@ -68,7 +69,7 @@ static int selinux_netlbl_sidlookup_cached(struct sk_buff *skb,
 static struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)
 {
 	int rc;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	struct netlbl_lsm_secattr *secattr;

 	if (sksec->nlbl_secattr != NULL)
@@ -101,7 +102,7 @@ static struct netlbl_lsm_secattr *selinux_netlbl_sock_getattr(
 							const struct sock *sk,
 							u32 sid)
 {
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	struct netlbl_lsm_secattr *secattr = sksec->nlbl_secattr;

 	if (secattr == NULL)
@@ -236,7 +237,7 @@ int selinux_netlbl_skbuff_setsid(struct sk_buff *skb,
 	 * being labeled by it's parent socket, if it is just exit */
 	sk = skb_to_full_sk(skb);
 	if (sk != NULL) {
-		struct sk_security_struct *sksec = sk->sk_security;
+		struct sk_security_struct *sksec = selinux_sock(sk);

 		if (sksec->nlbl_state != NLBL_REQSKB)
 			return 0;
@@ -274,7 +275,7 @@ int selinux_netlbl_sctp_assoc_request(struct sctp_association *asoc,
 {
 	int rc;
 	struct netlbl_lsm_secattr secattr;
-	struct sk_security_struct *sksec = asoc->base.sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(asoc->base.sk);
 	struct sockaddr_in addr4;
 	struct sockaddr_in6 addr6;

@@ -355,7 +356,7 @@ int selinux_netlbl_inet_conn_request(struct request_sock *req, u16 family)
  */
 void selinux_netlbl_inet_csk_clone(struct sock *sk, u16 family)
 {
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);

 	if (family == PF_INET)
 		sksec->nlbl_state = NLBL_LABELED;
@@ -373,8 +374,8 @@ void selinux_netlbl_inet_csk_clone(struct sock *sk, u16 family)
  */
 void selinux_netlbl_sctp_sk_clone(struct sock *sk, struct sock *newsk)
 {
-	struct sk_security_struct *sksec = sk->sk_security;
-	struct sk_security_struct *newsksec = newsk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
+	struct sk_security_struct *newsksec = selinux_sock(newsk);

 	newsksec->nlbl_state = sksec->nlbl_state;
 }
@@ -392,7 +393,7 @@ void selinux_netlbl_sctp_sk_clone(struct sock *sk, struct sock *newsk)
 int selinux_netlbl_socket_post_create(struct sock *sk, u16 family)
 {
 	int rc;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	struct netlbl_lsm_secattr *secattr;

 	if (family != PF_INET && family != PF_INET6)
@@ -507,7 +508,7 @@ int selinux_netlbl_socket_setsockopt(struct socket *sock,
 {
 	int rc = 0;
 	struct sock *sk = sock->sk;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	struct netlbl_lsm_secattr secattr;

 	if (selinux_netlbl_option(level, optname) &&
@@ -545,7 +546,7 @@ static int selinux_netlbl_socket_connect_helper(struct sock *sk,
 						struct sockaddr *addr)
 {
 	int rc;
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);
 	struct netlbl_lsm_secattr *secattr;

 	/* connected sockets are allowed to disconnect when the address family
@@ -584,7 +585,7 @@ static int selinux_netlbl_socket_connect_helper(struct sock *sk,
 int selinux_netlbl_socket_connect_locked(struct sock *sk,
 					 struct sockaddr *addr)
 {
-	struct sk_security_struct *sksec = sk->sk_security;
+	struct sk_security_struct *sksec = selinux_sock(sk);

 	if (sksec->nlbl_state != NLBL_REQSKB &&
 	    sksec->nlbl_state != NLBL_CONNLABELED)
diff --git a/security/smack/smack.h b/security/smack/smack.h
index 99c3422596ab..66b813e15196 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -363,6 +363,11 @@ static inline struct superblock_smack *smack_superblock(
 	return superblock->s_security + smack_blob_sizes.lbs_superblock;
 }

+static inline struct socket_smack *smack_sock(const struct sock *sock)
+{
+	return sock->sk_security + smack_blob_sizes.lbs_sock;
+}
+
 /*
  * Is the directory transmuting?
  */
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index efd35b07c7f8..db72debca070 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -1434,7 +1434,7 @@ static int smack_inode_getsecurity(struct user_namespace *mnt_userns,
 		if (sock == NULL || sock->sk == NULL)
 			return -EOPNOTSUPP;

-		ssp = sock->sk->sk_security;
+		ssp = smack_sock(sock->sk);

 		if (strcmp(name, XATTR_SMACK_IPIN) == 0)
 			isp = ssp->smk_in;
@@ -1817,7 +1817,7 @@ static int smack_file_receive(struct file *file)

 	if (inode->i_sb->s_magic == SOCKFS_MAGIC) {
 		sock = SOCKET_I(inode);
-		ssp = sock->sk->sk_security;
+		ssp = smack_sock(sock->sk);
 		tsp = smack_cred(current_cred());
 		/*
 		 * If the receiving process can't write to the
@@ -2238,11 +2238,7 @@ static void smack_task_to_inode(struct task_struct *p, struct inode *inode)
 static int smack_sk_alloc_security(struct sock *sk, int family, gfp_t gfp_flags)
 {
 	struct smack_known *skp = smk_of_current();
-	struct socket_smack *ssp;
-
-	ssp = kzalloc(sizeof(struct socket_smack), gfp_flags);
-	if (ssp == NULL)
-		return -ENOMEM;
+	struct socket_smack *ssp = smack_sock(sk);

 	/*
 	 * Sockets created by kernel threads receive web label.
@@ -2256,11 +2252,10 @@ static int smack_sk_alloc_security(struct sock *sk, int family, gfp_t gfp_flags)
 	}
 	ssp->smk_packet = NULL;

-	sk->sk_security = ssp;
-
 	return 0;
 }

+#ifdef SMACK_IPV6_PORT_LABELING
 /**
  * smack_sk_free_security - Free a socket blob
  * @sk: the socket
@@ -2269,7 +2264,6 @@ static int smack_sk_alloc_security(struct sock *sk, int family, gfp_t gfp_flags)
  */
 static void smack_sk_free_security(struct sock *sk)
 {
-#ifdef SMACK_IPV6_PORT_LABELING
 	struct smk_port_label *spp;

 	if (sk->sk_family == PF_INET6) {
@@ -2282,9 +2276,8 @@ static void smack_sk_free_security(struct sock *sk)
 		}
 		rcu_read_unlock();
 	}
-#endif
-	kfree(sk->sk_security);
 }
+#endif

 /**
 * smack_ipv4host_label - check host based restrictions
@@ -2397,7 +2390,7 @@ static struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)
  */
 static int smack_netlbl_add(struct sock *sk)
 {
-	struct socket_smack *ssp = sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sk);
 	struct smack_known *skp = ssp->smk_out;
 	int rc;

@@ -2429,7 +2422,7 @@ static int smack_netlbl_add(struct sock *sk)
  */
 static void smack_netlbl_delete(struct sock *sk)
 {
-	struct socket_smack *ssp = sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sk);

 	/*
 	 * Take the label off the socket if one is set.
@@ -2461,7 +2454,7 @@ static int smk_ipv4_check(struct sock *sk, struct sockaddr_in *sap)
 	struct smack_known *skp;
 	int rc = 0;
 	struct smack_known *hkp;
-	struct socket_smack *ssp = sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sk);
 	struct smk_audit_info ad;

 	rcu_read_lock();
@@ -2534,7 +2527,7 @@ static void smk_ipv6_port_label(struct socket *sock, struct sockaddr *address)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_in6 *addr6;
-	struct socket_smack *ssp = sock->sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sock->sk);
 	struct smk_port_label *spp;
 	unsigned short port = 0;

@@ -2622,7 +2615,7 @@ static int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,
 				int act)
 {
 	struct smk_port_label *spp;
-	struct socket_smack *ssp = sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sk);
 	struct smack_known *skp = NULL;
 	unsigned short port;
 	struct smack_known *object;
@@ -2716,7 +2709,7 @@ static int smack_inode_setsecurity(struct inode *inode, const char *name,
 	if (sock == NULL || sock->sk == NULL)
 		return -EOPNOTSUPP;

-	ssp = sock->sk->sk_security;
+	ssp = smack_sock(sock->sk);

 	if (strcmp(name, XATTR_SMACK_IPIN) == 0)
 		ssp->smk_in = skp;
@@ -2764,7 +2757,7 @@ static int smack_socket_post_create(struct socket *sock, int family,
 	 * Sockets created by kernel threads receive web label.
 	 */
 	if (unlikely(current->flags & PF_KTHREAD)) {
-		ssp = sock->sk->sk_security;
+		ssp = smack_sock(sock->sk);
 		ssp->smk_in = &smack_known_web;
 		ssp->smk_out = &smack_known_web;
 	}
@@ -2789,8 +2782,8 @@ static int smack_socket_post_create(struct socket *sock, int family,
 static int smack_socket_socketpair(struct socket *socka,
 		                   struct socket *sockb)
 {
-	struct socket_smack *asp = socka->sk->sk_security;
-	struct socket_smack *bsp = sockb->sk->sk_security;
+	struct socket_smack *asp = smack_sock(socka->sk);
+	struct socket_smack *bsp = smack_sock(sockb->sk);

 	asp->smk_packet = bsp->smk_out;
 	bsp->smk_packet = asp->smk_out;
@@ -2853,7 +2846,7 @@ static int smack_socket_connect(struct socket *sock, struct sockaddr *sap,
 		if (__is_defined(SMACK_IPV6_SECMARK_LABELING))
 			rsp = smack_ipv6host_label(sip);
 		if (rsp != NULL) {
-			struct socket_smack *ssp = sock->sk->sk_security;
+			struct socket_smack *ssp = smack_sock(sock->sk);

 			rc = smk_ipv6_check(ssp->smk_out, rsp, sip,
 					    SMK_CONNECTING);
@@ -3584,9 +3577,9 @@ static int smack_unix_stream_connect(struct sock *sock,
 {
 	struct smack_known *skp;
 	struct smack_known *okp;
-	struct socket_smack *ssp = sock->sk_security;
-	struct socket_smack *osp = other->sk_security;
-	struct socket_smack *nsp = newsk->sk_security;
+	struct socket_smack *ssp = smack_sock(sock);
+	struct socket_smack *osp = smack_sock(other);
+	struct socket_smack *nsp = smack_sock(newsk);
 	struct smk_audit_info ad;
 	int rc = 0;
 #ifdef CONFIG_AUDIT
@@ -3632,8 +3625,8 @@ static int smack_unix_stream_connect(struct sock *sock,
  */
 static int smack_unix_may_send(struct socket *sock, struct socket *other)
 {
-	struct socket_smack *ssp = sock->sk->sk_security;
-	struct socket_smack *osp = other->sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sock->sk);
+	struct socket_smack *osp = smack_sock(other->sk);
 	struct smk_audit_info ad;
 	int rc;

@@ -3670,7 +3663,7 @@ static int smack_socket_sendmsg(struct socket *sock, struct msghdr *msg,
 	struct sockaddr_in6 *sap = (struct sockaddr_in6 *) msg->msg_name;
 #endif
 #ifdef SMACK_IPV6_SECMARK_LABELING
-	struct socket_smack *ssp = sock->sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sock->sk);
 	struct smack_known *rsp;
 #endif
 	int rc = 0;
@@ -3882,7 +3875,7 @@ static struct smack_known *smack_from_netlbl(const struct sock *sk, u16 family,
 	netlbl_secattr_init(&secattr);

 	if (sk)
-		ssp = sk->sk_security;
+		ssp = smack_sock(sk);

 	if (netlbl_skbuff_getattr(skb, family, &secattr) == 0) {
 		skp = smack_from_secattr(&secattr, ssp);
@@ -3904,7 +3897,7 @@ static struct smack_known *smack_from_netlbl(const struct sock *sk, u16 family,
  */
 static int smack_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
-	struct socket_smack *ssp = sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sk);
 	struct smack_known *skp = NULL;
 	int rc = 0;
 	struct smk_audit_info ad;
@@ -4008,7 +4001,7 @@ static int smack_socket_getpeersec_stream(struct socket *sock,
 	int slen = 1;
 	int rc = 0;

-	ssp = sock->sk->sk_security;
+	ssp = smack_sock(sock->sk);
 	if (ssp->smk_packet != NULL) {
 		rcp = ssp->smk_packet->smk_known;
 		slen = strlen(rcp) + 1;
@@ -4057,7 +4050,7 @@ static int smack_socket_getpeersec_dgram(struct socket *sock,

 	switch (family) {
 	case PF_UNIX:
-		ssp = sock->sk->sk_security;
+		ssp = smack_sock(sock->sk);
 		s = ssp->smk_out->smk_secid;
 		break;
 	case PF_INET:
@@ -4106,7 +4099,7 @@ static void smack_sock_graft(struct sock *sk, struct socket *parent)
 	    (sk->sk_family != PF_INET && sk->sk_family != PF_INET6))
 		return;

-	ssp = sk->sk_security;
+	ssp = smack_sock(sk);
 	ssp->smk_in = skp;
 	ssp->smk_out = skp;
 	/* cssp->smk_packet is already set in smack_inet_csk_clone() */
@@ -4126,7 +4119,7 @@ static int smack_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
 {
 	u16 family = sk->sk_family;
 	struct smack_known *skp;
-	struct socket_smack *ssp = sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sk);
 	struct sockaddr_in addr;
 	struct iphdr *hdr;
 	struct smack_known *hskp;
@@ -4212,7 +4205,7 @@ static int smack_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
 static void smack_inet_csk_clone(struct sock *sk,
 				 const struct request_sock *req)
 {
-	struct socket_smack *ssp = sk->sk_security;
+	struct socket_smack *ssp = smack_sock(sk);
 	struct smack_known *skp;

 	if (req->peer_secid != 0) {
@@ -4748,6 +4741,7 @@ struct lsm_blob_sizes smack_blob_sizes __lsm_ro_after_init = {
 	.lbs_inode = sizeof(struct inode_smack),
 	.lbs_ipc = sizeof(struct smack_known *),
 	.lbs_msg_msg = sizeof(struct smack_known *),
+	.lbs_sock = sizeof(struct socket_smack),
 	.lbs_superblock = sizeof(struct superblock_smack),
 };

@@ -4858,7 +4852,9 @@ static struct security_hook_list smack_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(socket_getpeersec_stream, smack_socket_getpeersec_stream),
 	LSM_HOOK_INIT(socket_getpeersec_dgram, smack_socket_getpeersec_dgram),
 	LSM_HOOK_INIT(sk_alloc_security, smack_sk_alloc_security),
+#ifdef SMACK_IPV6_PORT_LABELING
 	LSM_HOOK_INIT(sk_free_security, smack_sk_free_security),
+#endif
 	LSM_HOOK_INIT(sock_graft, smack_sock_graft),
 	LSM_HOOK_INIT(inet_conn_request, smack_inet_conn_request),
 	LSM_HOOK_INIT(inet_csk_clone, smack_inet_csk_clone),
diff --git a/security/smack/smack_netfilter.c b/security/smack/smack_netfilter.c
index b945c1d3a743..bad71b7e648d 100644
--- a/security/smack/smack_netfilter.c
+++ b/security/smack/smack_netfilter.c
@@ -26,8 +26,8 @@ static unsigned int smack_ip_output(void *priv,
 	struct socket_smack *ssp;
 	struct smack_known *skp;

-	if (sk && sk->sk_security) {
-		ssp = sk->sk_security;
+	if (sk) {
+		ssp = smack_sock(sk);
 		skp = ssp->smk_out;
 		skb->secmark = skp->smk_secid;
 	}
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 32CECC433F5
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:47:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235108AbhKXBuK (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:50:10 -0500
Received: from sonic302-26.consmr.mail.ne1.yahoo.com ([66.163.186.152]:44259
        "EHLO sonic302-26.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S229549AbhKXBuJ (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:50:09 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718420; bh=yaXYcBfvMbg/h8f5VdHhlT6LmT6wOArB3lESF9Mmz1c=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=IuuKUfowADa4hWYiLvdraG3cHI31+GEtLiQ+qVkLonoYwEWr3H6lMMVuUA3u4oXZuU3l9P2JOKbdQl83DuEyiYIInGMeRyXW37nEf/KMx0hCwV3ZOrUN+MmT5I2jLy5ANAo+HtjK60iNr5eEaDJcMoQ7vWD0lP+ky5zb66UooPH5NsCtjt+fsHDi/DhJ0YTheeGYuPtkODujv8sd+Ov3Qkrc+kjhT0uCagHB2RznTyYRo9ArsefFi6ZedoMEKzyiHcE9ved4+nVa/oi4u8OAG0lAq1o/WYw1SZsJthXFQsj0gTO8UA7Bq/pBbVj8n6e/stuQtGSBk0qn71DehNadxA==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718420; bh=vIpxFb/sAvz2wi3vIiLP51GJpzVKEHgG0y4aFVEq2re=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=VrI6DwC2+AVN6g3+f/OGr0HYRL0g0JKvMwWYpXr64bFrtWuDiMMMC8iE41xB5R8/FBOAxZTeFxVupZVhpgb3Cq94VwhkKqPTiWrYJbnIjK0RDtpJSV7Ps5sPCVPOpnGfSnWZgkxnhMPSlmTtmYjnp4W04whvCWkln/PMykgGuGih3YQ+6QtrCWYd3pGZo9DoQ6A8im+tTrtfVPnbqcZoqCU4vQT9PYsxKppJUtp5qS81p5bfvq/daQobEYUls1itF7YP2FD2oF6Ajsgxs56KkcEUZWikqPstZLmbo+UNMVDEqSG9pv8H1eFRfUTzNOdRQiWyQmf3zQ1AzsmKIEyXBQ==
X-YMail-OSG: 76vxxvMVM1mT4nNjie_S_MYJ4E6vyn6HxmxZndz8PtT6bQAikbco_o_TdVzafHW
 L2A42fkiqnrD85dZN.81b9KjRP0DNwd13K9.fUEauHdQ4si4SDADYb3IP0Vz_Lkpm1vaacOZ_92s
 Zfwj1cyb_5tzHXcmoQN4LrlY3tbQyw6otf9EfpKnHaHLEiI2k2Bw1OVcNBMbRWUP_UkcP5oyQjFu
 wmtOq1kZMwWDz1tKYLJWLZtBgpW3Ka1Y7SQnVvCQuJ3pnTMvZ7X08QDpV6.GS1FJ37zc1G9Smuy8
 0qWY03XiXCGMabzb3IfpaJ9Dtqj0l9dByMbNoZc.Hiz9LchAehlaOj3oaNBUowQU7yFjaURFkrQs
 SH.DtobBFzpYHyiOJDMUufGKRI9kU0OPTDNMysfmpm0ovc0TXZeNLlGe8Vq0g3VZNMicFrB09w7p
 RMQei2mCpsJxZhbi8s970B2gyQbFWe44Y.ptChuJxhYU0n_.vuSnwpaDCjRmaYYejMjMcf6zn2tV
 5hqStfArGwYzcqHxMouDN_LjUFVDnTR_IPtREJ9795LGW6ZpZMRKvS4UonnByD4zY1F88Wr2ItzB
 GJM7ZD8VG4RDdRCrfHiMIv4TkL5a91f9pXeOKW2YGVOW7UZpjUxdRBNvCxM5G9NOccSYslgKbhl8
 Uc0sRa6Cn2OXDiol_ju7Ha0M_Fe1J6MrSHRednNcwOnN7s8vSkm5D8XPREsIrhmRNxaNiMqKbmNt
 m_iLjW9fK0jnwRq7PGju2skEOzuYsHkT2xWuo145JGoEmbb0rBJaV.HfXDUq_yxD7hI.ko3ypnkj
 aPfmpR.niofUDhCC7dpK3P2WzQItHm_Mqk_LAqUlFqTYmacOkK.1VbLuZsdYz.tu9jeuRODkGOst
 wSoBhXjo3Ybwqy7824QcOiISr5tScZXwK_b3dxH2ftcvmKN14HG_s7_SNAukcM9sKetO3Vm74bUe
 EPxVjzG7NaQ87OdtPjSfZ3DnB1EEVv5hR8Ujxvgpxa6pt6tfD1sEgWYOzKaw3CouGSlf98LaqfAX
 WHWPRqKhdxgVSsZWaRxdeImzGIqrn4i48WtWVe1DeR.T6o8QH8qcgURly52gGeDvw_GBiPGOnCg8
 2FFsSVj8g68E_TFSaej5PYx_yyDubB5Bh2RCIvjG1aBjbdNiTdDBBaDG6JLLZcPR9c57e7sjPJwx
 brmnZ45bG4FnF3XghOJM0fJW81Z3AFsBOmgTUr7Me3iySuewA7J9bSqGdwGoZHG0.lKyvvxP4YkK
 29Fiyt6zQUqAc8aIxDJpozeksqFEN1CvHGfBmaPOzKZeT6e7WSDTxtDiX_Kd8905kPGIqU9Uvc9I
 RnTLueTL5zLYvF2uzp4zbNXyoWPKyQhyxN1MFvfIQYs0D6W0IVeXMmoVXV9XHIxva1KwMpTu4Uzf
 y_MAaZLmpsVEir3fiFmsuZcDrZ7NcYMwI_JdVUBSUFv7PZYwSEZpLfIhLkkuDTennqXtUug_oCre
 lRrBQ1jAmdpItabT75mWmGBOLd2_B8KoLml_I2Exs1CJIuIXk7vGZj55REtyZ.5oVkgQdD_CfHIy
 JUPIGacsNTaVnU59kfOowv0UDIwdSHf.H0wAGy.kO5C39pqZWp7dA._oY5vD9kIsthyvxcOJbvhT
 m4CnU3mHUFzgD3uaCE.4kLusHTz2uscWZ.P8laC_f1lvptGVzlV_EwDjnm07g_bAL5lCsDYVL_oF
 q6_0Xb6hIJUa2bGhP5kJr8iyz3bQ8Gid9wvhkI8Pkw3ROeDCeNBHiy6LGsee_I.w09Ri.JPYVd4n
 JQ8X5uA5Maltdii0OI.Dec5RHl6hLX2FAQHY9GxPYLt3BkZkXckZvWZ3dyqKxX6bYRyOLaOHp9SI
 mjolUSrz72lzr0ZIuDJ1CMuMA4e1NSTyhysxnOAF8l54I.qOebdSltw2hquk4r28P0HwT7mwVKwD
 9tnRTDl2j2wJwHjP4PYJPSi_uuxGTri9sRfYXL9xFO7hQc4z2mlKE9gu1X1pCHeU8hv_pjb0ANXt
 8_8fLFdohmZ2jc0WlntlFpHLJEE.T09pzaIFcoEowTVDMIjRv6kR38dPs5hznPXjlPrTPtG9qhxG
 1lCnx3bVNUHmNn_iuMVSWhG_XGQiTQiqJcA.oKY0cqB_VIvl0E.UFMcYdMBGFE3TOD5EyocfsqGT
 ewKV8Oxfe4SLGldcAhIBs2fJhq5axgrda7Hu46Jwnu34O4wJq_U9vVDS_37cEMj9WfZ3UZmyplSs
 cn..Uu0JaNPOf8rLhec5TiazTfEalwGmH2fqk6zRHSbAbdhr9JbtrsD9CdlY4W5NbXINcmG9FyA.
 HGwJafG_J
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic302.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:47:00 +0000
Received: by kubenode503.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 794376d1dc8ecb7ff8b0989e9cfd1d7e;
          Wed, 24 Nov 2021 01:46:58 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 03/28] LSM: Add the lsmblob data structure.
Date:   Tue, 23 Nov 2021 17:43:07 -0800
Message-Id: <20211124014332.36128-4-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

When more than one security module is exporting data to
audit and networking sub-systems a single 32 bit integer
is no longer sufficient to represent the data. Add a
structure to be used instead.

The lsmblob structure is currently an array of
u32 "secids". There is an entry for each of the
security modules built into the system that would
use secids if active. The system assigns the module
a "slot" when it registers hooks. If modules are
compiled in but not registered there will be unused
slots.

A new lsm_id structure, which contains the name
of the LSM and its slot number, is created. There
is an instance for each LSM, which assigns the name
and passes it to the infrastructure to set the slot.

The audit rules data is expanded to use an array of
security module data rather than a single instance.
A new structure audit_rules is defined to avoid the
confusion which commonly accompanies the use of
void ** parameters.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 include/linux/audit.h        | 10 ++++-
 include/linux/lsm_hooks.h    | 12 +++++-
 include/linux/security.h     | 74 +++++++++++++++++++++++++++++---
 kernel/auditfilter.c         | 24 ++++++-----
 kernel/auditsc.c             | 17 +++-----
 security/apparmor/lsm.c      |  7 ++-
 security/bpf/hooks.c         | 12 +++++-
 security/commoncap.c         |  7 ++-
 security/landlock/cred.c     |  2 +-
 security/landlock/fs.c       |  2 +-
 security/landlock/ptrace.c   |  2 +-
 security/landlock/setup.c    |  5 +++
 security/landlock/setup.h    |  1 +
 security/loadpin/loadpin.c   |  8 +++-
 security/lockdown/lockdown.c |  7 ++-
 security/safesetid/lsm.c     |  8 +++-
 security/security.c          | 82 ++++++++++++++++++++++++++++++------
 security/selinux/hooks.c     |  8 +++-
 security/smack/smack_lsm.c   |  7 ++-
 security/tomoyo/tomoyo.c     |  8 +++-
 security/yama/yama_lsm.c     |  7 ++-
 21 files changed, 254 insertions(+), 56 deletions(-)

diff --git a/include/linux/audit.h b/include/linux/audit.h
index d06134ac6245..943584128399 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -11,6 +11,7 @@

 #include <linux/sched.h>
 #include <linux/ptrace.h>
+#include <linux/security.h>
 #include <linux/audit_arch.h>
 #include <uapi/linux/audit.h>
 #include <uapi/linux/netfilter/nf_tables.h>
@@ -59,6 +60,10 @@ struct audit_krule {
 /* Flag to indicate legacy AUDIT_LOGINUID unset usage */
 #define AUDIT_LOGINUID_LEGACY		0x1

+struct audit_rules {
+	void	*rule[LSMBLOB_ENTRIES];
+};
+
 struct audit_field {
 	u32				type;
 	union {
@@ -66,8 +71,9 @@ struct audit_field {
 		kuid_t			uid;
 		kgid_t			gid;
 		struct {
-			char		*lsm_str;
-			void		*lsm_rule;
+			bool			lsm_isset;
+			char			*lsm_str;
+			struct audit_rules	lsm_rules;
 		};
 	};
 	u32				op;
diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
index 89b8e40186f8..490545f0db6d 100644
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@ -1586,6 +1586,14 @@ struct security_hook_heads {
 	#undef LSM_HOOK
 } __randomize_layout;

+/*
+ * Information that identifies a security module.
+ */
+struct lsm_id {
+	const char	*lsm;	/* Name of the LSM */
+	int		slot;	/* Slot in lsmblob if one is allocated */
+};
+
 /*
  * Security module hook list structure.
  * For use with generic list macros for common operations.
@@ -1594,7 +1602,7 @@ struct security_hook_list {
 	struct hlist_node		list;
 	struct hlist_head		*head;
 	union security_list_options	hook;
-	char				*lsm;
+	struct lsm_id			*lsmid;
 } __randomize_layout;

 /*
@@ -1630,7 +1638,7 @@ extern struct security_hook_heads security_hook_heads;
 extern char *lsm_names;

 extern void security_add_hooks(struct security_hook_list *hooks, int count,
-				char *lsm);
+			       struct lsm_id *lsmid);

 #define LSM_FLAG_LEGACY_MAJOR	BIT(0)
 #define LSM_FLAG_EXCLUSIVE	BIT(1)
diff --git a/include/linux/security.h b/include/linux/security.h
index 71eac35bfa21..36a8c2d95542 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -39,6 +39,7 @@ struct kernel_siginfo;
 struct sembuf;
 struct kern_ipc_perm;
 struct audit_context;
+struct audit_rules;
 struct super_block;
 struct inode;
 struct dentry;
@@ -134,6 +135,65 @@ enum lockdown_reason {

 extern const char *const lockdown_reasons[LOCKDOWN_CONFIDENTIALITY_MAX+1];

+/*
+ * Data exported by the security modules
+ *
+ * Any LSM that provides secid or secctx based hooks must be included.
+ */
+#define LSMBLOB_ENTRIES ( \
+	(IS_ENABLED(CONFIG_SECURITY_SELINUX) ? 1 : 0) + \
+	(IS_ENABLED(CONFIG_SECURITY_SMACK) ? 1 : 0) + \
+	(IS_ENABLED(CONFIG_SECURITY_APPARMOR) ? 1 : 0) + \
+	(IS_ENABLED(CONFIG_BPF_LSM) ? 1 : 0))
+
+struct lsmblob {
+	u32     secid[LSMBLOB_ENTRIES];
+};
+
+#define LSMBLOB_INVALID		-1	/* Not a valid LSM slot number */
+#define LSMBLOB_NEEDED		-2	/* Slot requested on initialization */
+#define LSMBLOB_NOT_NEEDED	-3	/* Slot not requested */
+
+/**
+ * lsmblob_init - initialize an lsmblob structure
+ * @blob: Pointer to the data to initialize
+ * @secid: The initial secid value
+ *
+ * Set all secid for all modules to the specified value.
+ */
+static inline void lsmblob_init(struct lsmblob *blob, u32 secid)
+{
+	int i;
+
+	for (i = 0; i < LSMBLOB_ENTRIES; i++)
+		blob->secid[i] = secid;
+}
+
+/**
+ * lsmblob_is_set - report if there is an value in the lsmblob
+ * @blob: Pointer to the exported LSM data
+ *
+ * Returns true if there is a secid set, false otherwise
+ */
+static inline bool lsmblob_is_set(struct lsmblob *blob)
+{
+	struct lsmblob empty = {};
+
+	return !!memcmp(blob, &empty, sizeof(*blob));
+}
+
+/**
+ * lsmblob_equal - report if the two lsmblob's are equal
+ * @bloba: Pointer to one LSM data
+ * @blobb: Pointer to the other LSM data
+ *
+ * Returns true if all entries in the two are equal, false otherwise
+ */
+static inline bool lsmblob_equal(struct lsmblob *bloba, struct lsmblob *blobb)
+{
+	return !memcmp(bloba, blobb, sizeof(*bloba));
+}
+
 /* These functions are in security/commoncap.c */
 extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
 		       int cap, unsigned int opts);
@@ -1887,15 +1947,17 @@ static inline int security_key_getsecurity(struct key *key, char **_buffer)

 #ifdef CONFIG_AUDIT
 #ifdef CONFIG_SECURITY
-int security_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule);
+int security_audit_rule_init(u32 field, u32 op, char *rulestr,
+			     struct audit_rules *lsmrules);
 int security_audit_rule_known(struct audit_krule *krule);
-int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule);
-void security_audit_rule_free(void *lsmrule);
+int security_audit_rule_match(u32 secid, u32 field, u32 op,
+			      struct audit_rules *lsmrules);
+void security_audit_rule_free(struct audit_rules *lsmrules);

 #else

 static inline int security_audit_rule_init(u32 field, u32 op, char *rulestr,
-					   void **lsmrule)
+					   struct audit_rules *lsmrules)
 {
 	return 0;
 }
@@ -1906,12 +1968,12 @@ static inline int security_audit_rule_known(struct audit_krule *krule)
 }

 static inline int security_audit_rule_match(u32 secid, u32 field, u32 op,
-					    void *lsmrule)
+					    struct audit_rules *lsmrules)
 {
 	return 0;
 }

-static inline void security_audit_rule_free(void *lsmrule)
+static inline void security_audit_rule_free(struct audit_rules *lsmrules)
 { }

 #endif /* CONFIG_SECURITY */
diff --git a/kernel/auditfilter.c b/kernel/auditfilter.c
index d75acb014ccd..db427e136368 100644
--- a/kernel/auditfilter.c
+++ b/kernel/auditfilter.c
@@ -76,7 +76,7 @@ static void audit_free_lsm_field(struct audit_field *f)
 	case AUDIT_OBJ_LEV_LOW:
 	case AUDIT_OBJ_LEV_HIGH:
 		kfree(f->lsm_str);
-		security_audit_rule_free(f->lsm_rule);
+		security_audit_rule_free(&f->lsm_rules);
 	}
 }

@@ -527,9 +527,10 @@ static struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,
 				goto exit_free;
 			}
 			entry->rule.buflen += f_val;
+			f->lsm_isset = true;
 			f->lsm_str = str;
 			err = security_audit_rule_init(f->type, f->op, str,
-						       (void **)&f->lsm_rule);
+						       &f->lsm_rules);
 			/* Keep currently invalid fields around in case they
 			 * become valid after a policy reload. */
 			if (err == -EINVAL) {
@@ -782,7 +783,7 @@ static int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)
 	return 0;
 }

-/* Duplicate LSM field information.  The lsm_rule is opaque, so must be
+/* Duplicate LSM field information.  The lsm_rules is opaque, so must be
  * re-initialized. */
 static inline int audit_dupe_lsm_field(struct audit_field *df,
 					   struct audit_field *sf)
@@ -796,9 +797,9 @@ static inline int audit_dupe_lsm_field(struct audit_field *df,
 		return -ENOMEM;
 	df->lsm_str = lsm_str;

-	/* our own (refreshed) copy of lsm_rule */
+	/* our own (refreshed) copy of lsm_rules */
 	ret = security_audit_rule_init(df->type, df->op, df->lsm_str,
-				       (void **)&df->lsm_rule);
+				       &df->lsm_rules);
 	/* Keep currently invalid fields around in case they
 	 * become valid after a policy reload. */
 	if (ret == -EINVAL) {
@@ -850,7 +851,7 @@ struct audit_entry *audit_dupe_rule(struct audit_krule *old)
 	new->tree = old->tree;
 	memcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);

-	/* deep copy this information, updating the lsm_rule fields, because
+	/* deep copy this information, updating the lsm_rules fields, because
 	 * the originals will all be freed when the old rule is freed. */
 	for (i = 0; i < fcount; i++) {
 		switch (new->fields[i].type) {
@@ -1367,11 +1368,12 @@ int audit_filter(int msgtype, unsigned int listtype)
 			case AUDIT_SUBJ_TYPE:
 			case AUDIT_SUBJ_SEN:
 			case AUDIT_SUBJ_CLR:
-				if (f->lsm_rule) {
+				if (f->lsm_isset) {
 					security_task_getsecid_subj(current,
 								    &sid);
 					result = security_audit_rule_match(sid,
-						   f->type, f->op, f->lsm_rule);
+						   f->type, f->op,
+						   &f->lsm_rules);
 				}
 				break;
 			case AUDIT_EXE:
@@ -1398,7 +1400,7 @@ int audit_filter(int msgtype, unsigned int listtype)
 	return ret;
 }

-static int update_lsm_rule(struct audit_krule *r)
+static int update_lsm_rules(struct audit_krule *r)
 {
 	struct audit_entry *entry = container_of(r, struct audit_entry, rule);
 	struct audit_entry *nentry;
@@ -1430,7 +1432,7 @@ static int update_lsm_rule(struct audit_krule *r)
 	return err;
 }

-/* This function will re-initialize the lsm_rule field of all applicable rules.
+/* This function will re-initialize the lsm_rules field of all applicable rules.
  * It will traverse the filter lists serarching for rules that contain LSM
  * specific filter fields.  When such a rule is found, it is copied, the
  * LSM field is re-initialized, and the old rule is replaced with the
@@ -1445,7 +1447,7 @@ int audit_update_lsm_rules(void)

 	for (i = 0; i < AUDIT_NR_FILTERS; i++) {
 		list_for_each_entry_safe(r, n, &audit_rules_list[i], list) {
-			int res = update_lsm_rule(r);
+			int res = update_lsm_rules(r);
 			if (!err)
 				err = res;
 		}
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index b517947bfa48..1aa8ffdae0ad 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -664,14 +664,13 @@ static int audit_filter_rules(struct task_struct *tsk,
 			   match for now to avoid losing information that
 			   may be wanted.   An error message will also be
 			   logged upon error */
-			if (f->lsm_rule) {
+			if (f->lsm_isset) {
 				if (need_sid) {
 					security_task_getsecid_subj(tsk, &sid);
 					need_sid = 0;
 				}
 				result = security_audit_rule_match(sid, f->type,
-								   f->op,
-								   f->lsm_rule);
+							f->op, &f->lsm_rules);
 			}
 			break;
 		case AUDIT_OBJ_USER:
@@ -681,21 +680,19 @@ static int audit_filter_rules(struct task_struct *tsk,
 		case AUDIT_OBJ_LEV_HIGH:
 			/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR
 			   also applies here */
-			if (f->lsm_rule) {
+			if (f->lsm_isset) {
 				/* Find files that match */
 				if (name) {
 					result = security_audit_rule_match(
 								name->osid,
 								f->type,
 								f->op,
-								f->lsm_rule);
+								&f->lsm_rules);
 				} else if (ctx) {
 					list_for_each_entry(n, &ctx->names_list, list) {
 						if (security_audit_rule_match(
-								n->osid,
-								f->type,
-								f->op,
-								f->lsm_rule)) {
+							n->osid, f->type, f->op,
+							&f->lsm_rules)) {
 							++result;
 							break;
 						}
@@ -706,7 +703,7 @@ static int audit_filter_rules(struct task_struct *tsk,
 					break;
 				if (security_audit_rule_match(ctx->ipc.osid,
 							      f->type, f->op,
-							      f->lsm_rule))
+							      &f->lsm_rules))
 					++result;
 			}
 			break;
diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c
index 343631e20c2b..24241db8ec54 100644
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -1161,6 +1161,11 @@ struct lsm_blob_sizes apparmor_blob_sizes __lsm_ro_after_init = {
 	.lbs_sock = sizeof(struct aa_sk_ctx),
 };

+static struct lsm_id apparmor_lsmid __lsm_ro_after_init = {
+	.lsm  = "apparmor",
+	.slot = LSMBLOB_NEEDED
+};
+
 static struct security_hook_list apparmor_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),
 	LSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),
@@ -1846,7 +1851,7 @@ static int __init apparmor_init(void)
 		goto buffers_out;
 	}
 	security_add_hooks(apparmor_hooks, ARRAY_SIZE(apparmor_hooks),
-				"apparmor");
+				&apparmor_lsmid);

 	/* Report that AppArmor successfully initialized */
 	apparmor_initialized = 1;
diff --git a/security/bpf/hooks.c b/security/bpf/hooks.c
index e5971fa74fd7..7a58fe9ab8c4 100644
--- a/security/bpf/hooks.c
+++ b/security/bpf/hooks.c
@@ -15,9 +15,19 @@ static struct security_hook_list bpf_lsm_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(task_free, bpf_task_storage_free),
 };

+/*
+ * slot has to be LSMBLOB_NEEDED because some of the hooks
+ * supplied by this module require a slot.
+ */
+struct lsm_id bpf_lsmid __lsm_ro_after_init = {
+	.lsm = "bpf",
+	.slot = LSMBLOB_NEEDED
+};
+
 static int __init bpf_lsm_init(void)
 {
-	security_add_hooks(bpf_lsm_hooks, ARRAY_SIZE(bpf_lsm_hooks), "bpf");
+	security_add_hooks(bpf_lsm_hooks, ARRAY_SIZE(bpf_lsm_hooks),
+			   &bpf_lsmid);
 	pr_info("LSM support for eBPF active\n");
 	return 0;
 }
diff --git a/security/commoncap.c b/security/commoncap.c
index 3f810d37b71b..628685cf20e3 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -1443,6 +1443,11 @@ int cap_mmap_file(struct file *file, unsigned long reqprot,

 #ifdef CONFIG_SECURITY

+static struct lsm_id capability_lsmid __lsm_ro_after_init = {
+	.lsm  = "capability",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+
 static struct security_hook_list capability_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(capable, cap_capable),
 	LSM_HOOK_INIT(settime, cap_settime),
@@ -1467,7 +1472,7 @@ static struct security_hook_list capability_hooks[] __lsm_ro_after_init = {
 static int __init capability_init(void)
 {
 	security_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks),
-				"capability");
+			   &capability_lsmid);
 	return 0;
 }

diff --git a/security/landlock/cred.c b/security/landlock/cred.c
index 6725af24c684..56b121d65436 100644
--- a/security/landlock/cred.c
+++ b/security/landlock/cred.c
@@ -42,5 +42,5 @@ static struct security_hook_list landlock_hooks[] __lsm_ro_after_init = {
 __init void landlock_add_cred_hooks(void)
 {
 	security_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),
-			LANDLOCK_NAME);
+			&landlock_lsmid);
 }
diff --git a/security/landlock/fs.c b/security/landlock/fs.c
index 97b8e421f617..319e90e9290c 100644
--- a/security/landlock/fs.c
+++ b/security/landlock/fs.c
@@ -688,5 +688,5 @@ static struct security_hook_list landlock_hooks[] __lsm_ro_after_init = {
 __init void landlock_add_fs_hooks(void)
 {
 	security_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),
-			LANDLOCK_NAME);
+			&landlock_lsmid);
 }
diff --git a/security/landlock/ptrace.c b/security/landlock/ptrace.c
index f55b82446de2..54ccf55a077a 100644
--- a/security/landlock/ptrace.c
+++ b/security/landlock/ptrace.c
@@ -116,5 +116,5 @@ static struct security_hook_list landlock_hooks[] __lsm_ro_after_init = {
 __init void landlock_add_ptrace_hooks(void)
 {
 	security_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),
-			LANDLOCK_NAME);
+			&landlock_lsmid);
 }
diff --git a/security/landlock/setup.c b/security/landlock/setup.c
index f8e8e980454c..759e00b9436c 100644
--- a/security/landlock/setup.c
+++ b/security/landlock/setup.c
@@ -23,6 +23,11 @@ struct lsm_blob_sizes landlock_blob_sizes __lsm_ro_after_init = {
 	.lbs_superblock = sizeof(struct landlock_superblock_security),
 };

+struct lsm_id landlock_lsmid __lsm_ro_after_init = {
+	.lsm = LANDLOCK_NAME,
+	.slot = LSMBLOB_NOT_NEEDED,
+};
+
 static int __init landlock_init(void)
 {
 	landlock_add_cred_hooks();
diff --git a/security/landlock/setup.h b/security/landlock/setup.h
index 1daffab1ab4b..38bce5b172dc 100644
--- a/security/landlock/setup.h
+++ b/security/landlock/setup.h
@@ -14,5 +14,6 @@
 extern bool landlock_initialized;

 extern struct lsm_blob_sizes landlock_blob_sizes;
+extern struct lsm_id landlock_lsmid;

 #endif /* _SECURITY_LANDLOCK_SETUP_H */
diff --git a/security/loadpin/loadpin.c b/security/loadpin/loadpin.c
index b12f7d986b1e..b569f3bc170b 100644
--- a/security/loadpin/loadpin.c
+++ b/security/loadpin/loadpin.c
@@ -192,6 +192,11 @@ static int loadpin_load_data(enum kernel_load_data_id id, bool contents)
 	return loadpin_read_file(NULL, (enum kernel_read_file_id) id, contents);
 }

+static struct lsm_id loadpin_lsmid __lsm_ro_after_init = {
+	.lsm  = "loadpin",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+
 static struct security_hook_list loadpin_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(sb_free_security, loadpin_sb_free_security),
 	LSM_HOOK_INIT(kernel_read_file, loadpin_read_file),
@@ -239,7 +244,8 @@ static int __init loadpin_init(void)
 	pr_info("ready to pin (currently %senforcing)\n",
 		enforce ? "" : "not ");
 	parse_exclude();
-	security_add_hooks(loadpin_hooks, ARRAY_SIZE(loadpin_hooks), "loadpin");
+	security_add_hooks(loadpin_hooks, ARRAY_SIZE(loadpin_hooks),
+			   &loadpin_lsmid);
 	return 0;
 }

diff --git a/security/lockdown/lockdown.c b/security/lockdown/lockdown.c
index 87cbdc64d272..4e24ea3f7b7e 100644
--- a/security/lockdown/lockdown.c
+++ b/security/lockdown/lockdown.c
@@ -75,6 +75,11 @@ static struct security_hook_list lockdown_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(locked_down, lockdown_is_locked_down),
 };

+static struct lsm_id lockdown_lsmid __lsm_ro_after_init = {
+	.lsm = "lockdown",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+
 static int __init lockdown_lsm_init(void)
 {
 #if defined(CONFIG_LOCK_DOWN_KERNEL_FORCE_INTEGRITY)
@@ -83,7 +88,7 @@ static int __init lockdown_lsm_init(void)
 	lock_kernel_down("Kernel configuration", LOCKDOWN_CONFIDENTIALITY_MAX);
 #endif
 	security_add_hooks(lockdown_hooks, ARRAY_SIZE(lockdown_hooks),
-			   "lockdown");
+			   &lockdown_lsmid);
 	return 0;
 }

diff --git a/security/safesetid/lsm.c b/security/safesetid/lsm.c
index 963f4ad9cb66..0c368950dc14 100644
--- a/security/safesetid/lsm.c
+++ b/security/safesetid/lsm.c
@@ -241,6 +241,11 @@ static int safesetid_task_fix_setgid(struct cred *new,
 	return -EACCES;
 }

+static struct lsm_id safesetid_lsmid __lsm_ro_after_init = {
+	.lsm  = "safesetid",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+
 static struct security_hook_list safesetid_security_hooks[] = {
 	LSM_HOOK_INIT(task_fix_setuid, safesetid_task_fix_setuid),
 	LSM_HOOK_INIT(task_fix_setgid, safesetid_task_fix_setgid),
@@ -250,7 +255,8 @@ static struct security_hook_list safesetid_security_hooks[] = {
 static int __init safesetid_security_init(void)
 {
 	security_add_hooks(safesetid_security_hooks,
-			   ARRAY_SIZE(safesetid_security_hooks), "safesetid");
+			   ARRAY_SIZE(safesetid_security_hooks),
+			   &safesetid_lsmid);

 	/* Report that SafeSetID successfully initialized */
 	safesetid_initialized = 1;
diff --git a/security/security.c b/security/security.c
index 7f2bed1b2d6c..283671b6a5d7 100644
--- a/security/security.c
+++ b/security/security.c
@@ -345,6 +345,7 @@ static void __init ordered_lsm_init(void)
 	init_debug("sock blob size       = %d\n", blob_sizes.lbs_sock);
 	init_debug("superblock blob size = %d\n", blob_sizes.lbs_superblock);
 	init_debug("task blob size       = %d\n", blob_sizes.lbs_task);
+	init_debug("lsmblob size         = %zu\n", sizeof(struct lsmblob));

 	/*
 	 * Create any kmem_caches needed for blobs
@@ -472,21 +473,38 @@ static int lsm_append(const char *new, char **result)
 	return 0;
 }

+/*
+ * Current index to use while initializing the lsmblob secid list.
+ */
+static int lsm_slot __lsm_ro_after_init;
+
 /**
  * security_add_hooks - Add a modules hooks to the hook lists.
  * @hooks: the hooks to add
  * @count: the number of hooks to add
- * @lsm: the name of the security module
+ * @lsmid: the identification information for the security module
  *
  * Each LSM has to register its hooks with the infrastructure.
+ * If the LSM is using hooks that export secids allocate a slot
+ * for it in the lsmblob.
  */
 void __init security_add_hooks(struct security_hook_list *hooks, int count,
-				char *lsm)
+			       struct lsm_id *lsmid)
 {
 	int i;

+	WARN_ON(!lsmid->slot || !lsmid->lsm);
+
+	if (lsmid->slot == LSMBLOB_NEEDED) {
+		if (lsm_slot >= LSMBLOB_ENTRIES)
+			panic("%s Too many LSMs registered.\n", __func__);
+		lsmid->slot = lsm_slot++;
+		init_debug("%s assigned lsmblob slot %d\n", lsmid->lsm,
+			   lsmid->slot);
+	}
+
 	for (i = 0; i < count; i++) {
-		hooks[i].lsm = lsm;
+		hooks[i].lsmid = lsmid;
 		hlist_add_tail_rcu(&hooks[i].list, hooks[i].head);
 	}

@@ -495,7 +513,7 @@ void __init security_add_hooks(struct security_hook_list *hooks, int count,
 	 * and fix this up afterwards.
 	 */
 	if (slab_is_available()) {
-		if (lsm_append(lsm, &lsm_names) < 0)
+		if (lsm_append(lsmid->lsm, &lsm_names) < 0)
 			panic("%s - Cannot get early memory.\n", __func__);
 	}
 }
@@ -2072,7 +2090,7 @@ int security_getprocattr(struct task_struct *p, const char *lsm, char *name,
 	struct security_hook_list *hp;

 	hlist_for_each_entry(hp, &security_hook_heads.getprocattr, list) {
-		if (lsm != NULL && strcmp(lsm, hp->lsm))
+		if (lsm != NULL && strcmp(lsm, hp->lsmid->lsm))
 			continue;
 		return hp->hook.getprocattr(p, name, value);
 	}
@@ -2085,7 +2103,7 @@ int security_setprocattr(const char *lsm, const char *name, void *value,
 	struct security_hook_list *hp;

 	hlist_for_each_entry(hp, &security_hook_heads.setprocattr, list) {
-		if (lsm != NULL && strcmp(lsm, hp->lsm))
+		if (lsm != NULL && strcmp(lsm, hp->lsmid->lsm))
 			continue;
 		return hp->hook.setprocattr(name, value, size);
 	}
@@ -2576,9 +2594,27 @@ int security_key_getsecurity(struct key *key, char **_buffer)

 #ifdef CONFIG_AUDIT

-int security_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)
+int security_audit_rule_init(u32 field, u32 op, char *rulestr,
+			     struct audit_rules *lsmrules)
 {
-	return call_int_hook(audit_rule_init, 0, field, op, rulestr, lsmrule);
+	struct security_hook_list *hp;
+	bool one_is_good = false;
+	int rc = 0;
+	int trc;
+
+	hlist_for_each_entry(hp, &security_hook_heads.audit_rule_init, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		trc = hp->hook.audit_rule_init(field, op, rulestr,
+					&lsmrules->rule[hp->lsmid->slot]);
+		if (trc == 0)
+			one_is_good = true;
+		else
+			rc = trc;
+	}
+	if (one_is_good)
+		return 0;
+	return rc;
 }

 int security_audit_rule_known(struct audit_krule *krule)
@@ -2586,14 +2622,36 @@ int security_audit_rule_known(struct audit_krule *krule)
 	return call_int_hook(audit_rule_known, 0, krule);
 }

-void security_audit_rule_free(void *lsmrule)
+void security_audit_rule_free(struct audit_rules *lsmrules)
 {
-	call_void_hook(audit_rule_free, lsmrule);
+	struct security_hook_list *hp;
+
+	hlist_for_each_entry(hp, &security_hook_heads.audit_rule_free, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		if (lsmrules->rule[hp->lsmid->slot] == NULL)
+			continue;
+		hp->hook.audit_rule_free(lsmrules->rule[hp->lsmid->slot]);
+	}
 }

-int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule)
+int security_audit_rule_match(u32 secid, u32 field, u32 op,
+			      struct audit_rules *lsmrules)
 {
-	return call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule);
+	struct security_hook_list *hp;
+	int rc;
+
+	hlist_for_each_entry(hp, &security_hook_heads.audit_rule_match, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		if (lsmrules->rule[hp->lsmid->slot] == NULL)
+			continue;
+		rc = hp->hook.audit_rule_match(secid, field, op,
+					&lsmrules->rule[hp->lsmid->slot]);
+		if (rc)
+			return rc;
+	}
+	return 0;
 }
 #endif /* CONFIG_AUDIT */

diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 90a140ea439d..c295b1035bc6 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -7045,6 +7045,11 @@ static int selinux_uring_sqpoll(void)
 }
 #endif /* CONFIG_IO_URING */

+static struct lsm_id selinux_lsmid __lsm_ro_after_init = {
+	.lsm  = "selinux",
+	.slot = LSMBLOB_NEEDED
+};
+
 /*
  * IMPORTANT NOTE: When adding new hooks, please be careful to keep this order:
  * 1. any hooks that don't belong to (2.) or (3.) below,
@@ -7361,7 +7366,8 @@ static __init int selinux_init(void)

 	hashtab_cache_init();

-	security_add_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks), "selinux");
+	security_add_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks),
+			   &selinux_lsmid);

 	if (avc_add_callback(selinux_netcache_avc_callback, AVC_CALLBACK_RESET))
 		panic("SELinux: Unable to register AVC netcache callback\n");
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index db72debca070..9c44327d8ea7 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -4745,6 +4745,11 @@ struct lsm_blob_sizes smack_blob_sizes __lsm_ro_after_init = {
 	.lbs_superblock = sizeof(struct superblock_smack),
 };

+static struct lsm_id smack_lsmid __lsm_ro_after_init = {
+	.lsm  = "smack",
+	.slot = LSMBLOB_NEEDED
+};
+
 static struct security_hook_list smack_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(ptrace_access_check, smack_ptrace_access_check),
 	LSM_HOOK_INIT(ptrace_traceme, smack_ptrace_traceme),
@@ -4948,7 +4953,7 @@ static __init int smack_init(void)
 	/*
 	 * Register with LSM
 	 */
-	security_add_hooks(smack_hooks, ARRAY_SIZE(smack_hooks), "smack");
+	security_add_hooks(smack_hooks, ARRAY_SIZE(smack_hooks), &smack_lsmid);
 	smack_enabled = 1;

 	pr_info("Smack:  Initializing.\n");
diff --git a/security/tomoyo/tomoyo.c b/security/tomoyo/tomoyo.c
index b6a31901f289..e8f6bb9782c1 100644
--- a/security/tomoyo/tomoyo.c
+++ b/security/tomoyo/tomoyo.c
@@ -521,6 +521,11 @@ static void tomoyo_task_free(struct task_struct *task)
 	}
 }

+static struct lsm_id tomoyo_lsmid __lsm_ro_after_init = {
+	.lsm  = "tomoyo",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+
 /*
  * tomoyo_security_ops is a "struct security_operations" which is used for
  * registering TOMOYO.
@@ -573,7 +578,8 @@ static int __init tomoyo_init(void)
 	struct tomoyo_task *s = tomoyo_task(current);

 	/* register ourselves with the security framework */
-	security_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks), "tomoyo");
+	security_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks),
+			   &tomoyo_lsmid);
 	pr_info("TOMOYO Linux initialized\n");
 	s->domain_info = &tomoyo_kernel_domain;
 	atomic_inc(&tomoyo_kernel_domain.users);
diff --git a/security/yama/yama_lsm.c b/security/yama/yama_lsm.c
index 06e226166aab..a9639ea541f7 100644
--- a/security/yama/yama_lsm.c
+++ b/security/yama/yama_lsm.c
@@ -421,6 +421,11 @@ static int yama_ptrace_traceme(struct task_struct *parent)
 	return rc;
 }

+static struct lsm_id yama_lsmid __lsm_ro_after_init = {
+	.lsm  = "yama",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+
 static struct security_hook_list yama_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(ptrace_access_check, yama_ptrace_access_check),
 	LSM_HOOK_INIT(ptrace_traceme, yama_ptrace_traceme),
@@ -477,7 +482,7 @@ static inline void yama_init_sysctl(void) { }
 static int __init yama_init(void)
 {
 	pr_info("Yama: becoming mindful.\n");
-	security_add_hooks(yama_hooks, ARRAY_SIZE(yama_hooks), "yama");
+	security_add_hooks(yama_hooks, ARRAY_SIZE(yama_hooks), &yama_lsmid);
 	yama_init_sysctl();
 	return 0;
 }
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id ADC0CC433EF
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:48:09 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234105AbhKXBvR (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:51:17 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:42410
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S231310AbhKXBvQ (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:51:16 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718487; bh=Q3oYFxmyePXUZvb52LUnr5+7j9BYUgqBMyeLytsPrdM=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=F4NAoxc88B11wa4uMaQyluzO/7S5f346tFZB+zthUcgfbS3WI76G5uDAOYnD5m6d1zpU800bSKPWgNk6FW6+6ZkAqxT4XU/JXnnh2Wg/fF9AkVSO2WGI/6nP68wZgTpSzeF6uk8KeC0PGE+rs4ar17pwI9toQzONJwavhlQ6MBR0R4kq0fcGK2ohBayPA+DIjZfPv9N+rqYhfMtoiZt8fhRgeTQC2JpWzr/y6rlHHQ/OmCFMLrXcdjqDcnVj2eLUgb17/sjtXB6+4UpCAnk4W7p5zOirXN3rgc7giQ19PrM3knhclawhDH1iLfzWTP71+MVOo4WQ4yV1F7V0qSOuow==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718487; bh=3dH3FHQ1luPwj2Ok6BQ+Kx2XrL9SgD+Cr1EjxsCKGLW=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=Fup8DgpU9IkjVJ/xSAZbRpIKBUlV4pNsqj2wXj3UfO4mJyGmTm4DLc7eceTtpC+4yRGmWMQUJZ7zkhR2q8pP/NvYOlt34SpM0okv9TXUnRo3rI/zM8ZlvzAHs+3hi8O/TKWrI3wTMeLAJ8JbeOD7pgyNr//dh5eRy+CbzuPXRd5e+tWmtCQekzVgTgIGMSHqmn+P+1i2gVLIz//COB2Bn/NLKEiZwMychtENUORnnvBY/3Vl/rEMYV7dcyoKXEtH4I0FfJwEFYIrnMeeqzMhzZOt65NCBJ9NkPoOjVfgV//HOYeEGGtiU6j78MumPQ1fVUuwfxv9Q2G/SoXTjSbftg==
X-YMail-OSG: OY3jJx0VM1nybd4zNj0rZv_V722_ckQuZruKfZG_F9LJuiBkdt13vNCvkOaRUZE
 bd4PELqSISEY2CJL59LAvA3YWZbMPHvnjpJGr4WV2E1LtDyfMfqb8ukq8ybSXOL0s1gWyeO4fA1S
 SFRnOYszsnhiSRQhA926KHKz7rDoLPTfTh5uwe5L.a09.bux8HAjNi.DE1sUTlpoUBDtRhH56oNv
 9YVfRcVflPSua5cbxT5pFAi0jPgHIsVSXEaZQVwaVi3nx0rMf6aEYQXFRYSNEEOtiRdjY3opryty
 d5Y7vaIDuBJEav4zyD1vixVACnUuMKhIiw7qLIiHPu3ZRuC8tkh_7AgH9E1xkbNkIIXXlW_fQ9Jk
 o8HpIichPTsPfpWNJzVIPwDjNIAqdpam9M910OzUt_zqPlDCkEvz_dEGn09fOv6fwiCrIahNPXPi
 k2l2vxNMnLhInpQs7SCHiu3WPPFyuvU6712xhBvonkdGWW2WOJppSi_mAwBkAjLLLrorYrMO1mF6
 yN15MIe1Hgy8l3OrsuNPAMroFWNcFeQpQPlaqKDc8jSOJ4tO1PlnEIhFN701dbsTeNxbURX4XPa5
 8qUTBXfS4gCGPxSkF5O.XbYMsm5NEm8YTnuEC5CTK.Stuy3B_V74h.Kn3xC976hLHHJiV8Ccl0vl
 3x9bgIr1kitKIMANTdj3fFIa2tPU8DWwYaCzHsDix6mnCxpMQhHqHAYHXd_5XDl8_jomm_i7JXyE
 6PggWJ08kSRPWgSxr4lpIktF0GZIEPAWwcdT_DahtO_m8ggE1Y1mPGYutVtm4d_sUTkEE606dinR
 7XZvbYzJvZe3Sx3S1qK6e8fmjXlNND_XCRV2SbU6.Z7a2LJSV3wY7EWRffJ35po4qwrZdEUWe.Tz
 cl6g.R_XEYjodc4XoCxzrUhJnd00yO7x8K.ocUj4l0oVXU2lCzCUlVeerRCfEaVgKN96uQqhaLsl
 tVyccA2xhfesJ6p.pT2HWgX0HUoCZcmvQQk8zW2UAXqcB5iNgdwH5qDHGv2UVdWAPHJxUpe_unOf
 YCvUKCxf.bigL.AFZLriZrGQD6nst424Mxd6s7yy2chPIPHw00hWmYG9.2K0qeFjJ2agNkNVzq39
 tava71YU2ZHvdB8rrFn0hGYMOlZQmVXMYvhei8etbo96KuPO4Upoi3YmTLVQWWD.mw675hrlm0cN
 SYjW1vUlUiUXBtJH6a3zpZFkDFfjlScpjHLZ0FPg3tEttmtKo0pcnxTupICh55AvxCqT.VwuPvYV
 jNpt1ut3Nm9azrsTC8vCOPJACy3acLdKdjDjG8L9NNC8xT4HgxYBDiQxDgYAOHnmSH1QywoCi0J1
 RundcNtjZcCdWxHRKMj0Jr_ItX7WtgXG1wjhVfbotwpPaRXweteF0R.ki2aRMhsT.UCTSKYWWpyD
 tfDQyN3SdWAyJYb.oMgIIQqqt1zC_ha5rVYIpfth1A3j3ycdMCHeOCKuns.qXCU2oUdDcPFpI4eF
 giAnHJzalHeksfU3VBVND6wq2cgcwqr6WV9Ibi6YcWRZFcUgsjoIFyUDGx2i8rYtGnKTdx7F1hxt
 ZLubG4QI87itil6M7B_mzcCwf2BCObfkAnsN5_rgge3TizwdXiGiZN1fTcTUuLuokgDOlyXhn3yO
 V3l8kWCh1rMBFX8iJIRcXnWuJ19CqLhXO_T8fBJNgNv5Ao4HhDGvLpyepQwMz3QWZSG8aFQLX0Mm
 qTEd29JEIpU5xhC6IqTTEcqUTzUUKWJD.bA.Cet9Ryk2xS.wMnuwrbSc2.3Mqo_RXwnax0uXRS4b
 sKvwvNYEx.urtJTzriEwm2n.K5_5Y7b_fI9VhfdIVKwsQpd2llVj2eQisQqEVdAKYJcFc9eNE5EL
 XJ66I4pxdC3AN9D5lKeTU.uysiKBHie6bdUlARFD97PC8ps0Vhdp8SW1.JvzMy8tC_VGCLrahD9I
 gwdfPWjDvvlv7b7GQoHIvnYpd5AXk3IK7ym6BKoN_bvYhrN8ya3qHDxCL7jlFdpNUgnGEirY25gM
 oYFAvqYkQ8Wh1ZJInbE9rrqpCt_d16AdAHiuTCT_SCUFKqa7N0BS3CLbWQBIlch.uCajuIpM03Cl
 66vVjTA4kuH6KcJDd.67LSlt7eqYG92lJsl9ct24Vgfj2I2pm5QesYR4amz32t87zANnIjdpNmTY
 dRTnnKyB19aJVKEJ4EjMA6H_ylHHIWfBlzW9Bl402cnSSKwZ3beKtuMLk.J5K6oTkMhpr4ctLvtZ
 gKAwx3d1Q2JHnuot3nTkxEW18Pav7
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:48:07 +0000
Received: by kubenode536.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 0bdf7b7fb47115a0eb0172a796184117;
          Wed, 24 Nov 2021 01:48:03 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 04/28] LSM: provide lsm name and id slot mappings
Date:   Tue, 23 Nov 2021 17:43:08 -0800
Message-Id: <20211124014332.36128-5-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Provide interfaces to map LSM slot numbers and LSM names.
Update the LSM registration code to save this information.

Acked-by: Paul Moore <paul@paul-moore.com>
Reviewed-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 include/linux/security.h |  4 ++++
 security/security.c      | 45 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 49 insertions(+)

diff --git a/include/linux/security.h b/include/linux/security.h
index 36a8c2d95542..cd68b4199877 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -194,6 +194,10 @@ static inline bool lsmblob_equal(struct lsmblob *bloba, struct lsmblob *blobb)
 	return !memcmp(bloba, blobb, sizeof(*bloba));
 }

+/* Map lsm names to blob slot numbers */
+extern int lsm_name_to_slot(char *name);
+extern const char *lsm_slot_to_name(int slot);
+
 /* These functions are in security/commoncap.c */
 extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
 		       int cap, unsigned int opts);
diff --git a/security/security.c b/security/security.c
index 283671b6a5d7..bc169b9a6d77 100644
--- a/security/security.c
+++ b/security/security.c
@@ -477,6 +477,50 @@ static int lsm_append(const char *new, char **result)
  * Current index to use while initializing the lsmblob secid list.
  */
 static int lsm_slot __lsm_ro_after_init;
+static struct lsm_id *lsm_slotlist[LSMBLOB_ENTRIES] __lsm_ro_after_init;
+
+/**
+ * lsm_name_to_slot - Report the slot number for a security module
+ * @name: name of the security module
+ *
+ * Look up the slot number for the named security module.
+ * Returns the slot number or LSMBLOB_INVALID if @name is not
+ * a registered security module name.
+ */
+int lsm_name_to_slot(char *name)
+{
+	int i;
+
+	for (i = 0; i < lsm_slot; i++)
+		if (strcmp(lsm_slotlist[i]->lsm, name) == 0)
+			return i;
+
+	return LSMBLOB_INVALID;
+}
+
+/**
+ * lsm_slot_to_name - Get the name of the security module in a slot
+ * @slot: index into the interface LSM slot list.
+ *
+ * Provide the name of the security module associated with
+ * a interface LSM slot.
+ *
+ * If @slot is LSMBLOB_INVALID return the value
+ * for slot 0 if it has been set, otherwise NULL.
+ *
+ * Returns a pointer to the name string or NULL.
+ */
+const char *lsm_slot_to_name(int slot)
+{
+	if (slot == LSMBLOB_INVALID)
+		slot = 0;
+	else if (slot >= LSMBLOB_ENTRIES || slot < 0)
+		return NULL;
+
+	if (lsm_slotlist[slot] == NULL)
+		return NULL;
+	return lsm_slotlist[slot]->lsm;
+}

 /**
  * security_add_hooks - Add a modules hooks to the hook lists.
@@ -498,6 +542,7 @@ void __init security_add_hooks(struct security_hook_list *hooks, int count,
 	if (lsmid->slot == LSMBLOB_NEEDED) {
 		if (lsm_slot >= LSMBLOB_ENTRIES)
 			panic("%s Too many LSMs registered.\n", __func__);
+		lsm_slotlist[lsm_slot] = lsmid;
 		lsmid->slot = lsm_slot++;
 		init_debug("%s assigned lsmblob slot %d\n", lsmid->lsm,
 			   lsmid->slot);
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 84ECEC433F5
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:49:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237394AbhKXBwu (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:52:50 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:36739
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S233344AbhKXBwr (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:52:47 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718579; bh=3/8RBVV2g7vxTlJLIdexlqAMFUzEx32GgRcCLieYGPY=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=r77cuPhHT3cZxYYUSV40ozy7+5E59LhvdWV2CdLqUunizchn0IFusRVs9M8yT3kPBOK9KHyUbC+s3dleXvzVRI3U2Lg+U/wsWVSp8JGLgMtHe/hbbRdEwbSGEhI8BSLqbM+kWvEYT4DRuEtxAEcC5+STQQtyykqMCKqTfCx9ZN3+baMFCBwYyLVG/3zc4ciHqFqMXGQF4R0DF4b27NGTpSXYhHXMNzEAK4npuICKf/A+TIiw5pSEfqxC1XAxKMWpLMP8TvepWcEoAY61J3v201PwyjbRzWzB7mCPfNkgQPrqWW/Sqp5oD1DpHFv4rf5nh/EDI7PL2dtTbitXpao9rA==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718579; bh=YbRQ8FfvFz9LnGU1NLSH2w/l/hV0y/FI+dRhWPh/4fY=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=FYPP7o/Bmlk0UK2cXdshC0sxhrWZlHVDoJ+DRw22i+4g6o8uoBIYFrD8gGjlFuAy6W9KP8euMEpBCrd+jYiwx7iKUCR6uN0Nxsvd2WJi1XI5tT+3XKMJD6wg7Jo95OT8gz1ovZfhYsCMhOgIzmG7kGkALtoIjUq4XxJUipW/6Fwt4G3YLYxtr6C9OdrNId29ONdu55ovYo0PTyf4BKlS3MOt2pChafhoYqjzpsAJx6EL6JU7klXnN9g9f0H05fIOdghT8BvlDYFMCnVWGfK0p26huOlKqV/WZMFovqeQjJ8GuMYrl86y6mGkT1tKUoqXNsTYUzW9w1bazZFQd5m2gA==
X-YMail-OSG: qBYoQpYVM1kbr_BL8PVm7ENQDjuh4hcZCFIaRHKToC5_aye8dphqYkzs_AhzYTs
 WSOSuXkQGelqUjcBujFBQLjduyRET5nFH3BgH2naMggGxWE_TC9tlmSmwYWLIscUPkBZKoIQbfUE
 jNLH802IHjGQQ0wvHyU1FoJRsOw8WbzwAXXoqOYarxUSdWqEM_EjVbOmbrQRiQf370.9Gg74L9gL
 Wuv8Jrv0P2w6XR9gjfdbtbeTkzSeOMN3mLnk3ZsIcggfKdfiNCIIe7oVKdCgB3hgxcci3S1bAadn
 mO416sdlYMpH4GGG8TEcb.DqBjWK2_hSRolCjsvC921TgtY96VBx6Q5dWtaJFZV4pC62XJKFEqrf
 nvbirT_jwmnrSFOLqr0FbcJLqzbrItyo9ILysY_QMWkZ4LGHR8EQZQ0EsS731nzOeKz._qwc08G0
 XVJFdFKa3v8xj__fhkpGc4sx8SBgjN5zdmQULFXiC7zpXJIiOGDaga0oYOf6ftopIFbLtCVc6eGW
 b4IwbW1CkbKktqM0HR_gYINY3CFE2mozrYJFo4bKclMTr74n12n5X0nF1xM3pcEYBbBomPYp.MLy
 .chpgSACzObGPfTyHNuWOvh5EMTY7vuTmhZMyb_C4cEprTvqVl4W9M3le3SGqYcnRC6kTm_F_CsV
 F.cvF1adu_cgXgvwC7PQjZlsO5o.ioXLYx2dyUVXhUoQmoY5VgZzwNXWwRfZRWieWx1DyEmZZo69
 TEgPP8vqX3HqdvUbtpMXeV47x9qRpBAuZmGinDtdSn81lzBV6sbDWvIb6OgxTas3Cwr3ynx.PKKa
 RTVGFKCDG6VfJWvhiQBPnhHYjbl7K6D6l6fMdAgdYMP0VR2fIpxg33I.11be9jMWdYfAktL51nxW
 SIpwwcWHCwxnCQ9JMH4VjAt2TCSHE2BVXX.sRWb1WN5i_P6ZB51xR7t2gu3y4Dvl5cLGmIYA7lUQ
 oywPXZ9uI7vX81SEFaJZxDYd.sIR0r3AxWxcr91OVSq_GXU.9czXVUGACAON3RJ4XY0zva43dM4n
 NN4Z7lxxJBdk0Uw.jovcP2d7Bz8ZnP27xwfiNVbMp5QwZE1_IZoFoP4E5D3z6LWefBzOlVkL6.ya
 RkLbLtRZ8xcPjaPlMKPxkrsyMgCf1AK4V2uZ0AyESGQZCV0onDvWEYN8x.600_insl01fzww_uEL
 vDe7yLFGWj6gQ5xstkAMl2qQ894JqKvx14It4gFnC6raCvCU58T40pD5bliJry4l4sO1u5T8TK3W
 RjJvnZ2ETA8tYdb3UuL1gGc79DpDVCdc3gRLeG_bcHfTjUSzp1aObTEGDRvJ7aN4VjZ4AKz_0RCh
 lWk6Qt7kDxlbq7UhzsjThzvECc0m0IBWbtJ16e2BeluYZqaG2OEqUg5cpSfMOAtZTOmRtXpwiEGx
 bMexxVuLgQar9VvUOw.RIRFJD4gNz7bsNQWI5VaVTzRJ5_oMrG4IoX5w9i1knJi_01x3m302nGy6
 fBRO4ZuGvHKbz_RSgJIpoX57Yzc4rFucVFc_jxj.FuR3eMUrcJdME22qGzY09sIvOr5OWJPhGT.5
 WEKvIkYY7bqO500MTNG5bXigMttlIPecLcOPO1sDtiOO5P7pNgx0EqucOzdEEnQ4FdJBXtVBKStU
 8ezBQbzA0TIdl.UDvKzJFSP4k5T1pYoHTOVdUhK5CW.bMkfKr5uCNBEDjcphuW_FF1hVm0cydfKU
 ZfJ3If_46Et7IE4.027NWSwyuzY7X_fyMPGpBoDFnuooX.VV5RQUnaE5DAmzbyABQ8.wo5w91KgK
 .Nqf7tIC4X0r2mFHVIojJxgRlG1qRemOC6BDaUvjBrfVL3zQzXZH.NpORNJX6PmCoJVDH4KnXqNA
 OyBBNAcW9AOwa9AczsrVhCXt75.En1VVlwaOvd63sSvbJLlQUzRathmeRgh85zPavPV89sUn6MS2
 kXK_G2NoCHP_p60KvVtNcGi_3MRxlJxxedywpbXVsd.W3eHVCCBLSee20J2XloBOQuYeKnYXHa0C
 9DHsFV1Zbs9t7jkKWl5f4_9Wun7U43qluJW3bvcgEf6RYTdqPn5VgBh0fnS0MGQa0rICTelCAvHx
 jUPKsSIRju5XCXMSlw0z2zVCAnpNr8ccNqVAEqiLXfsZ5M0.4.gzlvLWf2ogWCy085ZshYfrTCKK
 yY4YV2PHS3ZfuXtPFS.dCOSRyPMOB_HkLHk.KRNXZIswVtb9KA1GfUlPOk9S4s7FGSwvJH2mc_F7
 .HF1.wVPfayN35PfXWAdXuKwUFT_lVphF1otFqxspxR.mLrRb_iwKxqo-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:49:39 +0000
Received: by kubenode503.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID d601fc60808c5fb6510d4038ab063ddb;
          Wed, 24 Nov 2021 01:49:10 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 05/28] IMA: avoid label collisions with stacked LSMs
Date:   Tue, 23 Nov 2021 17:43:09 -0800
Message-Id: <20211124014332.36128-6-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Integrity measurement may filter on security module information
and needs to be clear in the case of multiple active security
modules which applies. Provide a boot option ima_rules_lsm= to
allow the user to specify an active security module to apply
filters to. If not specified, use the first registered module
that supports the audit_rule_match() LSM hook. Allow the user
to specify in the IMA policy an lsm= option to specify the
security module to use for a particular rule.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
To: Mimi Zohar <zohar@linux.ibm.com>
To: linux-integrity@vger.kernel.org
---
 Documentation/ABI/testing/ima_policy |  8 ++++-
 include/linux/security.h             | 14 ++++----
 security/integrity/ima/ima_policy.c  | 51 ++++++++++++++++++++++++----
 security/security.c                  | 35 +++++++++++++++----
 4 files changed, 89 insertions(+), 19 deletions(-)

diff --git a/Documentation/ABI/testing/ima_policy b/Documentation/ABI/testing/ima_policy
index 839fab811b18..64863e9d87ea 100644
--- a/Documentation/ABI/testing/ima_policy
+++ b/Documentation/ABI/testing/ima_policy
@@ -26,7 +26,7 @@ Description:
 				[uid=] [euid=] [gid=] [egid=]
 				[fowner=] [fgroup=]]
 			lsm:	[[subj_user=] [subj_role=] [subj_type=]
-				 [obj_user=] [obj_role=] [obj_type=]]
+				 [obj_user=] [obj_role=] [obj_type=]] [lsm=]
 			option:	[[appraise_type=]] [template=] [permit_directio]
 				[appraise_flag=] [appraise_algos=] [keyrings=]
 		  base:
@@ -126,6 +126,12 @@ Description:

 			measure subj_user=_ func=FILE_CHECK mask=MAY_READ

+		It is possible to explicitly specify which security
+		module a rule applies to using lsm=.  If the security
+		module specified is not active on the system the rule
+		will be rejected.  If lsm= is not specified the first
+		security module registered on the system will be assumed.
+
 		Example of measure rules using alternate PCRs::

 			measure func=KEXEC_KERNEL_CHECK pcr=4
diff --git a/include/linux/security.h b/include/linux/security.h
index cd68b4199877..ddd4cf48413c 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1985,25 +1985,27 @@ static inline void security_audit_rule_free(struct audit_rules *lsmrules)

 #ifdef CONFIG_IMA_LSM_RULES
 #ifdef CONFIG_SECURITY
-int ima_filter_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule);
-int ima_filter_rule_match(u32 secid, u32 field, u32 op, void *lsmrule);
-void ima_filter_rule_free(void *lsmrule);
+int ima_filter_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule,
+			 int lsmslot);
+int ima_filter_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
+			  int lsmslot);
+void ima_filter_rule_free(void *lsmrule, int lsmslot);

 #else

 static inline int ima_filter_rule_init(u32 field, u32 op, char *rulestr,
-					   void **lsmrule)
+					   void **lsmrule, int lsmslot)
 {
 	return 0;
 }

 static inline int ima_filter_rule_match(u32 secid, u32 field, u32 op,
-					    void *lsmrule)
+					    void *lsmrule, int lsmslot)
 {
 	return 0;
 }

-static inline void ima_filter_rule_free(void *lsmrule)
+static inline void ima_filter_rule_free(void *lsmrule, int lsmslot)
 { }

 #endif /* CONFIG_SECURITY */
diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index 320ca80aacab..22952efcc0b0 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -90,6 +90,7 @@ struct ima_rule_entry {
 	bool (*fgroup_op)(kgid_t cred_gid, kgid_t rule_gid); /* gid_eq(), gid_gt(), gid_lt() */
 	int pcr;
 	unsigned int allowed_algos; /* bitfield of allowed hash algorithms */
+	int which;		/* which LSM rule applies to */
 	struct {
 		void *rule;	/* LSM file metadata specific */
 		char *args_p;	/* audit value */
@@ -286,6 +287,20 @@ static int __init default_appraise_policy_setup(char *str)
 }
 __setup("ima_appraise_tcb", default_appraise_policy_setup);

+static int ima_rules_lsm __ro_after_init;
+
+static int __init ima_rules_lsm_init(char *str)
+{
+	ima_rules_lsm = lsm_name_to_slot(str);
+	if (ima_rules_lsm < 0) {
+		ima_rules_lsm = 0;
+		pr_err("rule lsm \"%s\" not registered", str);
+	}
+
+	return 1;
+}
+__setup("ima_rules_lsm=", ima_rules_lsm_init);
+
 static struct ima_rule_opt_list *ima_alloc_rule_opt_list(const substring_t *src)
 {
 	struct ima_rule_opt_list *opt_list;
@@ -357,7 +372,7 @@ static void ima_lsm_free_rule(struct ima_rule_entry *entry)
 	int i;

 	for (i = 0; i < MAX_LSM_RULES; i++) {
-		ima_filter_rule_free(entry->lsm[i].rule);
+		ima_filter_rule_free(entry->lsm[i].rule, entry->which);
 		kfree(entry->lsm[i].args_p);
 	}
 }
@@ -408,7 +423,8 @@ static struct ima_rule_entry *ima_lsm_copy_rule(struct ima_rule_entry *entry)

 		ima_filter_rule_init(nentry->lsm[i].type, Audit_equal,
 				     nentry->lsm[i].args_p,
-				     &nentry->lsm[i].rule);
+				     &nentry->lsm[i].rule,
+				     entry->which);
 		if (!nentry->lsm[i].rule)
 			pr_warn("rule for LSM \'%s\' is undefined\n",
 				nentry->lsm[i].args_p);
@@ -624,14 +640,16 @@ static bool ima_match_rules(struct ima_rule_entry *rule,
 			security_inode_getsecid(inode, &osid);
 			rc = ima_filter_rule_match(osid, rule->lsm[i].type,
 						   Audit_equal,
-						   rule->lsm[i].rule);
+						   rule->lsm[i].rule,
+						   rule->which);
 			break;
 		case LSM_SUBJ_USER:
 		case LSM_SUBJ_ROLE:
 		case LSM_SUBJ_TYPE:
 			rc = ima_filter_rule_match(secid, rule->lsm[i].type,
 						   Audit_equal,
-						   rule->lsm[i].rule);
+						   rule->lsm[i].rule,
+						   rule->which);
 			break;
 		default:
 			break;
@@ -1026,7 +1044,7 @@ enum policy_opt {
 	Opt_fowner_lt, Opt_fgroup_lt,
 	Opt_appraise_type, Opt_appraise_flag, Opt_appraise_algos,
 	Opt_permit_directio, Opt_pcr, Opt_template, Opt_keyrings,
-	Opt_label, Opt_err
+	Opt_lsm, Opt_label, Opt_err
 };

 static const match_table_t policy_tokens = {
@@ -1074,6 +1092,7 @@ static const match_table_t policy_tokens = {
 	{Opt_template, "template=%s"},
 	{Opt_keyrings, "keyrings=%s"},
 	{Opt_label, "label=%s"},
+	{Opt_lsm, "lsm=%s"},
 	{Opt_err, NULL}
 };

@@ -1092,7 +1111,8 @@ static int ima_lsm_rule_init(struct ima_rule_entry *entry,
 	entry->lsm[lsm_rule].type = audit_type;
 	result = ima_filter_rule_init(entry->lsm[lsm_rule].type, Audit_equal,
 				      entry->lsm[lsm_rule].args_p,
-				      &entry->lsm[lsm_rule].rule);
+				      &entry->lsm[lsm_rule].rule,
+				      entry->which);
 	if (!entry->lsm[lsm_rule].rule) {
 		pr_warn("rule for LSM \'%s\' is undefined\n",
 			entry->lsm[lsm_rule].args_p);
@@ -1781,6 +1801,19 @@ static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 						 &(template_desc->num_fields));
 			entry->template = template_desc;
 			break;
+		case Opt_lsm:
+			result = lsm_name_to_slot(args[0].from);
+			if (result == LSMBLOB_INVALID) {
+				int i;
+
+				for (i = 0; i < MAX_LSM_RULES; i++)
+					entry->lsm[i].args_p = NULL;
+				result = -EINVAL;
+				break;
+			}
+			entry->which = result;
+			result = 0;
+			break;
 		case Opt_err:
 			ima_log_string(ab, "UNKNOWN", p);
 			result = -EINVAL;
@@ -1817,6 +1850,7 @@ ssize_t ima_parse_add_rule(char *rule)
 	struct ima_rule_entry *entry;
 	ssize_t result, len;
 	int audit_info = 0;
+	int i;

 	p = strsep(&rule, "\n");
 	len = strlen(p) + 1;
@@ -1834,6 +1868,9 @@ ssize_t ima_parse_add_rule(char *rule)

 	INIT_LIST_HEAD(&entry->list);

+	for (i = 0; i < MAX_LSM_RULES; i++)
+		entry->which = ima_rules_lsm;
+
 	result = ima_parse_rule(p, entry);
 	if (result) {
 		ima_free_rule(entry);
@@ -2151,6 +2188,8 @@ int ima_policy_show(struct seq_file *m, void *v)
 		seq_puts(m, "appraise_flag=check_blacklist ");
 	if (entry->flags & IMA_PERMIT_DIRECTIO)
 		seq_puts(m, "permit_directio ");
+	if (entry->which >= 0)
+		seq_printf(m, pt(Opt_lsm), lsm_slot_to_name(entry->which));
 	rcu_read_unlock();
 	seq_puts(m, "\n");
 	return 0;
diff --git a/security/security.c b/security/security.c
index bc169b9a6d77..c472cac72641 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2705,19 +2705,42 @@ int security_audit_rule_match(u32 secid, u32 field, u32 op,
  * The integrity subsystem uses the same hooks as
  * the audit subsystem.
  */
-int ima_filter_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)
+int ima_filter_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule,
+			 int lsmslot)
 {
-	return call_int_hook(audit_rule_init, 0, field, op, rulestr, lsmrule);
+	struct security_hook_list *hp;
+
+	hlist_for_each_entry(hp, &security_hook_heads.audit_rule_init, list)
+		if (hp->lsmid->slot == lsmslot)
+			return hp->hook.audit_rule_init(field, op, rulestr,
+							lsmrule);
+
+	return 0;
 }

-void ima_filter_rule_free(void *lsmrule)
+void ima_filter_rule_free(void *lsmrule, int lsmslot)
 {
-	call_void_hook(audit_rule_free, lsmrule);
+	struct security_hook_list *hp;
+
+	hlist_for_each_entry(hp, &security_hook_heads.audit_rule_free, list) {
+		if (hp->lsmid->slot == lsmslot) {
+			hp->hook.audit_rule_free(lsmrule);
+			return;
+		}
+	}
 }

-int ima_filter_rule_match(u32 secid, u32 field, u32 op, void *lsmrule)
+int ima_filter_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
+			  int lsmslot)
 {
-	return call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule);
+	struct security_hook_list *hp;
+
+	hlist_for_each_entry(hp, &security_hook_heads.audit_rule_match, list)
+		if (hp->lsmid->slot == lsmslot)
+			return hp->hook.audit_rule_match(secid, field, op,
+							 lsmrule);
+
+	return 0;
 }
 #endif /* CONFIG_IMA_LSM_RULES */

--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 9DFC4C433FE
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:50:23 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237739AbhKXBxb (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:53:31 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:37574
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S231769AbhKXBx2 (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:53:28 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718619; bh=0F/wOjoDngNIlqzzF/QVmzrHGqxDKlEpuz6LMG+ygug=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=gXv9vuXnQZUm5j2g/mX4utCFsc9VuF5nwz10RL8OHqHIa0gpdYKIvOsmuw58cxhZjq/CX2KSMJyxGoXso0zY5++K8YIRTAbyn8j6ns7pyuyrj9K5V/yQsmmUqMlKahURQKNp0Z3kmsQp+BD8a3+Qu1/fBgliJS0g2EflMlvfEznMX0KEocedDYAimPXfCPRMDrcJkE7l2VaKbmFw/bn11dICljbmLEHzdy64w2Sl+7CHJDplFnK3h512S+C/drpCxkZjCbGXcd/axvd+PcoMRfkoqHxPhe3gdBqnd8VGaPVOXN8L1TbkjlaEoz9MO3NVYPfX3+R2zgWV2PnB1WkGAg==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718619; bh=KUbbNPmiKjUF8cKthrd7LCNEMGftPuH4Ntav/ueeYZD=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=YzsDFXfd+9cgfokOO/YExdRaPz34fI4j9Hp6sFFO5IPZFVkwFLcPPdm3hYnD6utA+bhAhGVvH/gkvEiGZUICYiJn6E8/bHYYgsni2APHewWzEBQqaUlbwiBauvV4cNkOXLS5tkPCcPMZEKNHL5IDxaOwo9DQV+bQQihW/SD1rHvBYE6l4rc7SWu2jGxteMaC12dsQR7kivDhXauruEtyk93h/ti09O502bv77N/qw30DhObQVupvZsxmOS/eL6WSsp9RiNL+2J7l+KKcucZ995C3IYYltomSCGlwP2zpnl9a0jDtVdGkAKWXvYIph74WSrQGmgATPnQKJCi5xHNNhg==
X-YMail-OSG: SYFFz84VM1mTwyOrRVqeTz5YWrlEf5zc7PfbWTeZr3nX3P5UHt_zHAP9vfeRqnV
 1mS3VvUKUJ1i0WCiM0vuPxNVi3SJOfse0ABzY41USqMKVMVE5Z4.8holL5LfhgpGaQx6e88OqBGw
 QJFD7pbhcfNuieoC4xi32M9XRSDrJna.20cggK2yf56v.jg8PH1AEzv_JV0U9CRgWcn8O8Fg9UXg
 v.nxoVOOv7mfdO9Y6rpCvvJGZvCgsbeSxBtaOJvNUJbDPMi9OCJRho98pUW0XhJ6joln0Q6u8YeC
 GfBOGR6aPa5x6_yroXlIk601Y3O3_Ud87LuLNWWyQ.fYxdIzCSVRTKn_baTL7gTUKbayMClYcDGv
 jfyoO.PzOOdxBcKEBlO6YDshjEoCOFjRUHmTxpoSB3dJvKuZiSq0F1egvddqunpvz7zBJ5jjTgHR
 du2sPsSXr.fQJlJvIaVjNGRKff1QQAHXU7HZDOfjCv6U5EQWhXDcQKeIeYBJ.x9TpbRoFryfTpuL
 dHxKTxYLRCflrJnsiudVvWb34cWBTWc0gKv3qDfsZieog2f6Pur2BPi7vYe8TVKXHlBeoxTsTbnQ
 BfvJmQOG1plfWm7_etCgP4g5reOW7WgsrjwM0GP_sPcngz71QtJAd2WVppzuixbJNG74jrQWmfYO
 wFlVm80buNUQvqEqdeIxJ_BpaGMfJS8mEdOxi5mSyNNa6AILduxm8kUZt2LqVm6OjVOyiB.oapHZ
 P2NqV1H3Sy37jVIgHr9k5EBxQSHIPBiInamJeaF_Cvup7a3.pf7LkDSvMzfP.W1z7GiSI0LiJfrk
 cJwVQI4CpqOMuHYhitYgYrdQDJvq9yIxkYf_0MMytb_HnQPo9kG7uedfHP3AIKWrEuytCduuc4ff
 eRYPXXTCJ5prELuycuMJFvxB.JvyJH1HpaL6hoe9EYk8N.3.HxQovQSJMJhPX8MKQFIc1y.cajJY
 zmoNDFLE9lkfjQkfj9I4C1H5CyZhuBRs1W9Lf4fK9hsScxsrqnHQGf2EYAE2UCuMAdeGKyUo622U
 Mm2eh31CQGyMUVAe2TIY7blXxOuGcXGMr0RN3a8G7qtzt._6Mq6xR0Tifmy6kiBvbLXeDAsPgNam
 Bv794PHcb5i_yLxMoe6Ud6st9KYPzx4OYNuv50cGK3xnSNEk1E3eYSRbjDXaDNTF.PEsSaLNgKaL
 7QdVXgIsm32YT.EF.dfKbrALwU.KAXXy00g769WxVy78kbvl0IjbQzyIjZPs_MbhihWEJbvFakia
 igD7EjKxj86fQNj5K7J6_65ncZaT4og0B87VEIpdFWO6Ta0Az7.BRDKSDKJSf6M_nK_0KLerfrQa
 rMtn8YLeKll.VmSooUj5A8gTZmz5N13uxwRHa9xp1C.lBxdiEYHy1qqcQ_5BMa5HAqYehIJI.3eU
 Vv5Zsxjv7PXRePCgM5f8MR2Qi6EIrKJqir8LNEbEkD2tu7iw0TEi6WclRLdxtcdvNfnMnzodtDh.
 ZY3GacfPFGkL3GE.UAURMDboiW7BnnFZWPempZZ8O4cyF9L1uarau6DFJv3jFnLYfTdwb6c6dVpg
 Qpx1WWnDrHpMuN7Hd0zIMILdXwfkU75DSFCZgdXieGD64ZlucBo6JONUX76MvR3OswLTi40Tnnhc
 7IvaxyzevhAzXWok0gSLy4Vj85jOJTFdhOAqscWFr95GGpQPEA9p4F1pDveTknTGQT0qMr7jtWkk
 cGI17JQDy.Pi0HE_iDyykAvjus10lrptU0B7YvyzS9euI.B5kKRJjjBaGtnoyRg_mFbjguwaQazz
 DFRrU99twLbTrI078EDn6dzcxKq6ePsk.0guxvsV.AIRadPF04U9..onKPZT6m6xckWt6RAhTOzQ
 uR0n44FjPF1GT1eIyjMHfQ4VXEoohcE1T9spmIVmo65CtCf1Jn4wdmcq.Nczyh6YppyOHarVG4Pu
 nv1Ropaa.Oquq7Epvs_U8FtuzaQWZuRWn6wLQ2dTIqMPZa_CG0Ae5Eq61mUG.Kxa6zyq5xDoeP_3
 aiCpf_DzaUTblZF9_z8SpVMEXL7rCENhlZ7lxdJMtcpXot4Q96MUYvXu6.ByVt6d2s0YrGqV_1wr
 QMq41m55CeAwXzCyXPOyb29Nf7iS_Vh6P2OS1aejuAMsgTg14ZhGpl2KGZqSI99q25LEJ10f7Kel
 9YR6WWm6Rb.1BcBh9X0QUsF2wLcTQR6SzqwRRiqplteaxQAUuwC18amkHMgvPorHGjCHltf.bNcW
 3mPaTPTanoR3kKAntEHtF4xiQ4Br1KmTDd5YYMz9fDlgIz_GzM9qDyrAk3TNR90bJMldrazxzEtb
 6kaHeGL4-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:50:19 +0000
Received: by kubenode551.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 7c0e493102cc6a75e535814ae41a581c;
          Wed, 24 Nov 2021 01:50:15 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 06/28] LSM: Use lsmblob in security_audit_rule_match
Date:   Tue, 23 Nov 2021 17:43:10 -0800
Message-Id: <20211124014332.36128-7-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Change the secid parameter of security_audit_rule_match
to a lsmblob structure pointer. Pass the entry from the
lsmblob structure for the approprite slot to the LSM hook.

Change the users of security_audit_rule_match to use the
lsmblob instead of a u32. The scaffolding function lsmblob_init()
fills the blob with the value of the old secid, ensuring that
it is available to the appropriate module hook. The sources of
the secid, security_task_getsecid() and security_inode_getsecid(),
will be converted to use the blob structure later in the series.
At the point the use of lsmblob_init() is dropped.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: linux-audit@redhat.com
---
 include/linux/security.h |  5 +++--
 kernel/auditfilter.c     |  6 ++++--
 kernel/auditsc.c         | 16 +++++++++++-----
 security/security.c      |  5 +++--
 4 files changed, 21 insertions(+), 11 deletions(-)

diff --git a/include/linux/security.h b/include/linux/security.h
index ddd4cf48413c..d846d90f5624 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1954,7 +1954,7 @@ static inline int security_key_getsecurity(struct key *key, char **_buffer)
 int security_audit_rule_init(u32 field, u32 op, char *rulestr,
 			     struct audit_rules *lsmrules);
 int security_audit_rule_known(struct audit_krule *krule);
-int security_audit_rule_match(u32 secid, u32 field, u32 op,
+int security_audit_rule_match(struct lsmblob *blob, u32 field, u32 op,
 			      struct audit_rules *lsmrules);
 void security_audit_rule_free(struct audit_rules *lsmrules);

@@ -1971,7 +1971,8 @@ static inline int security_audit_rule_known(struct audit_krule *krule)
 	return 0;
 }

-static inline int security_audit_rule_match(u32 secid, u32 field, u32 op,
+static inline int security_audit_rule_match(struct lsmblob *blob secid,
+					    u32 field, u32 op,
 					    struct audit_rules *lsmrules)
 {
 	return 0;
diff --git a/kernel/auditfilter.c b/kernel/auditfilter.c
index db427e136368..ffbd8396bdc9 100644
--- a/kernel/auditfilter.c
+++ b/kernel/auditfilter.c
@@ -1338,6 +1338,7 @@ int audit_filter(int msgtype, unsigned int listtype)

 		for (i = 0; i < e->rule.field_count; i++) {
 			struct audit_field *f = &e->rule.fields[i];
+			struct lsmblob blob;
 			pid_t pid;
 			u32 sid;

@@ -1371,8 +1372,9 @@ int audit_filter(int msgtype, unsigned int listtype)
 				if (f->lsm_isset) {
 					security_task_getsecid_subj(current,
 								    &sid);
-					result = security_audit_rule_match(sid,
-						   f->type, f->op,
+					lsmblob_init(&blob, sid);
+					result = security_audit_rule_match(
+						   &blob, f->type, f->op,
 						   &f->lsm_rules);
 				}
 				break;
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index 1aa8ffdae0ad..de22e852373a 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -468,6 +468,7 @@ static int audit_filter_rules(struct task_struct *tsk,
 	const struct cred *cred;
 	int i, need_sid = 1;
 	u32 sid;
+	struct lsmblob blob;
 	unsigned int sessionid;

 	if (ctx && rule->prio <= ctx->prio)
@@ -669,8 +670,10 @@ static int audit_filter_rules(struct task_struct *tsk,
 					security_task_getsecid_subj(tsk, &sid);
 					need_sid = 0;
 				}
-				result = security_audit_rule_match(sid, f->type,
-							f->op, &f->lsm_rules);
+				lsmblob_init(&blob, sid);
+				result = security_audit_rule_match(&blob,
+							f->type, f->op,
+							&f->lsm_rules);
 			}
 			break;
 		case AUDIT_OBJ_USER:
@@ -683,15 +686,17 @@ static int audit_filter_rules(struct task_struct *tsk,
 			if (f->lsm_isset) {
 				/* Find files that match */
 				if (name) {
+					lsmblob_init(&blob, name->osid);
 					result = security_audit_rule_match(
-								name->osid,
+								&blob,
 								f->type,
 								f->op,
 								&f->lsm_rules);
 				} else if (ctx) {
 					list_for_each_entry(n, &ctx->names_list, list) {
+						lsmblob_init(&blob, n->osid);
 						if (security_audit_rule_match(
-							n->osid, f->type, f->op,
+							&blob, f->type, f->op,
 							&f->lsm_rules)) {
 							++result;
 							break;
@@ -701,7 +706,8 @@ static int audit_filter_rules(struct task_struct *tsk,
 				/* Find ipc objects that match */
 				if (!ctx || ctx->type != AUDIT_IPC)
 					break;
-				if (security_audit_rule_match(ctx->ipc.osid,
+				lsmblob_init(&blob, ctx->ipc.osid);
+				if (security_audit_rule_match(&blob,
 							      f->type, f->op,
 							      &f->lsm_rules))
 					++result;
diff --git a/security/security.c b/security/security.c
index c472cac72641..238541218ca5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2680,7 +2680,7 @@ void security_audit_rule_free(struct audit_rules *lsmrules)
 	}
 }

-int security_audit_rule_match(u32 secid, u32 field, u32 op,
+int security_audit_rule_match(struct lsmblob *blob, u32 field, u32 op,
 			      struct audit_rules *lsmrules)
 {
 	struct security_hook_list *hp;
@@ -2691,7 +2691,8 @@ int security_audit_rule_match(u32 secid, u32 field, u32 op,
 			continue;
 		if (lsmrules->rule[hp->lsmid->slot] == NULL)
 			continue;
-		rc = hp->hook.audit_rule_match(secid, field, op,
+		rc = hp->hook.audit_rule_match(blob->secid[hp->lsmid->slot],
+					field, op,
 					&lsmrules->rule[hp->lsmid->slot]);
 		if (rc)
 			return rc;
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 4AE12C433FE
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:51:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237914AbhKXByf (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:54:35 -0500
Received: from sonic308-16.consmr.mail.ne1.yahoo.com ([66.163.187.39]:34813
        "EHLO sonic308-16.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S233344AbhKXByd (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:54:33 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718681; bh=EBxxjY8HejFxSXh3rI/36jrcmdb6/eBEzzs0STL4Jzk=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=frr2jzCVToVgiH1Yy1dp47lO7otKY1VGlgXECi/Vp6DUWzngkaBLsLh4iSiOhxOvGk+7FsrsIjD/eaMQXpWRgL40QRtUF3zYoAXimkYWgDyrjCeYHKVw6VW05hPGTrq/gcW+vzgSzGLSHj8lGXgZHKiqjJ8gBfyDo3ilwFJfEKHN8IZTK0aHbDCW4deJoe90tpoiyuYZCenCWEDD42J5njOnz5jSMsmkfu23MtI4JpOcznYE1HaigVG1V56Gw0RkMrtwAzXPrjE3l+cMfFJais2Od4+zjzFoexoqm3o1EBNIsI4JYId3Ql7OxlVpBp0YFHjMfxIsF0q7I5FlEb2+RQ==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718681; bh=jpJYD2zH5oEMqk9iGd3KVZ0pavAkPNyogBAps63gZPY=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=QqSVAtQh3dw0yQGqIlOWoqCxb/Y3/hY+L5UGNe5RQ7sSUW8DxYO+zXK1CWBnMXneJSLT7n9YLCrzXFS9yeNyp1tHiHMktlJuyRQ5QyoK9Dyt4olzc1i0lczW3FD/Hv+8m/qrO5aZa7mR9scxLOlOG+ImoGqRIXit9SZ7B+GC35EkKvYFH7n61dzKjy57zhCDnGG3vXMLKAeU2uK6UzUv26qjiZffja685RRkob92vmOyCDFFkUvHO2kDMc+xsm+Zws/8g4tLt0Lk71Mul5JY/a61oj29omS443IjRWen7zWb7BTfMlxvjZwBRrEMzdYGZQjp/73QgRMI35ecWRqx6A==
X-YMail-OSG: 19onif0VM1ntavtDQ7sSB0Cxu1TzQFMGv8BQ1yXKXqAQ64_kwJpsnBAtz6yda3R
 OqEYE.iIKba99MdJZFNBhjejQiJDHZhPRyFtHOLO3CdAY0CcKnkOXGr4dX4osSVv2hMRPJbBl_Nw
 0nJDC9JnBTJj9LptgJLrKb8RvrlkAImC58qeaixHCgCb3rfMAAOVWIibMK06SpCve.4uTJHoN6_g
 8yPLGGPidlYvqAdyfaicbLWwuD7i.h1OXMf3chbknJu5l9HbjISFdziJ7YlHSt1kf3Hsk3rMtm3R
 wzZQOWjokZbxiD9iZOK3ZLv1eIo_K_KU_Iwdc1kdePgBhfBomqQ9rlnViRSMGb_Nufj84_6ONkAg
 rLisw_Y7.NT8bXrZx.V6AOBBOLMllwCyhd7Rn1sFduCVXaYz28Fg9s2u7ry9uyKLaFQY.H8F5mEg
 vc7K7nT36BFXINptNqVFmFObIMibKPQXi9vG0XZCyPaYBcCBq9hflJ2._afm.f4xewJS2SrRnm.H
 TCWRCUnS0mgCNrBp384J3OtVxgt6RtiVpeu0e1FH8qD8EELp2JuNuSFzksgiMMqRuJXNd1Mhsxz9
 QKn5yQy4WmKshguAF4Q596PUU8yOBYQIOmbTgwQT0JEKqk2fUw6ygphQi.sR7ahmh5F72wG.H2vf
 aYPvWAcrI0obQlhRdOPALcOyLzp3knb.CyL1INT9i1XnAdK1dQvhFC1qW1zzhHeCa8_82iFKGOoH
 3K7_ocAFUMUyBRdSOZU6rG47.o3vR._07DIreln4E8UpDr6lKUofYuM1JKQLaTTB9Yot38zbmav6
 EWb6ipGIGF9_6ofEl6PDMrbofsKf1P56ofTG1AfF.hR810Sy31likXM8znzSgo_P22WYzTVkvhNy
 PQTT1.6XO5lUc_MJdj5MRAOm3plcN09cyvGp5KJviWBYFO9JsasfdWfpvx90ixEo778UMpJ2ktRz
 An.xt9cigRAlv9hc79.k.339A9o5EHxRR_fvreg3X1_BVfT3aiYVi8bzA02lOfm5eWVuyJO4w6RG
 LJvxpWo5rElbztcKZzDuMqqo7LUL_FgeucgQp6LLnssdoWzXBEOHptcC0RoljvQ2tZTVbBFXKnt3
 AEpXn1lOs1gkutoEGLYyVjQD.5DnaVbTbXlG75XSE5qtOH8dgI4hSQdZr6TrlNFRuKc99bgq6.NZ
 2RrUUdHh43jF7Dl6Q2F3dyqUZ2oto6OqEFR4haYN.39b6G1m2ZeN6lL9rV4OgH4PeK_yk2KzyzhC
 oy5PSqm8lkzWD6nOhYGbnxBtn9ODh4kSNwE_BQ3zZwWaJMWNS1npqtx8ThMigqVBHwiTv90MuGrM
 uVe.NtFe0I8ZPajyxPz_ShczZ9K8lYeF3BDpmU10GJclcPEWhP894c6rHmf3OBwq0b1cKVRigvef
 0QQLvBWmJZbixgpD0csP27kq9e2hB05W89w2qBf_ckO7sat9A5Go4xEGFDLS6RtD5pzbwX5bEEVo
 pTr.A0NCMNoS2ELhwzV21ImY3dk78z1asb.kPPhOXzfcjq_hKuw.gK.F_URFz8C7yfWZDZTbxTAI
 uIRFfhFHBnx9Ra1oemjtlePyn.p8napk8A5Hp4tOYDWXWhNLgDEdvUtzbTOXKWUoRRKEVKofpa4S
 SA77mOW9T73ZjMZHs2CNLDsWbLjDgJmyUgwEK9XwGlaU335ljwWBD_1f2nSL5OM3bP0LLIuC6a2Z
 L6E7UkDGugWE17740eTSsOLutKmGQRtTXIr5l0MmsdvUG0gvzWLc65.wJs9guMiMCLSm.72n79jo
 fVosvXI8QdISryueZZEO6d4I2SWayMRcXSFQ4IPyL5it2D53sOxmJbyxUSEqkO0O5LRHfbir8lbd
 XayjyQVh.OOi.clI3brS7c7T4yNAjDXfoqtkj8kybagKyMXbqj8uEbxzP1MBKD1Ky5.Z9gP2xiI6
 2Dv4a0ZB3.czqS9oqi0BbG_q.wIX4z6CRKZHYWdckKpOnCB0l1MzGptwUK57KQ2IfokH7Q0dpWMJ
 h6SK_6x01CSKVjlSopMerQFyGyBL7xadLSEWa1pEDSh5DRdieDG1ISHRcT8zWKUIFHtoRRy7nzwr
 QbXoyGSx0jlwiMLnUJqKJbiHzT04xkQ4PkXBqIC2AI85YJ3GFOt.luV_dfTM6Jl8GQr1wqKSY.4E
 6qx1rm6hLJ_PFPbSgw4.4scLhmepbV3rFt7QqvkAHJ6U73FQzcP1fFlwVqH1jMl3bOGI6kg9pKjR
 9t_PVUasDjti7UsGMz22sWoqm27A6
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic308.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:51:21 +0000
Received: by kubenode524.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 5fe41457cad84811041d12332dccb872;
          Wed, 24 Nov 2021 01:51:22 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>
Subject: [PATCH v30 07/28] LSM: Use lsmblob in security_kernel_act_as
Date:   Tue, 23 Nov 2021 17:43:11 -0800
Message-Id: <20211124014332.36128-8-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Change the security_kernel_act_as interface to use a lsmblob
structure in place of the single u32 secid in support of
module stacking. Change its only caller, set_security_override,
to do the same. Change that one's only caller,
set_security_override_from_ctx, to call it with the new
parameter type.

The security module hook is unchanged, still taking a secid.
The infrastructure passes the correct entry from the lsmblob.
lsmblob_init() is used to fill the lsmblob structure, however
this will be removed later in the series when security_secctx_to_secid()
is updated to provide a lsmblob instead of a secid.

Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
To: David Howells <dhowells@redhat.com>
---
 include/linux/cred.h     |  3 ++-
 include/linux/security.h |  5 +++--
 kernel/cred.c            | 10 ++++++----
 security/security.c      | 14 ++++++++++++--
 4 files changed, 23 insertions(+), 9 deletions(-)

diff --git a/include/linux/cred.h b/include/linux/cred.h
index fcbc6885cc09..eb02e8514239 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -18,6 +18,7 @@

 struct cred;
 struct inode;
+struct lsmblob;

 /*
  * COW Supplementary groups list
@@ -165,7 +166,7 @@ extern const struct cred *override_creds(const struct cred *);
 extern void revert_creds(const struct cred *);
 extern struct cred *prepare_kernel_cred(struct task_struct *);
 extern int change_create_files_as(struct cred *, struct inode *);
-extern int set_security_override(struct cred *, u32);
+extern int set_security_override(struct cred *, struct lsmblob *);
 extern int set_security_override_from_ctx(struct cred *, const char *);
 extern int set_create_files_as(struct cred *, struct inode *);
 extern int cred_fscmp(const struct cred *, const struct cred *);
diff --git a/include/linux/security.h b/include/linux/security.h
index d846d90f5624..e6dd3463604e 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -464,7 +464,7 @@ void security_cred_free(struct cred *cred);
 int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp);
 void security_transfer_creds(struct cred *new, const struct cred *old);
 void security_cred_getsecid(const struct cred *c, u32 *secid);
-int security_kernel_act_as(struct cred *new, u32 secid);
+int security_kernel_act_as(struct cred *new, struct lsmblob *blob);
 int security_kernel_create_files_as(struct cred *new, struct inode *inode);
 int security_kernel_module_request(char *kmod_name);
 int security_kernel_load_data(enum kernel_load_data_id id, bool contents);
@@ -1112,7 +1112,8 @@ static inline void security_cred_getsecid(const struct cred *c, u32 *secid)
 	*secid = 0;
 }

-static inline int security_kernel_act_as(struct cred *cred, u32 secid)
+static inline int security_kernel_act_as(struct cred *cred,
+					 struct lsmblob *blob)
 {
 	return 0;
 }
diff --git a/kernel/cred.c b/kernel/cred.c
index 473d17c431f3..e5e41bd4efc3 100644
--- a/kernel/cred.c
+++ b/kernel/cred.c
@@ -772,14 +772,14 @@ EXPORT_SYMBOL(prepare_kernel_cred);
 /**
  * set_security_override - Set the security ID in a set of credentials
  * @new: The credentials to alter
- * @secid: The LSM security ID to set
+ * @blob: The LSM security information to set
  *
  * Set the LSM security ID in a set of credentials so that the subjective
  * security is overridden when an alternative set of credentials is used.
  */
-int set_security_override(struct cred *new, u32 secid)
+int set_security_override(struct cred *new, struct lsmblob *blob)
 {
-	return security_kernel_act_as(new, secid);
+	return security_kernel_act_as(new, blob);
 }
 EXPORT_SYMBOL(set_security_override);

@@ -795,6 +795,7 @@ EXPORT_SYMBOL(set_security_override);
  */
 int set_security_override_from_ctx(struct cred *new, const char *secctx)
 {
+	struct lsmblob blob;
 	u32 secid;
 	int ret;

@@ -802,7 +803,8 @@ int set_security_override_from_ctx(struct cred *new, const char *secctx)
 	if (ret < 0)
 		return ret;

-	return set_security_override(new, secid);
+	lsmblob_init(&blob, secid);
+	return set_security_override(new, &blob);
 }
 EXPORT_SYMBOL(set_security_override_from_ctx);

diff --git a/security/security.c b/security/security.c
index 238541218ca5..f3d30ef512d4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1800,9 +1800,19 @@ void security_cred_getsecid(const struct cred *c, u32 *secid)
 }
 EXPORT_SYMBOL(security_cred_getsecid);

-int security_kernel_act_as(struct cred *new, u32 secid)
+int security_kernel_act_as(struct cred *new, struct lsmblob *blob)
 {
-	return call_int_hook(kernel_act_as, 0, new, secid);
+	struct security_hook_list *hp;
+	int rc;
+
+	hlist_for_each_entry(hp, &security_hook_heads.kernel_act_as, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		rc = hp->hook.kernel_act_as(new, blob->secid[hp->lsmid->slot]);
+		if (rc != 0)
+			return rc;
+	}
+	return 0;
 }

 int security_kernel_create_files_as(struct cred *new, struct inode *inode)
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 72CE7C433F5
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:52:40 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S238521AbhKXBzq (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:55:46 -0500
Received: from sonic308-16.consmr.mail.ne1.yahoo.com ([66.163.187.39]:36226
        "EHLO sonic308-16.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S238049AbhKXBzj (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:55:39 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718746; bh=FKZoy7Ae8g2fJFCJVup+YbOhxC6lR8pSGHi0aTX2obw=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=o+0wnoaLLoddnCCOifSoV9Nf7Gl7RVXd1s5Ib6AA9Hjr3X8G6RrSLo7hK+840PO2dep4P36ZmJj/pr42OknpB6ypHPPQ6xuHHiOvEp4beZbhV2vfkWG0E8g6fzlKA0NEpr0ZsQ7H6y6/AHV313Pc+Odw+lSUycljO21oAOm7ZUQePJGVl391MezfgGzSkhu2jHkBGLF1KrCztSeKQYBym+7yKmAuPCfJ4+1aLyz7mkf7bKIqIrSYMW4OEEPkeW50Kcv83zrvoIpheZnBVsMK+Su2q8F2SPNzqbgxIg/b036o0jSWOauQAbAd+O8UskJMZtxAtSUb5TyZZ6MhlHShYg==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718746; bh=Fw3f7wMa7P1VShv4P45ZOnt7nbBNdy7u8bLYO3jHjEr=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=GVQTD5L7Hj3lKsbocR6W7X1n1rD23GlTGs18k2GbeB/Y8SQnGMFinqBp37LvAVvirAWfLyiW+XmSaQB59t22sIxmc0cuoXhXMWSKzmxNHQii0MLe+f+5oKkUqNJLIj0WDyHep8mK+b6BTQRL99IcHm4Y6WCJvocQ+TFol8K7ptn3kKkYvyi5/SgOBepusc/IxgW8sK4a+LK2HoKJiYW2O6Cpq9kRlT+J1uaGGgZJTUpvK2fhKveEt+0GpiwQHu+ysmZNOv+UFMXI9cg7bB/Kz3jMxz/MFqcJ8NgG0xctU5kaSN3WM93C0T0HMr2x3d0x07J8lZX/fZp3mGQhgF0fWA==
X-YMail-OSG: iV3YhFMVM1lqFYBw.s6ixUNEV_LMBo.FcpmQ5uhOPx7FmkLPMHkV9ewG2VRjP0i
 fXBpnoOto_ZlFmseGQ3MPVCxE1wWUWiE0EfEXccNni23nej1qaNPyT.z3g2qiO.uJWsZ3avIEMkl
 Ii_.7nmdlBlCKI1pYkKTfgM0KlW022rKeUl.AWNbdVKRJRNMqBC9bk0Mz8od1yxPv.GuOZls1Yfg
 HowEhn2wOzaMmBc9q_sYfjx_fHVcOtQSX0qTCWvtbCZpd0UfZ4QyuiEVfmY3sOXfPni2.v3Rib4P
 ibjeKTzRpFoLGW_J9pbxniw92MrdqUOzG2cWfTGIG_Cp6sFIFMZyN0Y96b7cAf8CllM1Rud_Zmku
 .XwEgaLKkm5rw7Fbs6WzqiLf8Hcj1U1Urrb6yjX1gffDLhG9Z7kacYxkqLcxSRkqHc4RhbDfSOAB
 6tK1FvSXTyd2BBBNheYGIVPoFhF2.571veXF.6groGvnQqMkhPqqIyBby5i6grAsXANL7kjrK5LS
 1i3g2yRDjT5wZKI2bdsBYux5Z0mc2XZg.Gj8wgZ_rdWWd_cWEKuH9QziTRGj6UP73bgw7jLTJ.qx
 PeXz_Hw.4R30e3VwLL3fNWw2Vdy_CdG3aBMfxSJoejVbWoUpD3BSKBJ.GK3x79epIMeQY4iifhdD
 OGIDCfsoh0.Fc_jtlG9THFe_UPZhOn.vD2jubxf9FMdz1xzRWkh2puYHv8ODimSjeXzl5JGkh1CR
 XSAXhejTb9uMsX__eF7PBeB_Nn4mPSzZipYxk.MecR1422eY5xUmzODF19jZQDZg6Cky19iMzP.o
 N2QAAz9QkoBIYtvhjvBlbPpid9_XWljhkIQx41KKaAC4R8S0bm91vklCoaFIxJn9zP.45zpUkEFE
 gfTrB._ZqnimBhfc7CHNyrEpVFEmRp4P2sn.lm8c7yJVfyEqRa6pVwlWytQZCkK3PTkF.vMtbFTG
 OQ9O.gbbxS9KJj9aJiitJ07aRxdGTeEECr8pYdqNF2Ji_6wUFiExmc0qktU0jIqEyX7RRgMZkxl5
 yMEWZhtmS7ZW9TijFFDcR0.mMJU4gfo6iQpZONMZqZ9WE93UBq5vTt8xFaFObqPGiWKdwTGe541_
 M9SX_yECQC9bRm6KYr3zibY0QNhOmwjicYsutFJY.T9rSUmEHR7P9aRtCnsehqHG2a7zXNLlBjA4
 P5Ei3CdogSeOIaBOIlcD54t7zV1cuEKbp6tlbgz2MTvYBK7E7a3CCrfYYbtCKllkkX2nJdLQTFCD
 RvBWSE5eaIPnjg9zXLJvff0JTSU37k3LxBD7ljNMie9D0gSP_cebFuo8RBbS9usVeXobqZubQt2F
 I_7.prSNDo8Vjn0Bci4MyzSUDY9mriSIw8p0KOYM.63KsSSRMx4pC0N.TKNo9ZMCu.ex6qiBpgaB
 XmLDzNn28rZQkmJLneIjqpkEkXWjV2ZyZqLPunWmzkjbd3.ZsREvVUCnU7DLoU5oaydcsW82Acdg
 ByFi28zNTHHfGxj0Zsgo9Z8udo80aaAJ.3WfkCQBEXrBgweTs0FZ2E9D1eF0qja0u.E5QYFN_vJs
 dRc5NXkSZnqL3woRfavu6pylWFqM8OjUymePviSxqSNNxUeulnJZPkldZCl1qdLr7gvuAABNgI9U
 uqpAFg2S07KJfoPa.7YV14875IZtFicMqOVpZ5d0h6p0Gnv6N2ixKjSXpelIb0.fpApP498ieGcm
 Mqfxjn9TTgDoVlXBcJiIvASVaFQrH_9YMKVs7vdr8gyToy_WxuVr1b8KvvZQKuO.SG8DwpXdSmUT
 BoV._geAmdieKwe5PQKhZUddIQtnfGl97ZvNl2A.BLJzh4I6KljT.chtbZg6HVBdMHRkaePQ2k5s
 0zuRN8l0B56eZbx_b7YwlMsEw4WKnmHG_UI9jabrVV._CkWHlecJYaY6dLMuyNGw_zhTd5HDoffq
 khPctibUOy9Ohh3PugVDh0dhDFozxsW3f6WUdpV5.2KRTXSMA9xKaU0eDP6WqFns_UJZRNqjRyQF
 OhpzAzHHz4hcuf0KWQm.ZUXWxlxyQF9zqYxANik0fTQbOeSCTjwc.1lwrE4Z770M3TxS7i807ZH6
 NNMUAWcJ030V1t2cnY.uRLrQff77XNeg6Ub9abKlWaYVFL_puycDr2JjAbJX0JEp6SrEvgxlE0Ua
 6G2nn6W.ZcUkvcrrQ3DvOa6MsV.7_1ArKoUC8BblL46_X6IBAmsdANNDF5FNpRrrnno_283m.vEq
 599i8DrukkMrjzb5QD7xo4fjz.MXsrZ9EpOO3ptPpg4hCAxY9YWI8ekAz
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic308.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:52:26 +0000
Received: by kubenode504.mail-prod1.omega.ne1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID f73285a66f3fbf39f2e43e2b2e480b38;
          Wed, 24 Nov 2021 01:52:28 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        netdev@vger.kernel.org, netfilter-devel@vger.kernel.org
Subject: [PATCH v30 08/28] LSM: Use lsmblob in security_secctx_to_secid
Date:   Tue, 23 Nov 2021 17:43:12 -0800
Message-Id: <20211124014332.36128-9-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Change the security_secctx_to_secid interface to use a lsmblob
structure in place of the single u32 secid in support of
module stacking. Change its callers to do the same.

The security module hook is unchanged, still passing back a secid.
The infrastructure passes the correct entry from the lsmblob.

Acked-by: Paul Moore <paul@paul-moore.com>
Reviewed-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: netdev@vger.kernel.org
Cc: netfilter-devel@vger.kernel.org
To: Pablo Neira Ayuso <pablo@netfilter.org>
---
 include/linux/security.h          | 26 ++++++++++++++++++--
 kernel/cred.c                     |  4 +---
 net/netfilter/nft_meta.c          | 10 ++++----
 net/netfilter/xt_SECMARK.c        |  7 +++++-
 net/netlabel/netlabel_unlabeled.c | 23 +++++++++++-------
 security/security.c               | 40 ++++++++++++++++++++++++++-----
 6 files changed, 85 insertions(+), 25 deletions(-)

diff --git a/include/linux/security.h b/include/linux/security.h
index e6dd3463604e..65dc61067e7c 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -198,6 +198,27 @@ static inline bool lsmblob_equal(struct lsmblob *bloba, struct lsmblob *blobb)
 extern int lsm_name_to_slot(char *name);
 extern const char *lsm_slot_to_name(int slot);

+/**
+ * lsmblob_value - find the first non-zero value in an lsmblob structure.
+ * @blob: Pointer to the data
+ *
+ * This needs to be used with extreme caution, as the cases where
+ * it is appropriate are rare.
+ *
+ * Return the first secid value set in the lsmblob.
+ * There should only be one.
+ */
+static inline u32 lsmblob_value(const struct lsmblob *blob)
+{
+	int i;
+
+	for (i = 0; i < LSMBLOB_ENTRIES; i++)
+		if (blob->secid[i])
+			return blob->secid[i];
+
+	return 0;
+}
+
 /* These functions are in security/commoncap.c */
 extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
 		       int cap, unsigned int opts);
@@ -530,7 +551,8 @@ int security_setprocattr(const char *lsm, const char *name, void *value,
 int security_netlink_send(struct sock *sk, struct sk_buff *skb);
 int security_ismaclabel(const char *name);
 int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen);
-int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid);
+int security_secctx_to_secid(const char *secdata, u32 seclen,
+			     struct lsmblob *blob);
 void security_release_secctx(char *secdata, u32 seclen);
 void security_inode_invalidate_secctx(struct inode *inode);
 int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen);
@@ -1391,7 +1413,7 @@ static inline int security_secid_to_secctx(u32 secid, char **secdata, u32 *secle

 static inline int security_secctx_to_secid(const char *secdata,
 					   u32 seclen,
-					   u32 *secid)
+					   struct lsmblob *blob)
 {
 	return -EOPNOTSUPP;
 }
diff --git a/kernel/cred.c b/kernel/cred.c
index e5e41bd4efc3..a112ea708b6e 100644
--- a/kernel/cred.c
+++ b/kernel/cred.c
@@ -796,14 +796,12 @@ EXPORT_SYMBOL(set_security_override);
 int set_security_override_from_ctx(struct cred *new, const char *secctx)
 {
 	struct lsmblob blob;
-	u32 secid;
 	int ret;

-	ret = security_secctx_to_secid(secctx, strlen(secctx), &secid);
+	ret = security_secctx_to_secid(secctx, strlen(secctx), &blob);
 	if (ret < 0)
 		return ret;

-	lsmblob_init(&blob, secid);
 	return set_security_override(new, &blob);
 }
 EXPORT_SYMBOL(set_security_override_from_ctx);
diff --git a/net/netfilter/nft_meta.c b/net/netfilter/nft_meta.c
index fe91ff5f8fbe..c171c9aadb01 100644
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@ -813,21 +813,21 @@ static const struct nla_policy nft_secmark_policy[NFTA_SECMARK_MAX + 1] = {

 static int nft_secmark_compute_secid(struct nft_secmark *priv)
 {
-	u32 tmp_secid = 0;
+	struct lsmblob blob;
 	int err;

-	err = security_secctx_to_secid(priv->ctx, strlen(priv->ctx), &tmp_secid);
+	err = security_secctx_to_secid(priv->ctx, strlen(priv->ctx), &blob);
 	if (err)
 		return err;

-	if (!tmp_secid)
+	if (!lsmblob_is_set(&blob))
 		return -ENOENT;

-	err = security_secmark_relabel_packet(tmp_secid);
+	err = security_secmark_relabel_packet(lsmblob_value(&blob));
 	if (err)
 		return err;

-	priv->secid = tmp_secid;
+	priv->secid = lsmblob_value(&blob);
 	return 0;
 }

diff --git a/net/netfilter/xt_SECMARK.c b/net/netfilter/xt_SECMARK.c
index 498a0bf6f044..87ca3a537d1c 100644
--- a/net/netfilter/xt_SECMARK.c
+++ b/net/netfilter/xt_SECMARK.c
@@ -42,13 +42,14 @@ secmark_tg(struct sk_buff *skb, const struct xt_secmark_target_info_v1 *info)

 static int checkentry_lsm(struct xt_secmark_target_info_v1 *info)
 {
+	struct lsmblob blob;
 	int err;

 	info->secctx[SECMARK_SECCTX_MAX - 1] = '\0';
 	info->secid = 0;

 	err = security_secctx_to_secid(info->secctx, strlen(info->secctx),
-				       &info->secid);
+				       &blob);
 	if (err) {
 		if (err == -EINVAL)
 			pr_info_ratelimited("invalid security context \'%s\'\n",
@@ -56,6 +57,10 @@ static int checkentry_lsm(struct xt_secmark_target_info_v1 *info)
 		return err;
 	}

+	/* xt_secmark_target_info can't be changed to use lsmblobs because
+	 * it is exposed as an API. Use lsmblob_value() to get the one
+	 * value that got set by security_secctx_to_secid(). */
+	info->secid = lsmblob_value(&blob);
 	if (!info->secid) {
 		pr_info_ratelimited("unable to map security context \'%s\'\n",
 				    info->secctx);
diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 566ba4397ee4..762561318d78 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -880,7 +880,7 @@ static int netlbl_unlabel_staticadd(struct sk_buff *skb,
 	void *addr;
 	void *mask;
 	u32 addr_len;
-	u32 secid;
+	struct lsmblob blob;
 	struct netlbl_audit audit_info;

 	/* Don't allow users to add both IPv4 and IPv6 addresses for a
@@ -904,13 +904,18 @@ static int netlbl_unlabel_staticadd(struct sk_buff *skb,
 	ret_val = security_secctx_to_secid(
 		                  nla_data(info->attrs[NLBL_UNLABEL_A_SECCTX]),
 				  nla_len(info->attrs[NLBL_UNLABEL_A_SECCTX]),
-				  &secid);
+				  &blob);
 	if (ret_val != 0)
 		return ret_val;

+	/* netlbl_unlhsh_add will be changed to pass a struct lsmblob *
+	 * instead of a u32 later in this patch set. security_secctx_to_secid()
+	 * will only be setting one entry in the lsmblob struct, so it is
+	 * safe to use lsmblob_value() to get that one value. */
+
 	return netlbl_unlhsh_add(&init_net,
-				 dev_name, addr, mask, addr_len, secid,
-				 &audit_info);
+				 dev_name, addr, mask, addr_len,
+				 lsmblob_value(&blob), &audit_info);
 }

 /**
@@ -931,7 +936,7 @@ static int netlbl_unlabel_staticadddef(struct sk_buff *skb,
 	void *addr;
 	void *mask;
 	u32 addr_len;
-	u32 secid;
+	struct lsmblob blob;
 	struct netlbl_audit audit_info;

 	/* Don't allow users to add both IPv4 and IPv6 addresses for a
@@ -953,13 +958,15 @@ static int netlbl_unlabel_staticadddef(struct sk_buff *skb,
 	ret_val = security_secctx_to_secid(
 		                  nla_data(info->attrs[NLBL_UNLABEL_A_SECCTX]),
 				  nla_len(info->attrs[NLBL_UNLABEL_A_SECCTX]),
-				  &secid);
+				  &blob);
 	if (ret_val != 0)
 		return ret_val;

+	/* security_secctx_to_secid() will only put one secid into the lsmblob
+	 * so it's safe to use lsmblob_value() to get the secid. */
 	return netlbl_unlhsh_add(&init_net,
-				 NULL, addr, mask, addr_len, secid,
-				 &audit_info);
+				 NULL, addr, mask, addr_len,
+				 lsmblob_value(&blob), &audit_info);
 }

 /**
diff --git a/security/security.c b/security/security.c
index f3d30ef512d4..852aaa05edea 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2195,10 +2195,22 @@ int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 }
 EXPORT_SYMBOL(security_secid_to_secctx);

-int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
+int security_secctx_to_secid(const char *secdata, u32 seclen,
+			     struct lsmblob *blob)
 {
-	*secid = 0;
-	return call_int_hook(secctx_to_secid, 0, secdata, seclen, secid);
+	struct security_hook_list *hp;
+	int rc;
+
+	lsmblob_init(blob, 0);
+	hlist_for_each_entry(hp, &security_hook_heads.secctx_to_secid, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		rc = hp->hook.secctx_to_secid(secdata, seclen,
+					      &blob->secid[hp->lsmid->slot]);
+		if (rc != 0)
+			return rc;
+	}
+	return 0;
 }
 EXPORT_SYMBOL(security_secctx_to_secid);

@@ -2349,10 +2361,26 @@ int security_socket_getpeersec_stream(struct socket *sock, char __user *optval,
 				optval, optlen, len);
 }

-int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)
+int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb,
+				     u32 *secid)
 {
-	return call_int_hook(socket_getpeersec_dgram, -ENOPROTOOPT, sock,
-			     skb, secid);
+	struct security_hook_list *hp;
+	int rc = -ENOPROTOOPT;
+
+	/*
+	 * Only one security module should provide a real hook for
+	 * this. A stub or bypass like is used in BPF should either
+	 * (somehow) leave rc unaltered or return -ENOPROTOOPT.
+	 */
+	hlist_for_each_entry(hp, &security_hook_heads.socket_getpeersec_dgram,
+			     list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		rc = hp->hook.socket_getpeersec_dgram(sock, skb, secid);
+		if (rc != -ENOPROTOOPT)
+			break;
+	}
+	return rc;
 }
 EXPORT_SYMBOL(security_socket_getpeersec_dgram);

--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id D229CC433FE
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:53:44 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S238529AbhKXB4u (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:56:50 -0500
Received: from sonic302-26.consmr.mail.ne1.yahoo.com ([66.163.186.152]:44117
        "EHLO sonic302-26.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S238267AbhKXB4r (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:56:47 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718818; bh=I376tfCBPkXxTvDHbGlI/BnOlmvs91pFbxvhLdOiGlQ=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=AjXOCBWkXw6CUjCUTURYdVAil7RKM38bVxeitLnE9qmmtmOCZudjw0Wf10wPqFDVQJH/aA79hpGG5qUGaJlmTNhfNj2mu6zBgSkFZw+L9d2MDR7d8Jcy2/an0si4vdv5/LLtahYOWJpMRe7DRUMTRGMzQatlVMlN0ePkCrKwUBcnIV7Nzv5Cz0B3HKX3VcXY54N3Q/1TxlEQrZkyEFwj2H5gCSwtR5PnZBj66IkvXIU9JB6/qEK2UhSmoM1UZFtIPfMmJeKGqxxOa9pZvuxaT3AvP2AMOUJRvtMgH6xfVR+M/TjwOXPLdDK/W1YoQ6CYUakCnfP66l3+9X1cN3JjFA==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718818; bh=8CAvlH9pIrN6tqkD9y7eT9tFVoz9BLn1XbiHj8eX2H3=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=mUrGlhEsDopGb+P4lqS65/Nz1GHd6DLBv4ta7WtVxtsO2cOAKUWV8Y5fgurk9aJujkU1WlQ+GsVzESMH+QJsCbVgfn/aTVy/sRfex2drrlcxQfNzw8xW+KbvoSAwJPhu2A+SzeEEiDgoheCRMmuCeMuGJqvmGEuvubRjLwq5C5CNC3rHyaONOWc8XldvcIgv6/48rp1bnzPN16Ios0mrKIl2wFxJsAz2wOiONHIfsnqahOirJdWJZ5zUcyfHZ5PhszmJ+QBdw2vJFZ1eINWj8UHgru8G9HlgK/a5VuLR6pAS16WsYPvLMUJ4hltn/9d4OuZxcSywA4cCvkz79txTmw==
X-YMail-OSG: NYPF2AkVM1k1W5ux.zWrfTFzj3P0lJanIwrEITwdBb4n0.pjk629gYDTGwNlLns
 xMs6rIqCcYIioN4le0pdacI.kqcd6dV2OXEeYsALhscubLp3X5dRVkZEnnaHtCSd_JMMgbCbP9S5
 CQEggojcVlmY37C50W87NDeK9vk9qEV5LZ_HgK5Da2rNCXDekG3cqJlWXxCnOGfr1AvLAta.O6At
 wvRaiN2edYmo3FMcG6d2tNKkkm6ZExQRY6ONL2yMjSXwLZHzog66tE9m2sL3boDgsk1sbxZ69.Pb
 _726wj8nEvh6Mq_1Qt.ZF3DjhTpDTylh6Hz6N.xWiwYMwpdDx6ljokhQybkknoDZ5T9MmXvqZx1M
 83WEYrvKzU.EXJzT15QGwCe1O3.1huK.CeW4Q6fNGid92iCRUZu.K403n24UWvRcxxEIup.vUWbS
 CxhdUGZ1uUCbQNQ2Bj8v2uTPYIcH69_VmYGvoLaa1PSe8mfUCn_ZWICn.NapkgZMXbjWKWoxMoCO
 zw_QI_1P81wQg0tBsZzr1TBu2Hdiz5cv1qwFGH5mhxkzcnUtp3ZUuQ8YhVG5ZhG7SbyNxRmgZbHh
 XVVEWTIRcCy9bgA_LUDDb9I0BVuoqOnF8FFxdbh2qx5NBmYmb9KhhzFjBWnOUYe5yAYrDoTjbUkl
 mOWJ0rqNheCQgE7MoYQFIbnt9Mo7_mPJue5p.8wCvjpT71bs3dWaATw1w944aNd5gOg60LeM7sFT
 JfWc9EzEzF9p1xuIdkRRD.WozkNQlUCuDKOowE5joKV8cmqi573yl7TpXY0Ij2blspGT7LexdfBe
 AcoHVxAhmiPZHZiMjhO0McuZ2pXk_UXyIUUXd0pFHmK6PzmqBu_jlz9C19U6MCH3tOtKU6YPR.vK
 8QsxOxL4V9Z5UnhpJLrJE7XBw3BxxcaQgWItSl99m3QsHZuhRGW55ggNAUt2FRdH1JeY2YYImLYq
 LW7TYksCVwiUzSeLPQKYxOwJHQ8lP7utpGukiQFzJN9GLCH7BRKYEi_5.pYB_XQdGEzCW8cFX4_v
 ._aJ.0Cvjzi_LlvwxVCOuxd65cxpplg.y9AYj_cWcBJU9naF_5craWZGBhBP_5OwX5jKlWgk7vR4
 S.Xfaa95N2RwLD62kE5cz5IMLP5mEMKM6srRw34qPPUWrKQo3c9dEW1w7wPcafrB0o9IEM0X2rhm
 .xxUslRRwGaA.pTNhD9vQw9teuXS3ihEyr34yYkxRZf5BCvFDZN.Hy_lZX5jHKq4nVAihGNxbjwl
 RkJ5Y4zoRVCI_0Z5OcStyPh02GYVF7LPUu4hyHqJmyqGrN08VTdZ78kpWgMV3oZSKo2BGO8XQIUl
 qApWSaErUW9DsRFrmlWKSH5WtGvuNxpoXYsljZSsQwADiitrKLaNRodqQ_EljX2M.Kw5QWhTC81l
 y9HCOcmvBENe4HD8XHvXz29DO_LnMyDKKhG.ibWDxbOj_cs8K4RTMIEi_GxOwxt___jdprImgqVO
 1sURB25rqiVv0Ae_agCFDU6iZScqQUY2fEdwvkQU5Uu3GltQQrS1yPIV2xj8ZntdUOaW6GTUDIAe
 i36ClUewa8MKs02CK_Af0bwHWjyvlTS7_DYsgho55IPpJ2qjZ6V.r2D98aIBlw8V0Kq0UM3PaG_B
 sFD0hVI5_n6LVcxq0lvmkFAUYTaZ5n75isxAjJd03874.n_I_rAHuA4arQMtHsxtbXhCEOR51XuU
 F6b.HH9AM_qUGmQNwjmA26XwbwTX4sacKxSKETY7_NTVKiNQ064hR284XD2np.b1cBIz5QJ5nokl
 CqkzYreupn3R8kNuPOyjREf9z2S5sUTj6BRuFzh7lwRMFJLNK.oTyv5nx3iZ8urcaQXaAZkz9Xxo
 lnbNWIE3tpIeza_e_P6gOKll1ExxKmdJAS1JPla98Nxe_0hPBKHhRsUJKCjiGWNcX3ljEHaDPCWw
 O256zp_Q2s2fMkC5meiQOJFOEKs.euFe5iPr75t2HYKm5BUxhyRNu2SIVrtkdH.JJU9DZ0q.6qeF
 S0UXOKm1k5ANE8MUfiA1NZhV2fDGt3garEpy4VJaye3.0Cjgo5EN.rfSGyPBHDzTaGl.5.ZiCmHR
 By.GKrIpIdzspYERXgL0jKOi_XoNnTf.HFzHpk2pUjDhzcN49O479U7RzALP1CboMoPA3k6mYmXa
 NuuXnHemphCTnhZfYvHS9qOFCwLOdjKiVjyKIb3AMBVpNdt4mi_JhrH76yS4CVvSc90jiWpWrkf9
 EtG3wMqOyHRtUcAzlgICD637MR_A4b9hTsNL0Q1OR_ohfuJg5XDf5fJJfLsVo4w--
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic302.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:53:38 +0000
Received: by kubenode511.mail-prod1.omega.ne1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 2f39561b52daa71f71500fd09f46c636;
          Wed, 24 Nov 2021 01:53:33 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        netdev@vger.kernel.org, netfilter-devel@vger.kernel.org
Subject: [PATCH v30 09/28] LSM: Use lsmblob in security_secid_to_secctx
Date:   Tue, 23 Nov 2021 17:43:13 -0800
Message-Id: <20211124014332.36128-10-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Change security_secid_to_secctx() to take a lsmblob as input
instead of a u32 secid. It will then call the LSM hooks
using the lsmblob element allocated for that module. The
callers have been updated as well. This allows for the
possibility that more than one module may be called upon
to translate a secid to a string, as can occur in the
audit code.

Acked-by: Paul Moore <paul@paul-moore.com>
Reviewed-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: netdev@vger.kernel.org
Cc: linux-audit@redhat.com
Cc: netfilter-devel@vger.kernel.org
To: Pablo Neira Ayuso <pablo@netfilter.org>
---
 drivers/android/binder.c                | 12 +++++++++-
 include/linux/security.h                |  5 +++--
 include/net/scm.h                       |  7 +++++-
 kernel/audit.c                          | 20 +++++++++++++++--
 kernel/auditsc.c                        | 27 ++++++++++++++++++----
 net/ipv4/ip_sockglue.c                  |  4 +++-
 net/netfilter/nf_conntrack_netlink.c    | 14 ++++++++++--
 net/netfilter/nf_conntrack_standalone.c |  4 +++-
 net/netfilter/nfnetlink_queue.c         | 11 +++++++--
 net/netlabel/netlabel_unlabeled.c       | 30 +++++++++++++++++++++----
 net/netlabel/netlabel_user.c            |  6 ++---
 security/security.c                     | 11 +++++----
 12 files changed, 122 insertions(+), 29 deletions(-)

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 49fb74196d02..01cef18f942f 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -2719,10 +2719,20 @@ static void binder_transaction(struct binder_proc *proc,

 	if (target_node && target_node->txn_security_ctx) {
 		u32 secid;
+		struct lsmblob blob;
 		size_t added_size;

 		security_cred_getsecid(proc->cred, &secid);
-		ret = security_secid_to_secctx(secid, &secctx, &secctx_sz);
+		/*
+		 * Later in this patch set security_task_getsecid() will
+		 * provide a lsmblob instead of a secid. lsmblob_init
+		 * is used to ensure that all the secids in the lsmblob
+		 * get the value returned from security_task_getsecid(),
+		 * which means that the one expected by
+		 * security_secid_to_secctx() will be set.
+		 */
+		lsmblob_init(&blob, secid);
+		ret = security_secid_to_secctx(&blob, &secctx, &secctx_sz);
 		if (ret) {
 			return_error = BR_FAILED_REPLY;
 			return_error_param = ret;
diff --git a/include/linux/security.h b/include/linux/security.h
index 65dc61067e7c..af712b61c949 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -550,7 +550,7 @@ int security_setprocattr(const char *lsm, const char *name, void *value,
 			 size_t size);
 int security_netlink_send(struct sock *sk, struct sk_buff *skb);
 int security_ismaclabel(const char *name);
-int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen);
+int security_secid_to_secctx(struct lsmblob *blob, char **secdata, u32 *seclen);
 int security_secctx_to_secid(const char *secdata, u32 seclen,
 			     struct lsmblob *blob);
 void security_release_secctx(char *secdata, u32 seclen);
@@ -1406,7 +1406,8 @@ static inline int security_ismaclabel(const char *name)
 	return 0;
 }

-static inline int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
+static inline int security_secid_to_secctx(struct lsmblob *blob,
+					   char **secdata, u32 *seclen)
 {
 	return -EOPNOTSUPP;
 }
diff --git a/include/net/scm.h b/include/net/scm.h
index 1ce365f4c256..23a35ff1b3f2 100644
--- a/include/net/scm.h
+++ b/include/net/scm.h
@@ -92,12 +92,17 @@ static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
 #ifdef CONFIG_SECURITY_NETWORK
 static inline void scm_passec(struct socket *sock, struct msghdr *msg, struct scm_cookie *scm)
 {
+	struct lsmblob lb;
 	char *secdata;
 	u32 seclen;
 	int err;

 	if (test_bit(SOCK_PASSSEC, &sock->flags)) {
-		err = security_secid_to_secctx(scm->secid, &secdata, &seclen);
+		/* There can only be one security module using the secid,
+		 * and the infrastructure will know which it is.
+		 */
+		lsmblob_init(&lb, scm->secid);
+		err = security_secid_to_secctx(&lb, &secdata, &seclen);

 		if (!err) {
 			put_cmsg(msg, SOL_SOCKET, SCM_SECURITY, seclen, secdata);
diff --git a/kernel/audit.c b/kernel/audit.c
index 121d37e700a6..22286163e93e 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -1442,7 +1442,16 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	case AUDIT_SIGNAL_INFO:
 		len = 0;
 		if (audit_sig_sid) {
-			err = security_secid_to_secctx(audit_sig_sid, &ctx, &len);
+			struct lsmblob blob;
+
+			/*
+			 * lsmblob_init sets all values in the lsmblob
+			 * to audit_sig_sid. This is temporary until
+			 * audit_sig_sid is converted to a lsmblob, which
+			 * happens later in this patch set.
+			 */
+			lsmblob_init(&blob, audit_sig_sid);
+			err = security_secid_to_secctx(&blob, &ctx, &len);
 			if (err)
 				return err;
 		}
@@ -2131,12 +2140,19 @@ int audit_log_task_context(struct audit_buffer *ab)
 	unsigned len;
 	int error;
 	u32 sid;
+	struct lsmblob blob;

 	security_task_getsecid_subj(current, &sid);
 	if (!sid)
 		return 0;

-	error = security_secid_to_secctx(sid, &ctx, &len);
+	/*
+	 * lsmblob_init sets all values in the lsmblob to sid.
+	 * This is temporary until security_task_getsecid is converted
+	 * to use a lsmblob, which happens later in this patch set.
+	 */
+	lsmblob_init(&blob, sid);
+	error = security_secid_to_secctx(&blob, &ctx, &len);
 	if (error) {
 		if (error != -EINVAL)
 			goto error_path;
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index de22e852373a..fccd4571db5a 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -670,6 +670,13 @@ static int audit_filter_rules(struct task_struct *tsk,
 					security_task_getsecid_subj(tsk, &sid);
 					need_sid = 0;
 				}
+				/*
+				 * lsmblob_init sets all values in the lsmblob
+				 * to sid. This is temporary until
+				 * security_task_getsecid() is converted to
+				 * provide a lsmblob, which happens later in
+				 * this patch set.
+				 */
 				lsmblob_init(&blob, sid);
 				result = security_audit_rule_match(&blob,
 							f->type, f->op,
@@ -686,6 +693,13 @@ static int audit_filter_rules(struct task_struct *tsk,
 			if (f->lsm_isset) {
 				/* Find files that match */
 				if (name) {
+					/*
+					 * lsmblob_init sets all values in the
+					 * lsmblob to sid. This is temporary
+					 * until name->osid is converted to a
+					 * lsmblob, which happens later in
+					 * this patch set.
+					 */
 					lsmblob_init(&blob, name->osid);
 					result = security_audit_rule_match(
 								&blob,
@@ -1109,6 +1123,7 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 	char *ctx = NULL;
 	u32 len;
 	int rc = 0;
+	struct lsmblob blob;

 	ab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);
 	if (!ab)
@@ -1118,7 +1133,8 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 			 from_kuid(&init_user_ns, auid),
 			 from_kuid(&init_user_ns, uid), sessionid);
 	if (sid) {
-		if (security_secid_to_secctx(sid, &ctx, &len)) {
+		lsmblob_init(&blob, sid);
+		if (security_secid_to_secctx(&blob, &ctx, &len)) {
 			audit_log_format(ab, " obj=(none)");
 			rc = 1;
 		} else {
@@ -1362,8 +1378,10 @@ static void show_special(struct audit_context *context, int *call_panic)
 		if (osid) {
 			char *ctx = NULL;
 			u32 len;
+			struct lsmblob blob;

-			if (security_secid_to_secctx(osid, &ctx, &len)) {
+			lsmblob_init(&blob, osid);
+			if (security_secid_to_secctx(&blob, &ctx, &len)) {
 				audit_log_format(ab, " osid=%u", osid);
 				*call_panic = 1;
 			} else {
@@ -1524,9 +1542,10 @@ static void audit_log_name(struct audit_context *context, struct audit_names *n,
 	if (n->osid != 0) {
 		char *ctx = NULL;
 		u32 len;
+		struct lsmblob blob;

-		if (security_secid_to_secctx(
-			n->osid, &ctx, &len)) {
+		lsmblob_init(&blob, n->osid);
+		if (security_secid_to_secctx(&blob, &ctx, &len)) {
 			audit_log_format(ab, " osid=%u", n->osid);
 			if (call_panic)
 				*call_panic = 2;
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 38d29b175ca6..be7073df19a5 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -130,6 +130,7 @@ static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,

 static void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)
 {
+	struct lsmblob lb;
 	char *secdata;
 	u32 seclen, secid;
 	int err;
@@ -138,7 +139,8 @@ static void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)
 	if (err)
 		return;

-	err = security_secid_to_secctx(secid, &secdata, &seclen);
+	lsmblob_init(&lb, secid);
+	err = security_secid_to_secctx(&lb, &secdata, &seclen);
 	if (err)
 		return;

diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
index f1e5443fe7c7..daf554915e07 100644
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -341,8 +341,13 @@ static int ctnetlink_dump_secctx(struct sk_buff *skb, const struct nf_conn *ct)
 	struct nlattr *nest_secctx;
 	int len, ret;
 	char *secctx;
+	struct lsmblob blob;

-	ret = security_secid_to_secctx(ct->secmark, &secctx, &len);
+	/* lsmblob_init() puts ct->secmark into all of the secids in blob.
+	 * security_secid_to_secctx() will know which security module
+	 * to use to create the secctx.  */
+	lsmblob_init(&blob, ct->secmark);
+	ret = security_secid_to_secctx(&blob, &secctx, &len);
 	if (ret)
 		return 0;

@@ -650,8 +655,13 @@ static inline int ctnetlink_secctx_size(const struct nf_conn *ct)
 {
 #ifdef CONFIG_NF_CONNTRACK_SECMARK
 	int len, ret;
+	struct lsmblob blob;

-	ret = security_secid_to_secctx(ct->secmark, NULL, &len);
+	/* lsmblob_init() puts ct->secmark into all of the secids in blob.
+	 * security_secid_to_secctx() will know which security module
+	 * to use to create the secctx.  */
+	lsmblob_init(&blob, ct->secmark);
+	ret = security_secid_to_secctx(&blob, NULL, &len);
 	if (ret)
 		return 0;

diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index 80f675d884b2..79c280d1efce 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -178,8 +178,10 @@ static void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)
 	int ret;
 	u32 len;
 	char *secctx;
+	struct lsmblob blob;

-	ret = security_secid_to_secctx(ct->secmark, &secctx, &len);
+	lsmblob_init(&blob, ct->secmark);
+	ret = security_secid_to_secctx(&blob, &secctx, &len);
 	if (ret)
 		return;

diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c
index 4acc4b8e9fe5..62c0c5b847c6 100644
--- a/net/netfilter/nfnetlink_queue.c
+++ b/net/netfilter/nfnetlink_queue.c
@@ -305,13 +305,20 @@ static u32 nfqnl_get_sk_secctx(struct sk_buff *skb, char **secdata)
 {
 	u32 seclen = 0;
 #if IS_ENABLED(CONFIG_NETWORK_SECMARK)
+	struct lsmblob blob;
+
 	if (!skb || !sk_fullsock(skb->sk))
 		return 0;

 	read_lock_bh(&skb->sk->sk_callback_lock);

-	if (skb->secmark)
-		security_secid_to_secctx(skb->secmark, secdata, &seclen);
+	if (skb->secmark) {
+		/* lsmblob_init() puts ct->secmark into all of the secids in
+		 * blob. security_secid_to_secctx() will know which security
+		 * module to use to create the secctx.  */
+		lsmblob_init(&blob, skb->secmark);
+		security_secid_to_secctx(&blob, secdata, &seclen);
+	}

 	read_unlock_bh(&skb->sk->sk_callback_lock);
 #endif
diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 762561318d78..51cb4fce5edf 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -376,6 +376,7 @@ int netlbl_unlhsh_add(struct net *net,
 	struct audit_buffer *audit_buf = NULL;
 	char *secctx = NULL;
 	u32 secctx_len;
+	struct lsmblob blob;

 	if (addr_len != sizeof(struct in_addr) &&
 	    addr_len != sizeof(struct in6_addr))
@@ -438,7 +439,11 @@ int netlbl_unlhsh_add(struct net *net,
 unlhsh_add_return:
 	rcu_read_unlock();
 	if (audit_buf != NULL) {
-		if (security_secid_to_secctx(secid,
+		/* lsmblob_init() puts secid into all of the secids in blob.
+		 * security_secid_to_secctx() will know which security module
+		 * to use to create the secctx.  */
+		lsmblob_init(&blob, secid);
+		if (security_secid_to_secctx(&blob,
 					     &secctx,
 					     &secctx_len) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s", secctx);
@@ -475,6 +480,7 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 	struct net_device *dev;
 	char *secctx;
 	u32 secctx_len;
+	struct lsmblob blob;

 	spin_lock(&netlbl_unlhsh_lock);
 	list_entry = netlbl_af4list_remove(addr->s_addr, mask->s_addr,
@@ -493,8 +499,13 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 					  (dev != NULL ? dev->name : NULL),
 					  addr->s_addr, mask->s_addr);
 		dev_put(dev);
+		/* lsmblob_init() puts entry->secid into all of the secids
+		 * in blob. security_secid_to_secctx() will know which
+		 * security module to use to create the secctx.  */
+		if (entry != NULL)
+			lsmblob_init(&blob, entry->secid);
 		if (entry != NULL &&
-		    security_secid_to_secctx(entry->secid,
+		    security_secid_to_secctx(&blob,
 					     &secctx, &secctx_len) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s", secctx);
 			security_release_secctx(secctx, secctx_len);
@@ -536,6 +547,7 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 	struct net_device *dev;
 	char *secctx;
 	u32 secctx_len;
+	struct lsmblob blob;

 	spin_lock(&netlbl_unlhsh_lock);
 	list_entry = netlbl_af6list_remove(addr, mask, &iface->addr6_list);
@@ -553,8 +565,13 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 					  (dev != NULL ? dev->name : NULL),
 					  addr, mask);
 		dev_put(dev);
+		/* lsmblob_init() puts entry->secid into all of the secids
+		 * in blob. security_secid_to_secctx() will know which
+		 * security module to use to create the secctx.  */
+		if (entry != NULL)
+			lsmblob_init(&blob, entry->secid);
 		if (entry != NULL &&
-		    security_secid_to_secctx(entry->secid,
+		    security_secid_to_secctx(&blob,
 					     &secctx, &secctx_len) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s", secctx);
 			security_release_secctx(secctx, secctx_len);
@@ -1080,6 +1097,7 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 	u32 secid;
 	char *secctx;
 	u32 secctx_len;
+	struct lsmblob blob;

 	data = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).portid,
 			   cb_arg->seq, &netlbl_unlabel_gnl_family,
@@ -1134,7 +1152,11 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 		secid = addr6->secid;
 	}

-	ret_val = security_secid_to_secctx(secid, &secctx, &secctx_len);
+	/* lsmblob_init() secid into all of the secids in blob.
+	 * security_secid_to_secctx() will know which security module
+	 * to use to create the secctx.  */
+	lsmblob_init(&blob, secid);
+	ret_val = security_secid_to_secctx(&blob, &secctx, &secctx_len);
 	if (ret_val != 0)
 		goto list_cb_failure;
 	ret_val = nla_put(cb_arg->skb,
diff --git a/net/netlabel/netlabel_user.c b/net/netlabel/netlabel_user.c
index 3ed4fea2a2de..893301ae0131 100644
--- a/net/netlabel/netlabel_user.c
+++ b/net/netlabel/netlabel_user.c
@@ -86,6 +86,7 @@ struct audit_buffer *netlbl_audit_start_common(int type,
 	struct audit_buffer *audit_buf;
 	char *secctx;
 	u32 secctx_len;
+	struct lsmblob blob;

 	if (audit_enabled == AUDIT_OFF)
 		return NULL;
@@ -98,10 +99,9 @@ struct audit_buffer *netlbl_audit_start_common(int type,
 			 from_kuid(&init_user_ns, audit_info->loginuid),
 			 audit_info->sessionid);

+	lsmblob_init(&blob, audit_info->secid);
 	if (audit_info->secid != 0 &&
-	    security_secid_to_secctx(audit_info->secid,
-				     &secctx,
-				     &secctx_len) == 0) {
+	    security_secid_to_secctx(&blob, &secctx, &secctx_len) == 0) {
 		audit_log_format(audit_buf, " subj=%s", secctx);
 		security_release_secctx(secctx, secctx_len);
 	}
diff --git a/security/security.c b/security/security.c
index 852aaa05edea..cd3ac0a5673e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2176,17 +2176,16 @@ int security_ismaclabel(const char *name)
 }
 EXPORT_SYMBOL(security_ismaclabel);

-int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
+int security_secid_to_secctx(struct lsmblob *blob, char **secdata, u32 *seclen)
 {
 	struct security_hook_list *hp;
 	int rc;

-	/*
-	 * Currently, only one LSM can implement secid_to_secctx (i.e this
-	 * LSM hook is not "stackable").
-	 */
 	hlist_for_each_entry(hp, &security_hook_heads.secid_to_secctx, list) {
-		rc = hp->hook.secid_to_secctx(secid, secdata, seclen);
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		rc = hp->hook.secid_to_secctx(blob->secid[hp->lsmid->slot],
+					      secdata, seclen);
 		if (rc != LSM_RET_DEFAULT(secid_to_secctx))
 			return rc;
 	}
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 1C7F1C433EF
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:55:23 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239209AbhKXB6a (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:58:30 -0500
Received: from sonic315-27.consmr.mail.ne1.yahoo.com ([66.163.190.153]:41642
        "EHLO sonic315-27.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S238713AbhKXB6W (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:58:22 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718913; bh=VLwZDb1tdKx6yw+sD0e7cZyLT/6rM6QoGaGkqwB5xxg=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=sCv7apefrtOW145ZbQt/QI6JPzQ4vFuMU5aEI4ALra39t2Zd1vjxb/RNvSrYG/vrt85thAEzD87t9qdLDlkQgBDbD0wFDF7H1Ylhg+Zaz/rUDZHKF3I6rgXEu5rJJ5LvNHoMFCXBEeix4XqFRqDv/f08bOcWb2JKjb8UDkSedpt9/hi5d84FIOWDuNe0e0ug0BWEYReEw8wxGjyoLAkWia5GuORbDhPUwAJFQUiB9ZLAJRoTMzhICuvmF5EeoGaG4eY2nNC5KgXAoUM8Z/D+O4QMdxA1taDKVB+EKRB4wuwkaIr+fJivww6VtK7V8y6jK4KP8pH62xOgJBhasE3fSA==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718913; bh=6/eosNwc54pMe1yCp5LmkoWD+kdSqc5F43imD8wswEq=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=Wc2ew20FhghwhKUtFx2ARcXPqopcUbXw3r3c1bGikKLYTfqgCBmOU96yUtdrMzfUAmA0VwSj5T3sFGoMtm6SHm7JLKtgsqz6173nhi4dasQiHeGxdvW6FRT3sS8MUNuAis+ZNZ3h2LIkpX/NNEoDpqNwmImcgLm/3HCqVNF3RsZ5QrYe3ElSDMfmsNeWlueQkjWl5bw5wPAidO07NH4hH8IByv4dQ1Yg0zlWe8AB7DR74vZLKusLCmZpiGm4slW/l2m3W8GyrUNpl1CMv+r+MdScj+7HmMKKAqzRxJsWLLjkY+wsW8Q6lTLzlXzi7jhgCOsZsW8vqKUf2oCEpZNwFw==
X-YMail-OSG: dykXSRQVM1my8mrgbC4dlFMY4_IgHecEOoPAWZHv9bP5Zgcj.tWnyyO9AnhzTmg
 FvpRLPtTkAznqoU7iMWXx9hsioT_SMSvHjv62Q2SJiX3gVod6UbDMe0nsdsaMcfx7bvPtcO2mHfv
 lVtrDmxrl4xM5SFwfZrVVMSnMRSiSEUlvPpioYE8RrDjNQSiIusiOEhug2QF8UyGiQATqOu6ckhO
 SH.7aIbnC9eXkYeVnijswyWHuvwQl6De_OyLxw457bNdVT4j51FjyiztGV33521IayOLvIRpDnow
 L2M.W_9QFYXSMyzobMw_kQnjOLWflJPJPTCynLqbCRXUTPve8bfHlgnNdRmaRcDNUKHQ.iZJw_Rj
 jOgw7Rl6eUGskrYJkb7Hf_JbqQtGEFu_d.KjLrUslrD5YA0G68TOho7_V4XEagrMCIs.d7zLcNMU
 5FfVGByfFm.em9RifsFoG8o199vv8uFN3dkrv0yh55Oo9tb_7VQjtn_IJMWxZX2UWqge4YOsL.6L
 C6mGnWHja1s3nY0oV.ALMzhooPmr75mAcX04ysfqYlAH_TWJvS6frDmls1oKGa8qPXAB5J7P_Izi
 K52c81OfHNmWX5b6_dR_DMhZpvBw9Lc9KYZ2iro19rrdUd4Q9N7SvLHoEZ2JcGMMzHD43NObJT9P
 1G97qBiNPyVSt1ve.MocDpLHxKaXud8I1JhiBoOk__4A1pHxI6JQLsQnVKx03eJ3lZn0IytHgqay
 t75k5sKC_IaGapQ_UD5M1c.HtQQG6X2h0bSqaSeKYYDqZW8vpU4xYg3FOyVcbPTPN6wJCmpUY.rY
 fbXEtYS6R00JnhdPFtYt8ZWEzS.l1WcG6hQtH8JMbBT18FUZM.16yET3scADxazekmjhIO0k1EH6
 80KmpGnbvEM4t6WrNc4t3TSfdoecJhMl1.DfVmabaUoOPsamvplobakYBB1swhhvApZdDjrtE4mk
 N40dklVfDcZZgmCAQIIIyarqThY.rmHYWtI35XvTtiIA9bqMpxm16SVSB94DoQeiPo2cc8ODdnNE
 difmqoaD.zyLCILYCEYukvk4G7wuorBMWFsBxe7oPy7Yztz3PMzyIL.uCdEXy71iFhB2EQhH_bRM
 6ykht3k3tYf9xpxrfYX7fz_gEGcnQarDxwlVcBVnZkgQuzhP1MldXwcmqz3GDdBIEguqQpM7ZQMt
 jjOj4tnG3p.63vcepzR_yzH9UKoVfn_DSA1NYOS1dSB8jZJDjflacCt4qc_x1k2TtsaDJ5l8RfZ7
 DAtHqei6sSiZ8ijBXAR3tNKm6qCkVlbMHC.6vAJBa2GZDoWix2RmjJGuuhAtIy9l665dqBd6q2J4
 6Y4YLwvmv4KyuG0MrOclq74fHMs6Bu4mnAam5Ia.OaF8IOB3I07NfeLTGMOPcESa5OQwVkBFPenK
 D6qonmj6qwD5MgCytKlIh4QAoj4nauW_swJLAYJuAUqhVIQV6h57y40L2bo7Avu6YNoRENZHL9eO
 2xn_qwgk4dVACckFw4.wBUkZhTNCh4YOwtXxqEyUmlVYTR7e.cjBX8BH1QYgWsYryVEXq_t83sjk
 mvmKw0xCTk9TJhd_F.HrcA.DF7sBEpEPVJDz09eEvSGXAaX3WyIOLIHggLgnxmfxns9v0UsJk1rq
 vrKRtBLm9fbyhJeHFxFYF2jru3leK_eKhq5H71IUCCUxdJio6bUMQ1f6BSAl0cMu1e.OMVuMjJT.
 R1z6EZ53Rb.zbsIutp416VjN26sS3zFC4jLM8YdOcNOTg5W7gaBoqcVC2.RfcAmexd0Qobh6mi_M
 xbnS4ZRCZueMbbmUlVQpZg7TGJa4C4B1vcmdx3KnKSVS74Keo213dJXopuY0yJ8.TDmGoYUklbwJ
 DOnFs5VGE6U2UjQPYMl0j8ViqKjB6Cqbsge2CdGQn7J1prm._AUhzOpw.2U_JYs.KpTGlhGbUf2p
 qhKxErefKHyYcHQpHML5KQLTQ2Q7vXBtdZrgXy6HwsjYw5MbJsXxFDhGFDFuibQRiKKMJ7ewHfu0
 h.KZ_1hLa6bb3s.XUQvt68j7QobTpOzTxbA.cm.9Br2GjWSflqv1kRKCxvaofN3S0Q6p2KT0N0j9
 62AeNF.2Z1Rq_B_KBDq88bWQLC_ECJ3ISPF31ogCaXxElfTkid_5sEq3it1a4jrnOAJt6VgIqmb5
 hyG2yBZctrbwEmXylwVUbYOJbGG4kYJzKe42QJ.FYGfHocCN9V.K69GfIoEjsxjjhvpEwg2J1FL2
 QiwiJ3wfMi2ZYsy4JcjYjObowVnFlzswadZrTnGg-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic315.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:55:13 +0000
Received: by kubenode502.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID b96e5df6817e2f1cb8c030c23d93dbaf;
          Wed, 24 Nov 2021 01:54:39 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>
Subject: [PATCH v30 10/28] LSM: Use lsmblob in security_ipc_getsecid
Date:   Tue, 23 Nov 2021 17:43:14 -0800
Message-Id: <20211124014332.36128-11-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

There may be more than one LSM that provides IPC data
for auditing. Change security_ipc_getsecid() to fill in
a lsmblob structure instead of the u32 secid. The
audit data structure containing the secid will be updated
later, so there is a bit of scaffolding here.

Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: linux-audit@redhat.com
---
 include/linux/security.h |  7 ++++---
 kernel/auditsc.c         |  7 ++++++-
 security/security.c      | 12 +++++++++---
 3 files changed, 19 insertions(+), 7 deletions(-)

diff --git a/include/linux/security.h b/include/linux/security.h
index af712b61c949..42c99237786b 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -521,7 +521,7 @@ int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 			unsigned long arg4, unsigned long arg5);
 void security_task_to_inode(struct task_struct *p, struct inode *inode);
 int security_ipc_permission(struct kern_ipc_perm *ipcp, short flag);
-void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid);
+void security_ipc_getsecid(struct kern_ipc_perm *ipcp, struct lsmblob *blob);
 int security_msg_msg_alloc(struct msg_msg *msg);
 void security_msg_msg_free(struct msg_msg *msg);
 int security_msg_queue_alloc(struct kern_ipc_perm *msq);
@@ -1284,9 +1284,10 @@ static inline int security_ipc_permission(struct kern_ipc_perm *ipcp,
 	return 0;
 }

-static inline void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
+static inline void security_ipc_getsecid(struct kern_ipc_perm *ipcp,
+					 struct lsmblob *blob)
 {
-	*secid = 0;
+	lsmblob_init(blob, 0);
 }

 static inline int security_msg_msg_alloc(struct msg_msg *msg)
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index fccd4571db5a..bba31349ae3e 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -2601,12 +2601,17 @@ void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 void __audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
 	struct audit_context *context = audit_context();
+	struct lsmblob blob;

 	context->ipc.uid = ipcp->uid;
 	context->ipc.gid = ipcp->gid;
 	context->ipc.mode = ipcp->mode;
 	context->ipc.has_perm = 0;
-	security_ipc_getsecid(ipcp, &context->ipc.osid);
+	security_ipc_getsecid(ipcp, &blob);
+	/* context->ipc.osid will be changed to a lsmblob later in
+	 * the patch series. This will allow auditing of all the object
+	 * labels associated with the ipc object. */
+	context->ipc.osid = lsmblob_value(&blob);
 	context->type = AUDIT_IPC;
 }

diff --git a/security/security.c b/security/security.c
index cd3ac0a5673e..2e74e5e88d64 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1996,10 +1996,16 @@ int security_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
 	return call_int_hook(ipc_permission, 0, ipcp, flag);
 }

-void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
+void security_ipc_getsecid(struct kern_ipc_perm *ipcp, struct lsmblob *blob)
 {
-	*secid = 0;
-	call_void_hook(ipc_getsecid, ipcp, secid);
+	struct security_hook_list *hp;
+
+	lsmblob_init(blob, 0);
+	hlist_for_each_entry(hp, &security_hook_heads.ipc_getsecid, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		hp->hook.ipc_getsecid(ipcp, &blob->secid[hp->lsmid->slot]);
+	}
 }

 int security_msg_msg_alloc(struct msg_msg *msg)
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 19147C43217
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:55:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239230AbhKXB7E (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 20:59:04 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:37988
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S238822AbhKXB67 (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 20:58:59 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718950; bh=7MiUFyCmfkC//4vnaYq/YKc6j4ocqCWB/2RMJPU3nwo=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=hsq3iHIWoxu3jFteNF1W4lpWvr9tmc1iU2bntRgRLcJSJaDWA8+fLt0tHUzvht37ZlPjHBlJUCo6nHjiPHl1gxpRLmK3ANasBQ0tBUM7xBakuZytoDNlmrvzY76Cr/S+EKvkGRyAvegC+E+MIec1YUFk/soYaP9TDmmVSppCy7vThBjiduZMfwrcqVfzp8jXiybHyr9ruGEuDMxfX+kGfBCHkHMtOgxPhasy4bc+TddvDPfoNb4c+4kMAD8T1axBo/kYqCTwu3JJ+ZoyPvlCrTHcgCYcYmpoMwf2M0Dj/yE1d4IUAyxkYu9COZTNtTnWUJi+PZhJyA82SsWwNHkPuA==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637718950; bh=xbeUysdvsbQ7KdjsehGv4BIwjhXQtvkgXbFDYAs9GnJ=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=S/gDAKqftZ+iR+HnqFPnYSj2E7lOruCEMKInEGGxIexX2zHaRNJ7ddIwbJGH9ZvoaBwhJoZlPR/+cYx31QVBj6RbzFaEOAhqzP010cSAnakRCEk6MF7F0g2zy3wwGYJFqBCl7QkfNSjFnNTVYeGfAKKt2jAZqdjqn4vAhs4gifes86DPXZUkw5uRG/QkSgcJEPNqTowVI+eUsl4Z9U4jM8AZJDG5oIaCxirYX8oumnH97N22ZtL+zrA69/x8pRqSG8fyrgKOVSlse+oz1sMLF7SZgOfex7GhsVvRyY0w6sgOz00Q5HfDiwf21q3zoZ3nYH60Ybgbe6cOYnbC5iRDKw==
X-YMail-OSG: .NGEq8kVM1m5ea_5_RdkZfniA4gsr5x8kx74xZIAgxiCDKsjrfkfMErTj4fjY9F
 kE99kkOe1los1G1bHmubDnVXdBVolkcHmXmc3SYTtO1W11ZPSIEbE8uUBAOilmRGvh10DEYEk4Zr
 62OHDb6wbze3ouU5cBQ6dwxeEcNSsh.Cv.CsZ_PFxvykto0L3tUO9MILZQRN_wJurEoRfeqm7Xr0
 7M3ilEeUt1dzNGmJv7qsTaK.fbsR7q58QK5xLBLuTmcfTnr6ahiWauUK0h7vJJFPjVVOiQLiANA1
 Ge..WshoaKw5Q3u1ucjJZ_xkWoEdQcbZBRZkj5_xN38GIM70iuQYgEHVyNBhLIqoI.cihQF8n7Px
 RTq.lWDGg5MP7MTTQqieDlkrvh7MOI6U14rOzC9L3.HJgLCRNgK8velXPwlxV8ZPMB7pKnXFeI6D
 l5tcXC7_IYGlQg_zhuhRuYDD3bdJYTJ.M77UXPx2bIIRxYnieallVmlybuEuEklxiR8kev92K8EP
 WggSuSyKYQyUD9sAcfWx4vvATaHOV6.zb4.yZHeT6OcWY55F55G_4EfBB0S_QgzduRuem6GPR9KE
 tkFF_NIX1FrazIG0YJPNec2J1UoAdn_49N5WyhPKAkuFxBkHbN.SYeJf7DXCxyowPcId7ZJFmpX3
 wa0DMxmr8AbY0VlJIYtR3J7mRqt.QUgwAIxM_TkhWub42ulruJl55u838Rng6_trNvvByFKdu.0r
 XotuFQVeHQus.N_z26Epz8jEzXbshrfduXQd__.ysr_CjuX.m0HLskdt_2uzxB6PrYNA2PnZMOAT
 4GN9oDqLtr42d20Wk_eBwhDLcXI03BEWHajw.M4.8i70bUeYPRVyl.h3iiSgzlqRKNIjUPSuuEHZ
 8V.aEGl5YvPVVGATaLNpIFXNbOEWfOrskt.isbm0mFdS2y5Hn5BA2ys6ekF.xQ0O0Hju_Q5v8jkU
 xyhtvoN_XvUxnEH5AvByRq0eb2IcEhfVaV__elDKY4Okl41eFBRbHcPsoQuUyFK6YLIbPq_HJaZU
 T9Qk9Acrj_vpKNOVAo9XcDKaTUcszVFHs9vsGH77vXy32ebzduPsxn4Ltv2FN7qgXOT4fRW9DVsm
 6IAkIA0XD.saWSddrql59gPGnADHdjNsCW7DHf4z.izhM_ZTbkN0V_tobgZmJRnstHs0XGggKNro
 ciakCKS0GXcJ27drxX3lA99aAED_vARVJbVY_mvqhoI2Az5stgtJoM4.1dTqikAZWXrYF3E6ta7.
 C8C4f6l5KRoseT8cUT.aaU3ZzSVkHim3lMmdWv3udzaOKeyccsT2MXg4WOk7HBuTn9Qt_PMnKqA2
 UzvHSqZ.h7oQnQli0yhhpZ2ob0sdkZPnKzRMdL8_7bAv5GRhIH0m59b6wm5JC89Oict0nhYhosXM
 OHmJwngQ3JWM2pQPELZ.LQwM5.5IS82m9oO1AmNfvaFs.i6qozFnGpTDKGUAFgmKBjss3GfwmChx
 ACDx5NTjA2IsrqAYZbH1CohCTeig05oFuz4T65ee1hvw0nnVJUDqGYfPE1WyX_.QDcAh1byYLw.7
 QkxKY94HsO4F2.skmVarntSfZcaL5h6GCPOFEnS_FV.ygqDWLPWa4TSnOb3SRjdrQCjj2pB95X0D
 oSXdBWcFhXgFBoyj.WjaXGKhGBAuYwiACgx2pEl_XZnI_Li_WlX02zm2sxDdggkusXssaoOtOP_a
 Y8DdqyFBYVDKSnqnheojHWVkCww4C3fSXL3RKEUJ2Kg5bob3EH9wu21PYpOB0Y5SjuHkFDtv.EpK
 P6WWrSVxcAdT0DVFuv96cIvxudRrWnxDcA7pWUHWpaFGElDgdpwzilKloWGx09wIkapkCUFDa.Mk
 25moOhK1.Jp4TsRUEU.cu8KnE9sQOeMmGa4mWlOMV3fDf2kbjmXqOQnkAw6klF3S9ZNr87aG7ypv
 vXDebwH5kvl94vuMz_eNZXl5U5KUKkT4.D3158E.zm9GRx_CVG91xnep0Ymxe8pR163njWjr_igE
 ie.xYTOyq4yHAbSYETDumuUybuV_nqnx3ZD8s78Wc43EB4TfZ63SbNTw.6rb9puWp5EjPUhFTkeO
 _040hgJRzYsswmtt_C75kZN00JFvriCLAA8Xwrm25CUnJU0G8YKYgebA.piVjA0vnTRJTxsGurwv
 UY5HWkk_uQANd380sRMBoDqad71Q6QSnrZ2q.5_H37.FEmU2_hrMNLz1g4ew26Q4YMyVMcyV_AT.
 94JpEcBDB48bNSOvhlr7OkW4HzaJrTj6eigiBLAxhhq31Q5bCbdA_Z1LFficGBXmrhstjmhrt2zu
 NQtGDXZedzds4156_lDVVYMba868quF8hREw0k3_ams5j
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:55:50 +0000
Received: by kubenode511.mail-prod1.omega.ne1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 642dde53d69d58293143a094a618e31b;
          Wed, 24 Nov 2021 01:55:45 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>,
        linux-integrity@vger.kernel.org, netdev@vger.kernel.org
Subject: [PATCH v30 11/28] LSM: Use lsmblob in security_task_getsecid
Date:   Tue, 23 Nov 2021 17:43:15 -0800
Message-Id: <20211124014332.36128-12-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Change the security_task_getsecid_subj() and
security_task_getsecid_obj() interfaces to fill in
a lsmblob structure instead of a u32 secid in support of
LSM stacking. Audit interfaces will need to collect all
possible secids for possible reporting.

Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: linux-integrity@vger.kernel.org
Cc: linux-audit@redhat.com
Cc: netdev@vger.kernel.org
---
 drivers/android/binder.c              |  6 +--
 include/linux/security.h              | 14 ++++---
 kernel/audit.c                        | 16 +++-----
 kernel/auditfilter.c                  |  4 +-
 kernel/auditsc.c                      | 25 ++++++------
 net/netlabel/netlabel_unlabeled.c     |  5 ++-
 net/netlabel/netlabel_user.h          |  6 ++-
 security/integrity/ima/ima_appraise.c | 12 +++---
 security/integrity/ima/ima_main.c     | 55 +++++++++++++++------------
 security/security.c                   | 25 +++++++++---
 10 files changed, 96 insertions(+), 72 deletions(-)

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 01cef18f942f..780c7e265f3a 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -2718,16 +2718,16 @@ static void binder_transaction(struct binder_proc *proc,
 	t->priority = task_nice(current);

 	if (target_node && target_node->txn_security_ctx) {
-		u32 secid;
 		struct lsmblob blob;
 		size_t added_size;
+		u32 secid;

 		security_cred_getsecid(proc->cred, &secid);
 		/*
-		 * Later in this patch set security_task_getsecid() will
+		 * Later in this patch set security_cred_getsecid() will
 		 * provide a lsmblob instead of a secid. lsmblob_init
 		 * is used to ensure that all the secids in the lsmblob
-		 * get the value returned from security_task_getsecid(),
+		 * get the value returned from security_cred_getsecid(),
 		 * which means that the one expected by
 		 * security_secid_to_secctx() will be set.
 		 */
diff --git a/include/linux/security.h b/include/linux/security.h
index 42c99237786b..efd6e88d57b1 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -503,8 +503,8 @@ int security_task_fix_setgid(struct cred *new, const struct cred *old,
 int security_task_setpgid(struct task_struct *p, pid_t pgid);
 int security_task_getpgid(struct task_struct *p);
 int security_task_getsid(struct task_struct *p);
-void security_task_getsecid_subj(struct task_struct *p, u32 *secid);
-void security_task_getsecid_obj(struct task_struct *p, u32 *secid);
+void security_task_getsecid_subj(struct task_struct *p, struct lsmblob *blob);
+void security_task_getsecid_obj(struct task_struct *p, struct lsmblob *blob);
 int security_task_setnice(struct task_struct *p, int nice);
 int security_task_setioprio(struct task_struct *p, int ioprio);
 int security_task_getioprio(struct task_struct *p);
@@ -1206,14 +1206,16 @@ static inline int security_task_getsid(struct task_struct *p)
 	return 0;
 }

-static inline void security_task_getsecid_subj(struct task_struct *p, u32 *secid)
+static inline void security_task_getsecid_subj(struct task_struct *p,
+					       struct lsmblob *blob)
 {
-	*secid = 0;
+	lsmblob_init(blob, 0);
 }

-static inline void security_task_getsecid_obj(struct task_struct *p, u32 *secid)
+static inline void security_task_getsecid_obj(struct task_struct *p,
+					      struct lsmblob *blob)
 {
-	*secid = 0;
+	lsmblob_init(blob, 0);
 }

 static inline int security_task_setnice(struct task_struct *p, int nice)
diff --git a/kernel/audit.c b/kernel/audit.c
index 22286163e93e..d92c7b894183 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -2139,19 +2139,12 @@ int audit_log_task_context(struct audit_buffer *ab)
 	char *ctx = NULL;
 	unsigned len;
 	int error;
-	u32 sid;
 	struct lsmblob blob;

-	security_task_getsecid_subj(current, &sid);
-	if (!sid)
+	security_task_getsecid_subj(current, &blob);
+	if (!lsmblob_is_set(&blob))
 		return 0;

-	/*
-	 * lsmblob_init sets all values in the lsmblob to sid.
-	 * This is temporary until security_task_getsecid is converted
-	 * to use a lsmblob, which happens later in this patch set.
-	 */
-	lsmblob_init(&blob, sid);
 	error = security_secid_to_secctx(&blob, &ctx, &len);
 	if (error) {
 		if (error != -EINVAL)
@@ -2359,6 +2352,7 @@ int audit_set_loginuid(kuid_t loginuid)
 int audit_signal_info(int sig, struct task_struct *t)
 {
 	kuid_t uid = current_uid(), auid;
+	struct lsmblob blob;

 	if (auditd_test_task(t) &&
 	    (sig == SIGTERM || sig == SIGHUP ||
@@ -2369,7 +2363,9 @@ int audit_signal_info(int sig, struct task_struct *t)
 			audit_sig_uid = auid;
 		else
 			audit_sig_uid = uid;
-		security_task_getsecid_subj(current, &audit_sig_sid);
+		security_task_getsecid_subj(current, &blob);
+		/* scaffolding until audit_sig_sid is converted */
+		audit_sig_sid = blob.secid[0];
 	}

 	return audit_signal_info_syscall(t);
diff --git a/kernel/auditfilter.c b/kernel/auditfilter.c
index ffbd8396bdc9..de165c2cd55f 100644
--- a/kernel/auditfilter.c
+++ b/kernel/auditfilter.c
@@ -1340,7 +1340,6 @@ int audit_filter(int msgtype, unsigned int listtype)
 			struct audit_field *f = &e->rule.fields[i];
 			struct lsmblob blob;
 			pid_t pid;
-			u32 sid;

 			switch (f->type) {
 			case AUDIT_PID:
@@ -1371,8 +1370,7 @@ int audit_filter(int msgtype, unsigned int listtype)
 			case AUDIT_SUBJ_CLR:
 				if (f->lsm_isset) {
 					security_task_getsecid_subj(current,
-								    &sid);
-					lsmblob_init(&blob, sid);
+								    &blob);
 					result = security_audit_rule_match(
 						   &blob, f->type, f->op,
 						   &f->lsm_rules);
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index bba31349ae3e..7cd70a43408f 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -467,7 +467,6 @@ static int audit_filter_rules(struct task_struct *tsk,
 {
 	const struct cred *cred;
 	int i, need_sid = 1;
-	u32 sid;
 	struct lsmblob blob;
 	unsigned int sessionid;

@@ -667,17 +666,9 @@ static int audit_filter_rules(struct task_struct *tsk,
 			   logged upon error */
 			if (f->lsm_isset) {
 				if (need_sid) {
-					security_task_getsecid_subj(tsk, &sid);
+					security_task_getsecid_subj(tsk, &blob);
 					need_sid = 0;
 				}
-				/*
-				 * lsmblob_init sets all values in the lsmblob
-				 * to sid. This is temporary until
-				 * security_task_getsecid() is converted to
-				 * provide a lsmblob, which happens later in
-				 * this patch set.
-				 */
-				lsmblob_init(&blob, sid);
 				result = security_audit_rule_match(&blob,
 							f->type, f->op,
 							&f->lsm_rules);
@@ -2703,12 +2694,15 @@ int __audit_sockaddr(int len, void *a)
 void __audit_ptrace(struct task_struct *t)
 {
 	struct audit_context *context = audit_context();
+	struct lsmblob blob;

 	context->target_pid = task_tgid_nr(t);
 	context->target_auid = audit_get_loginuid(t);
 	context->target_uid = task_uid(t);
 	context->target_sessionid = audit_get_sessionid(t);
-	security_task_getsecid_obj(t, &context->target_sid);
+	security_task_getsecid_obj(t, &blob);
+	/* scaffolding - until target_sid is converted */
+	context->target_sid = blob.secid[0];
 	memcpy(context->target_comm, t->comm, TASK_COMM_LEN);
 }

@@ -2724,6 +2718,7 @@ int audit_signal_info_syscall(struct task_struct *t)
 	struct audit_aux_data_pids *axp;
 	struct audit_context *ctx = audit_context();
 	kuid_t t_uid = task_uid(t);
+	struct lsmblob blob;

 	if (!audit_signals || audit_dummy_context())
 		return 0;
@@ -2735,7 +2730,9 @@ int audit_signal_info_syscall(struct task_struct *t)
 		ctx->target_auid = audit_get_loginuid(t);
 		ctx->target_uid = t_uid;
 		ctx->target_sessionid = audit_get_sessionid(t);
-		security_task_getsecid_obj(t, &ctx->target_sid);
+		security_task_getsecid_obj(t, &blob);
+		/* scaffolding until target_sid is converted */
+		ctx->target_sid = blob.secid[0];
 		memcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);
 		return 0;
 	}
@@ -2756,7 +2753,9 @@ int audit_signal_info_syscall(struct task_struct *t)
 	axp->target_auid[axp->pid_count] = audit_get_loginuid(t);
 	axp->target_uid[axp->pid_count] = t_uid;
 	axp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);
-	security_task_getsecid_obj(t, &axp->target_sid[axp->pid_count]);
+	security_task_getsecid_obj(t, &blob);
+	/* scaffolding until target_sid is converted */
+	axp->target_sid[axp->pid_count] = blob.secid[0];
 	memcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);
 	axp->pid_count++;

diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 51cb4fce5edf..15b53fc4e83f 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -1562,11 +1562,14 @@ int __init netlbl_unlabel_defconf(void)
 	int ret_val;
 	struct netlbl_dom_map *entry;
 	struct netlbl_audit audit_info;
+	struct lsmblob blob;

 	/* Only the kernel is allowed to call this function and the only time
 	 * it is called is at bootup before the audit subsystem is reporting
 	 * messages so don't worry to much about these values. */
-	security_task_getsecid_subj(current, &audit_info.secid);
+	security_task_getsecid_subj(current, &blob);
+	/* scaffolding until audit_info.secid is converted */
+	audit_info.secid = blob.secid[0];
 	audit_info.loginuid = GLOBAL_ROOT_UID;
 	audit_info.sessionid = 0;

diff --git a/net/netlabel/netlabel_user.h b/net/netlabel/netlabel_user.h
index 6190cbf94bf0..aa31f7bf79ee 100644
--- a/net/netlabel/netlabel_user.h
+++ b/net/netlabel/netlabel_user.h
@@ -32,7 +32,11 @@
  */
 static inline void netlbl_netlink_auditinfo(struct netlbl_audit *audit_info)
 {
-	security_task_getsecid_subj(current, &audit_info->secid);
+	struct lsmblob blob;
+
+	security_task_getsecid_subj(current, &blob);
+	/* scaffolding until secid is converted */
+	audit_info->secid = blob.secid[0];
 	audit_info->loginuid = audit_get_loginuid(current);
 	audit_info->sessionid = audit_get_sessionid(current);
 }
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index dbba51583e7c..2fedda131a39 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -71,15 +71,17 @@ bool is_ima_appraise_enabled(void)
 int ima_must_appraise(struct user_namespace *mnt_userns, struct inode *inode,
 		      int mask, enum ima_hooks func)
 {
-	u32 secid;
+	struct lsmblob blob;

 	if (!ima_appraise)
 		return 0;

-	security_task_getsecid_subj(current, &secid);
-	return ima_match_policy(mnt_userns, inode, current_cred(), secid,
-				func, mask, IMA_APPRAISE | IMA_HASH, NULL,
-				NULL, NULL, NULL);
+	security_task_getsecid_subj(current, &blob);
+	/* scaffolding the .secid[0] */
+	return ima_match_policy(mnt_userns, inode, current_cred(),
+				blob.secid[0], func, mask,
+				IMA_APPRAISE | IMA_HASH, NULL, NULL, NULL,
+				NULL);
 }

 static int ima_fix_xattr(struct dentry *dentry,
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index 465865412100..c327f93d3962 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -405,12 +405,13 @@ static int process_measurement(struct file *file, const struct cred *cred,
  */
 int ima_file_mmap(struct file *file, unsigned long prot)
 {
-	u32 secid;
+	struct lsmblob blob;

 	if (file && (prot & PROT_EXEC)) {
-		security_task_getsecid_subj(current, &secid);
-		return process_measurement(file, current_cred(), secid, NULL,
-					   0, MAY_EXEC, MMAP_CHECK);
+		security_task_getsecid_subj(current, &blob);
+		/* scaffolding - until process_measurement changes */
+		return process_measurement(file, current_cred(), blob.secid[0],
+					   NULL, 0, MAY_EXEC, MMAP_CHECK);
 	}

 	return 0;
@@ -436,9 +437,9 @@ int ima_file_mprotect(struct vm_area_struct *vma, unsigned long prot)
 	char *pathbuf = NULL;
 	const char *pathname = NULL;
 	struct inode *inode;
+	struct lsmblob blob;
 	int result = 0;
 	int action;
-	u32 secid;
 	int pcr;

 	/* Is mprotect making an mmap'ed file executable? */
@@ -446,11 +447,11 @@ int ima_file_mprotect(struct vm_area_struct *vma, unsigned long prot)
 	    !(prot & PROT_EXEC) || (vma->vm_flags & VM_EXEC))
 		return 0;

-	security_task_getsecid_subj(current, &secid);
+	security_task_getsecid_subj(current, &blob);
 	inode = file_inode(vma->vm_file);
 	action = ima_get_action(file_mnt_user_ns(vma->vm_file), inode,
-				current_cred(), secid, MAY_EXEC, MMAP_CHECK,
-				&pcr, &template, NULL, NULL);
+				current_cred(), blob.secid[0], MAY_EXEC,
+				MMAP_CHECK, &pcr, &template, NULL, NULL);

 	/* Is the mmap'ed file in policy? */
 	if (!(action & (IMA_MEASURE | IMA_APPRAISE_SUBMASK)))
@@ -486,10 +487,12 @@ int ima_bprm_check(struct linux_binprm *bprm)
 {
 	int ret;
 	u32 secid;
+	struct lsmblob blob;

-	security_task_getsecid_subj(current, &secid);
-	ret = process_measurement(bprm->file, current_cred(), secid, NULL, 0,
-				  MAY_EXEC, BPRM_CHECK);
+	security_task_getsecid_subj(current, &blob);
+	/* scaffolding until process_measurement changes */
+	ret = process_measurement(bprm->file, current_cred(), blob.secid[0],
+				  NULL, 0, MAY_EXEC, BPRM_CHECK);
 	if (ret)
 		return ret;

@@ -510,10 +513,11 @@ int ima_bprm_check(struct linux_binprm *bprm)
  */
 int ima_file_check(struct file *file, int mask)
 {
-	u32 secid;
+	struct lsmblob blob;

-	security_task_getsecid_subj(current, &secid);
-	return process_measurement(file, current_cred(), secid, NULL, 0,
+	security_task_getsecid_subj(current, &blob);
+	/* scaffolding until process_measurement changes */
+	return process_measurement(file, current_cred(), blob.secid[0], NULL, 0,
 				   mask & (MAY_READ | MAY_WRITE | MAY_EXEC |
 					   MAY_APPEND), FILE_CHECK);
 }
@@ -689,7 +693,7 @@ int ima_read_file(struct file *file, enum kernel_read_file_id read_id,
 		  bool contents)
 {
 	enum ima_hooks func;
-	u32 secid;
+	struct lsmblob blob;

 	/*
 	 * Do devices using pre-allocated memory run the risk of the
@@ -709,8 +713,9 @@ int ima_read_file(struct file *file, enum kernel_read_file_id read_id,

 	/* Read entire file for all partial reads. */
 	func = read_idmap[read_id] ?: FILE_CHECK;
-	security_task_getsecid_subj(current, &secid);
-	return process_measurement(file, current_cred(), secid, NULL,
+	security_task_getsecid_subj(current, &blob);
+	/* scaffolding - until process_measurement changes */
+	return process_measurement(file, current_cred(), blob.secid[0], NULL,
 				   0, MAY_READ, func);
 }

@@ -739,7 +744,7 @@ int ima_post_read_file(struct file *file, void *buf, loff_t size,
 		       enum kernel_read_file_id read_id)
 {
 	enum ima_hooks func;
-	u32 secid;
+	struct lsmblob blob;

 	/* permit signed certs */
 	if (!file && read_id == READING_X509_CERTIFICATE)
@@ -752,9 +757,10 @@ int ima_post_read_file(struct file *file, void *buf, loff_t size,
 	}

 	func = read_idmap[read_id] ?: FILE_CHECK;
-	security_task_getsecid_subj(current, &secid);
-	return process_measurement(file, current_cred(), secid, buf, size,
-				   MAY_READ, func);
+	security_task_getsecid_subj(current, &blob);
+	/* scaffolding until process_measurement changes */
+	return process_measurement(file, current_cred(), blob.secid[0], buf,
+				   size, MAY_READ, func);
 }

 /**
@@ -882,7 +888,7 @@ int process_buffer_measurement(struct user_namespace *mnt_userns,
 	int digest_hash_len = hash_digest_size[ima_hash_algo];
 	int violation = 0;
 	int action = 0;
-	u32 secid;
+	struct lsmblob blob;

 	if (digest && digest_len < digest_hash_len)
 		return -EINVAL;
@@ -905,9 +911,10 @@ int process_buffer_measurement(struct user_namespace *mnt_userns,
 	 * buffer measurements.
 	 */
 	if (func) {
-		security_task_getsecid_subj(current, &secid);
+		security_task_getsecid_subj(current, &blob);
+		/* scaffolding */
 		action = ima_get_action(mnt_userns, inode, current_cred(),
-					secid, 0, func, &pcr, &template,
+					blob.secid[0], 0, func, &pcr, &template,
 					func_data, NULL);
 		if (!(action & IMA_MEASURE) && !digest)
 			return -ENOENT;
diff --git a/security/security.c b/security/security.c
index 2e74e5e88d64..1b9f33097216 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1906,17 +1906,30 @@ int security_task_getsid(struct task_struct *p)
 	return call_int_hook(task_getsid, 0, p);
 }

-void security_task_getsecid_subj(struct task_struct *p, u32 *secid)
+void security_task_getsecid_subj(struct task_struct *p, struct lsmblob *blob)
 {
-	*secid = 0;
-	call_void_hook(task_getsecid_subj, p, secid);
+	struct security_hook_list *hp;
+
+	lsmblob_init(blob, 0);
+	hlist_for_each_entry(hp, &security_hook_heads.task_getsecid_subj,
+			     list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		hp->hook.task_getsecid_subj(p, &blob->secid[hp->lsmid->slot]);
+	}
 }
 EXPORT_SYMBOL(security_task_getsecid_subj);

-void security_task_getsecid_obj(struct task_struct *p, u32 *secid)
+void security_task_getsecid_obj(struct task_struct *p, struct lsmblob *blob)
 {
-	*secid = 0;
-	call_void_hook(task_getsecid_obj, p, secid);
+	struct security_hook_list *hp;
+
+	lsmblob_init(blob, 0);
+	hlist_for_each_entry(hp, &security_hook_heads.task_getsecid_obj, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		hp->hook.task_getsecid_obj(p, &blob->secid[hp->lsmid->slot]);
+	}
 }
 EXPORT_SYMBOL(security_task_getsecid_obj);

--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id D4D0CC4332F
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:56:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239387AbhKXCAD (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:00:03 -0500
Received: from sonic315-27.consmr.mail.ne1.yahoo.com ([66.163.190.153]:41423
        "EHLO sonic315-27.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S238822AbhKXCAC (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:00:02 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719013; bh=Dj7UHpYVHqjreTElHiNwWdnVgmwqS6TZW/D5C04dUtQ=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=NqdLoN0bGrVaAkT+N317jnrsd1ySsXQgj/0XGUYrFcIBwf7JzTo2WgnYmiuxZUXoyV0E6gdNU+xOrkOSNf5KpgXJ9bWbNAfOj+ELfcbwQ73MaeAad9EGiGAvFD0tff/kLfu4TVl1c2dqb0gOZHOkdQAgjC2S3/eIg9I3QJ9AsSxCoPkZve6gUpYCsV0Djsamce/I0sH/1Vf+A4wi1nxY9VWcnW1HShPP+GjVOhDwtZlNcD0sxmNTmDZfMXYKcX3LpAINmq8QrWpczgVv8EYR0FYCbxd3KrVizG0bL+6+fRy9Ze5ijCaELMba0ehnS/07GX/+csldp697adOr7hekIg==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719013; bh=O0p7Vi0jlbIBk2Fq3kmz7Q05SRuEuccaOy+7KehXpRi=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=GazG4xdXapBuP/utgJGtuhk3T7zaxesEhXCUGh+WYGvuX9ktV0oSqNGyRgwOmkEVl/fLqfrFB03QP0zAqf42yDuSZFx9S9nTS+plDksyKpeLBAxVHwUPjqmiXEn59hnjIfhFZpC2buOICnI4kSIhnSOMHCY6htP7dksYdmMEYfoBHUt3Zbt4+BUcZyLbaxCdTh7Mlq4YujUgd2Kd9yqwSnaPTqXwvA29Ik+6UMbobPJ3Q5UDOyMgHeXout8tbX1QZY9pQv0eFZ5Ms8gnJB9m9KpfyhwqZkKVQ32XyFR/IKR/KKR6xwwP0yhXa4bSpAeFaE6wTgnAC7f9Jegc7XeXIg==
X-YMail-OSG: V.gSpQ8VM1nWy8qzWKQr6R1J4c851j40XxQUZQeu59ltimeLpWCHnk6ZbMrOmzp
 Etk_eM.PXBl2QlhUKic0TW2l.PPBWc9jQAoUDPKM_JKd1OfODO1m2OOVV5LTMwwN0w.LuW_E1HKu
 cZ.hGASL.VakE0hon8gL6B5v2W6ihjiFO.1.DnN4i3SoKONZDiSpBSDlYuitcxim8NjhYpFE2b5z
 anpOQSzQgIyoXNvrn1V13rwPXquXUV2xPI0HdMxUy0HoQigQZgBBMaQ.b.a87QAiowM0NS5vhpRn
 6bFQCTU1w55Kn3p2NVg62Lw3U7LQ6MhHU4PUeV0SivpsGKBGhbKgpItFMS1w0TR_1xT0_5DWRQei
 eiEQrHofZ5ldHWLgDAz7xqAJpr16ctW2ajEStLPxHspR7KPDXwn8TyVSt2_myzJ7dS15uZRvPY5W
 K69_tftApn3n0z08LuSKVL8KvMFa3eW9WSXHDFdI6.K65iGv9sRCfp8CkwiVElJ4p92fJ9LIV0s_
 .UnUeaFTep0G5m9PWlIzs61i5HxN8IX9MfDryfs7raizjTB02e_GIe4b5sXeqUUrEyAZiydifX25
 mi5PZKhICuXb07tQWIQnEnzvOLQs982EIY_220GUfEz30630mL4xce7c8gsa.bmzSEI74.3u.yMV
 VgPEgzXWfIl.ddTZn8xWh.VtjiWuTV8hntAK5h5cvXHNS0lNfHMbkjLv37dFjbvajQnD5C2RfzeD
 QAFDWbPgEWvQgkwYC3rHXn5b7QQCKcpcvuBg2vKAJ7zZZJccacqO0xlE8tWJo0YEOQ1P6j4YncRl
 QH3OUCtMbCaf9B6K0WcckFzH5UrSekPIz57bhTMKs2tk7xdBlsOOltm5aGPaMuHRwQoH0oy3uTak
 pYbVIlt0HLQV92WFTK36Exn0M83031bi4vOuRcSv2jCd7YuZYR6ClSyM7xlDxlM2mp9e5SOcaJlP
 8ImNo2o3fY2OCWbioch3HnjmIY9sjzlpOn2y4cDFMmMnnxVYZElV5.XXlNqyWNRahWp3MbH6yf4O
 unOF31IogQd3zCVpX0YWCCVoy3p_sbl15Xh.PjSS9fjwSr1DHREl75Le_7xOxg47UzghI3p3KS2h
 bBreBBauPJq3IXQI_1qMQweg_KGF3tiovVQeM78El2ujadogm3NfM8oBqCo2cidG5qAbvyc3oSYI
 2fBz8z8Z7SXaK5AjNbaZtaum.vgd8TSbVljiWrugxvL7TYgpS1GQdyr3n43geX8lqpm_d6L_vJsV
 Ob95rs8XaAfVyo91.uQ2kx3nEDUgjPRmrY6GJNJi0i0g157I.sd96WLPT5BaJWMQhoc3ZnEne5EH
 6Qj2K1ERrdQ6_LqNultcUQ6127mAyq_4hClNFiYExlW8MpBsbBKX6d_ITDRaMkvNDmT2J3hSevSN
 iZiqwZKaZx512.J6Nyi_01myNOEf96DBcAV_0CJCoqAIF4TfxFblNt4tIVOphauJFxkLLjLxnJbS
 E2ErpWzZnz38SWpHU4jla7XnUJEdQ6E6IdBijoOCc.T9l1lK9OtmGezClL4eDH36o57_B86ozhLy
 YRGU5.Jp3KPotCXrBA80TRynUKDI0H2eenhs5qyCVsVeBwV99XIkIDqAKLY734R8xcskDpYbnL1N
 IkCSY9L6V_TeokpyrrfDE2kZFJHVHZgJdtbMoAbDnaWT3AsOXjzUYjyR4cjsERtcIpVQGBeUnf0h
 26kAbIEfylXKCSO2tXU9X49TeaZ1BehPq6k1TjqXg9vZMYU2E1cP97UUSBpxLDDgSJJrHRAiJd80
 Us8Ld7T4PhNMRlDqJGnjXuLie9E973DA0_geOAKSVKyIix780K8ofkBC9h.fipdH7nN_PPjrnqz.
 pUDcI9B6aktSomVD9AucIGQ4iKGeKPC0X2VOI4PzEsM7hY64C2R6oTWdKS0UWuQkTm6YG2yIwkPR
 i2iVt9WT81F6E.TVCs60l32jixFGFHPSxCMidisNZzngqTidQksJtgCKv9tUK0LAf60LlNOyAkwr
 syBr5Z8nsHrN4Koha1eL3sT6aePBCo3Y8b_hYJqJKl4109YvWi45gqw0ezBgoSvPnjqVnDP4unOd
 EwKx0SzYm1jKXSE80oYVpDwG.KC0RuCVZHVOadJeIYkmqiJvKbApT2SYIPdYMx397GSX8A82fQTQ
 ouxRpqc1XW2i3Rk2ZRM3.Y17TzoxTgy35PjoimHW5M3BsSlC5CjLp0I_cssQRetPhJWfr.9sxMai
 _n0tKxjC.TbtfhAgDtkPHFjrHnFNfOuiD1NdjOz5YQ5VeQ.5Oj7KhEPpG6BSUYbPf
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic315.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:56:53 +0000
Received: by kubenode511.mail-prod1.omega.ne1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 64c89d686737995e38e1628cf5806ab5;
          Wed, 24 Nov 2021 01:56:50 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>,
        linux-integrity@vger.kernel.org
Subject: [PATCH v30 12/28] LSM: Use lsmblob in security_inode_getsecid
Date:   Tue, 23 Nov 2021 17:43:16 -0800
Message-Id: <20211124014332.36128-13-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Change the security_inode_getsecid() interface to fill in a
lsmblob structure instead of a u32 secid. This allows for its
callers to gather data from all registered LSMs. Data is provided
for IMA and audit.

Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: linux-integrity@vger.kernel.org
Cc: linux-audit@redhat.com
---
 include/linux/security.h            |  7 ++++---
 kernel/auditsc.c                    |  6 +++++-
 security/integrity/ima/ima_policy.c |  7 ++++---
 security/security.c                 | 11 +++++++++--
 4 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/include/linux/security.h b/include/linux/security.h
index efd6e88d57b1..f324acc2c029 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -457,7 +457,7 @@ int security_inode_getsecurity(struct user_namespace *mnt_userns,
 			       void **buffer, bool alloc);
 int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags);
 int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size);
-void security_inode_getsecid(struct inode *inode, u32 *secid);
+void security_inode_getsecid(struct inode *inode, struct lsmblob *blob);
 int security_inode_copy_up(struct dentry *src, struct cred **new);
 int security_inode_copy_up_xattr(const char *name);
 int security_kernfs_init_security(struct kernfs_node *kn_dir,
@@ -1009,9 +1009,10 @@ static inline int security_inode_listsecurity(struct inode *inode, char *buffer,
 	return 0;
 }

-static inline void security_inode_getsecid(struct inode *inode, u32 *secid)
+static inline void security_inode_getsecid(struct inode *inode,
+					   struct lsmblob *blob)
 {
-	*secid = 0;
+	lsmblob_init(blob, 0);
 }

 static inline int security_inode_copy_up(struct dentry *src, struct cred **new)
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index 7cd70a43408f..3123c97d13b3 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -2239,13 +2239,17 @@ static void audit_copy_inode(struct audit_names *name,
 			     const struct dentry *dentry,
 			     struct inode *inode, unsigned int flags)
 {
+	struct lsmblob blob;
+
 	name->ino   = inode->i_ino;
 	name->dev   = inode->i_sb->s_dev;
 	name->mode  = inode->i_mode;
 	name->uid   = inode->i_uid;
 	name->gid   = inode->i_gid;
 	name->rdev  = inode->i_rdev;
-	security_inode_getsecid(inode, &name->osid);
+	security_inode_getsecid(inode, &blob);
+	/* scaffolding until osid is updated */
+	name->osid = blob.secid[0];
 	if (flags & AUDIT_INODE_NOEVAL) {
 		name->fcap_ver = -1;
 		return;
diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index 22952efcc0b0..34ecdd7b01f5 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -625,7 +625,7 @@ static bool ima_match_rules(struct ima_rule_entry *rule,
 		return false;
 	for (i = 0; i < MAX_LSM_RULES; i++) {
 		int rc = 0;
-		u32 osid;
+		struct lsmblob lsmdata;

 		if (!rule->lsm[i].rule) {
 			if (!rule->lsm[i].args_p)
@@ -637,8 +637,9 @@ static bool ima_match_rules(struct ima_rule_entry *rule,
 		case LSM_OBJ_USER:
 		case LSM_OBJ_ROLE:
 		case LSM_OBJ_TYPE:
-			security_inode_getsecid(inode, &osid);
-			rc = ima_filter_rule_match(osid, rule->lsm[i].type,
+			security_inode_getsecid(inode, &lsmdata);
+			rc = ima_filter_rule_match(lsmdata.secid[rule->which],
+						   rule->lsm[i].type,
 						   Audit_equal,
 						   rule->lsm[i].rule,
 						   rule->which);
diff --git a/security/security.c b/security/security.c
index 1b9f33097216..54b5dbe63265 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1550,9 +1550,16 @@ int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer
 }
 EXPORT_SYMBOL(security_inode_listsecurity);

-void security_inode_getsecid(struct inode *inode, u32 *secid)
+void security_inode_getsecid(struct inode *inode, struct lsmblob *blob)
 {
-	call_void_hook(inode_getsecid, inode, secid);
+	struct security_hook_list *hp;
+
+	lsmblob_init(blob, 0);
+	hlist_for_each_entry(hp, &security_hook_heads.inode_getsecid, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		hp->hook.inode_getsecid(inode, &blob->secid[hp->lsmid->slot]);
+	}
 }

 int security_inode_copy_up(struct dentry *src, struct cred **new)
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 22EC2C43217
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:58:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232410AbhKXCBL (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:01:11 -0500
Received: from sonic315-27.consmr.mail.ne1.yahoo.com ([66.163.190.153]:39939
        "EHLO sonic315-27.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S239573AbhKXCBH (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:01:07 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719078; bh=SaFxVnogzJCq2k92oJIkP1y5i7oZ2jbyQ0ExTgBRwoE=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=VsuByuzNiePh+HXwk4zu3+KvcANeHpivUTWC1xyHAY+lo2dwWoNUQs/tu6/cjZfQ1PtPpF9KltZHdUgbXYz1748VYS99Sro7QOOT7gsuIPrh0pOKMdbwzMIptVpLmfYhxzXJXIRKk/405NTu1Yt1TnWeuldcIQaGJVUxFsh2WH+hYcF8Px6T4JwKIwHGZGMxNnAhQLtqv+ukB+jS19DzA39VerHwTr9Fu+iPrPUEl1i/7tKNSLRkaOuhRDXEcuH3u91BarNkq1WrkqhpUwn0Mc4HdnAROF+rPTP3k74VON7MwhjZpeBQKhg+FzxY5VmxEIkKjljpB5aiH0XUNl1oZQ==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719078; bh=3SwvkznlKQgH48hA1kOckf3NZlCA5/C9CZBFkyMOy6v=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=FePZWN/OsHPokmVZBDGiOrzn6O19kNuk2jL8LcjwasiZxdHENSLctLZ2phVgm1D+ZC/IGR2oFh4/svuGH4oX7Ef2CZXZNC7vmyv5Y7/tYbODPJlFBPWeUapBCiXVMMsBk0f3wJ2QOBENLahVK3FAquPXhskj+zVVbKlPSW6jQXE/Ev/7ak6G7Q4PVQr9m8LfDCdV33Z6wVuzpnlRc+oAjGqIfd5SfYTbgX9Jp/OH9g8KSJcSbZ9dSfvd/gsEqK90sFa8RlyVS9vixI/3DnsvV9s/WrUeAXmN4XHqY5WLHOlztwOiP4MMd5eG6UBR5fy4lz/x+/Nx4fl4IG+DEylZxw==
X-YMail-OSG: DpqoLzYVM1kTH2C3DkX_NfQ0Q2.fl.Wcgi.cFGyJxEJX1ziXmkMSOh.KtBB5hD1
 kWDDE.R_hSORliPWQGXm1JQ0J1Hsc18gDEJo3xMjOgGandhtyUTUCAzn9mpLpyQhFxV5eTLKz89o
 deGHoPYqGo.7r0IzhhX.QRNEnfCDJhnk0IRn448uPv9Bv.EP7ymDw_mi5mAcLC0.DKmhN6HaTW2O
 DOWUjx5gHm1lYieCqCqInwopI29.NCepjoCrjDUeSVqH6md.wQ2bjUAYNy0Oqo6iO9QsHSXw1_Wb
 PJfjxrXqta5j8knBOBLsHduTB787idqNZYoQW96QgN2h5CkIuzbW4ckVKCTyaV3ow.._KvXD4v27
 E_6MS5pCVt0zoVn6_k8Ungxtgr2bMiGNowK__FaMJo7w5ygMa_tDLhZ0CVE6h.t6xz0qseVRtF8g
 lG7yvt2W_Vg.d30buJoConrOhmXHnB9DA5bzmSMxczB0pVLUpH3oyKQZpepP5agQXJCTjuZw.9n.
 oK6gcaWcURF9Th8A3t9pqI3EZZzX7PCAeZ7de7Ienz52.NQeFqc.9NbCxUAakLzw0z9WxTDhUa5P
 2iQRg1SWeGdgMDw_ht9uLh9ps0zcoz9KM.xWRhZcm9gOOtcwFxN2HcTpZE5Q5O1ik9lnI1nRjm2M
 YBVZ1mEqvDNKRfL6_E2ftc_sl5VCugjNvA59KQeE2WGzjpYoE32U4N99clhUwrBCpEiS6lIGtC.I
 t7OVdLy_lSSMilG74j3z_rO3YvPIP8ywQA.fqf.4iPRNttx0VTOLTtHLsqET5YW_8CRdpTuWJShU
 jP.LMxvCYAjvWmE2bSfurDsNFXKLE.LtcPFQUxH.e5ap7.pQX_vK7bDjexnJe9MXsf8XlOQUvi.i
 Q2.MxmITnCWYLe9hNjjM.KTxNnCorUJIxfYfXaW2kFGBaKH0SvdzRW3GXIaEHKhXOCOGDzddy_B9
 kiM5kOJRIlfatsKI05UUEYg5UnAHpTr88Q6ct1.FOAfSKhQAMzYo0xrFQxyzKbdZizBmh0uQla29
 zn7OfdRTpr.Jn33ws_iU1iHJSVAXh87f3AqmmX3vXeOcvVo1Idqt6vAn8BAExPvf_ieXUFFW9_3R
 jY0RXMulg6LV9lF1lpakD2IWhUZV5rFHxGY7oeZfcDOENdWAqkDeLqiBXppGRgSvnJhcUt.VnwEZ
 m1lmybg_uZUoAPn3xldZBnxVlw6aWzgdwfgqq0.xX.SXPNr6Temj84Uhrxj0sK50xNJ2GldIXPO4
 tRHaBTvI6zT5Z5fSna6qYg85n7EQJC6cjD_fjWSRQbPUWz8kdJZUepO.XOQqP3H3BjhvylbBzwxd
 bBnlYesyvvUen1oeD8JJO4CRVDiQsPpR8iVHUk.4MnmVrJs6fRt4eUrD.gbnEui_TVxmX5KV_FHK
 bYo8nQFA_5Ea5KGGO9aW60wWcCke3NWc_wX3z5PUM0ZXpPuImRkHTqC6WX9QZT1K8QPTwUlCTAQS
 j3g50uxVESUxzQ5fWmW1UkvMhlbQnKYGBNKVOAQAZoKz3kRJ425dimnUbf0X8.euvV9tX5jBOwdT
 X7a4wixhG07q2XDncutx43ZXPRJ16HTANM2ElSBQ4Om_nNkxHTBTE1yjYA_NzP3QAMCNLWg3QD8h
 I5bgu1ALvNYSfr62wQPj0bAlLORM0U2ujlvc74RZ5BukLrJ1gBIt1k619px5JcAEabH3qWlysODC
 3IgATvTe3_oOUiNUc2f.UqnNT3VUKLKA5f.OKokN.6J67uAi4KvS8HzYINTluwsozVn6spiZ1VLs
 D5uxAVEEKmKLyyNCJIGxcERzgRlA3XUNsyHectfKCo0IXsAq.ujERkmCY4kw0MIGTUIGLK5cz4L8
 vQuSeKce2gotjmcWfyTUdRughH0cg7WRI1i0XhTIvJgdjFyb.TI_AnyaZAS__50ni6ebUrxE1KOW
 ny5YgFmWMUURCBanEWqlHpxsRh0q0AMOSwc1YNIQJdszxoDPb5tCrIifgbAxdcC71grkSlVzIzWg
 _4rSp3r1ryJ9BSTzQKhKIk_ZcR8M7fHQt3zS0v7c9wXeQOVbv8ZETijX4tVg_c3Aes9lT_MLiddf
 s4wRzeUjZ2jQNDtZX7u2DkCMefifHohXCcijElaAY0pa60iRcWAWRGsbXXU6yTZQWtq2VX8QlmWo
 dUPDPNj3JpS8KkbvqYhTcFrUd_RecAWDXQkq3NsmlQvmQO1WOfCPNG3Pn53QEmZg04smHhITMbXo
 SqSXmigbLrWvFcy2JA9fMwwjLld6W4y0LSIUDYp.h85dPr5pHMRg1vbwZdGEB2tX8zFo-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic315.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:57:58 +0000
Received: by kubenode551.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID fc90a0548d4652347091e08d13a1c44d;
          Wed, 24 Nov 2021 01:57:55 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>,
        linux-integrity@vger.kernel.org
Subject: [PATCH v30 13/28] LSM: Use lsmblob in security_cred_getsecid
Date:   Tue, 23 Nov 2021 17:43:17 -0800
Message-Id: <20211124014332.36128-14-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Change the security_cred_getsecid() interface to fill in a
lsmblob instead of a u32 secid. The associated data elements
in the audit sub-system are changed from a secid to a lsmblob
to accommodate multiple possible LSM audit users.

Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: linux-integrity@vger.kernel.org
Cc: linux-audit@redhat.com
---
 drivers/android/binder.c          | 12 +----------
 include/linux/security.h          |  2 +-
 kernel/audit.c                    | 25 +++++++----------------
 kernel/audit.h                    |  3 ++-
 kernel/auditsc.c                  | 33 +++++++++++--------------------
 security/integrity/ima/ima_main.c |  8 ++++----
 security/security.c               | 12 ++++++++---
 7 files changed, 36 insertions(+), 59 deletions(-)

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 780c7e265f3a..2be77ae9ca52 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -2720,18 +2720,8 @@ static void binder_transaction(struct binder_proc *proc,
 	if (target_node && target_node->txn_security_ctx) {
 		struct lsmblob blob;
 		size_t added_size;
-		u32 secid;

-		security_cred_getsecid(proc->cred, &secid);
-		/*
-		 * Later in this patch set security_cred_getsecid() will
-		 * provide a lsmblob instead of a secid. lsmblob_init
-		 * is used to ensure that all the secids in the lsmblob
-		 * get the value returned from security_cred_getsecid(),
-		 * which means that the one expected by
-		 * security_secid_to_secctx() will be set.
-		 */
-		lsmblob_init(&blob, secid);
+		security_cred_getsecid(proc->cred, &blob);
 		ret = security_secid_to_secctx(&blob, &secctx, &secctx_sz);
 		if (ret) {
 			return_error = BR_FAILED_REPLY;
diff --git a/include/linux/security.h b/include/linux/security.h
index f324acc2c029..5271b2f4dfca 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -484,7 +484,7 @@ int security_cred_alloc_blank(struct cred *cred, gfp_t gfp);
 void security_cred_free(struct cred *cred);
 int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp);
 void security_transfer_creds(struct cred *new, const struct cred *old);
-void security_cred_getsecid(const struct cred *c, u32 *secid);
+void security_cred_getsecid(const struct cred *c, struct lsmblob *blob);
 int security_kernel_act_as(struct cred *new, struct lsmblob *blob);
 int security_kernel_create_files_as(struct cred *new, struct inode *inode);
 int security_kernel_module_request(char *kmod_name);
diff --git a/kernel/audit.c b/kernel/audit.c
index d92c7b894183..8ec64e6e8bc0 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -125,7 +125,7 @@ static u32	audit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;
 /* The identity of the user shutting down the audit system. */
 static kuid_t		audit_sig_uid = INVALID_UID;
 static pid_t		audit_sig_pid = -1;
-static u32		audit_sig_sid;
+struct lsmblob		audit_sig_lsm;

 /* Records can be lost in several ways:
    0) [suppressed in audit_alloc]
@@ -1441,29 +1441,21 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	}
 	case AUDIT_SIGNAL_INFO:
 		len = 0;
-		if (audit_sig_sid) {
-			struct lsmblob blob;
-
-			/*
-			 * lsmblob_init sets all values in the lsmblob
-			 * to audit_sig_sid. This is temporary until
-			 * audit_sig_sid is converted to a lsmblob, which
-			 * happens later in this patch set.
-			 */
-			lsmblob_init(&blob, audit_sig_sid);
-			err = security_secid_to_secctx(&blob, &ctx, &len);
+		if (lsmblob_is_set(&audit_sig_lsm)) {
+			err = security_secid_to_secctx(&audit_sig_lsm, &ctx,
+						       &len);
 			if (err)
 				return err;
 		}
 		sig_data = kmalloc(sizeof(*sig_data) + len, GFP_KERNEL);
 		if (!sig_data) {
-			if (audit_sig_sid)
+			if (lsmblob_is_set(&audit_sig_lsm))
 				security_release_secctx(ctx, len);
 			return -ENOMEM;
 		}
 		sig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);
 		sig_data->pid = audit_sig_pid;
-		if (audit_sig_sid) {
+		if (lsmblob_is_set(&audit_sig_lsm)) {
 			memcpy(sig_data->ctx, ctx, len);
 			security_release_secctx(ctx, len);
 		}
@@ -2352,7 +2344,6 @@ int audit_set_loginuid(kuid_t loginuid)
 int audit_signal_info(int sig, struct task_struct *t)
 {
 	kuid_t uid = current_uid(), auid;
-	struct lsmblob blob;

 	if (auditd_test_task(t) &&
 	    (sig == SIGTERM || sig == SIGHUP ||
@@ -2363,9 +2354,7 @@ int audit_signal_info(int sig, struct task_struct *t)
 			audit_sig_uid = auid;
 		else
 			audit_sig_uid = uid;
-		security_task_getsecid_subj(current, &blob);
-		/* scaffolding until audit_sig_sid is converted */
-		audit_sig_sid = blob.secid[0];
+		security_task_getsecid_subj(current, &audit_sig_lsm);
 	}

 	return audit_signal_info_syscall(t);
diff --git a/kernel/audit.h b/kernel/audit.h
index c4498090a5bd..527d4c4acb12 100644
--- a/kernel/audit.h
+++ b/kernel/audit.h
@@ -12,6 +12,7 @@
 #include <linux/fs.h>
 #include <linux/audit.h>
 #include <linux/skbuff.h>
+#include <linux/security.h>
 #include <uapi/linux/mqueue.h>
 #include <linux/tty.h>
 #include <uapi/linux/openat2.h> // struct open_how
@@ -143,7 +144,7 @@ struct audit_context {
 	kuid_t		    target_auid;
 	kuid_t		    target_uid;
 	unsigned int	    target_sessionid;
-	u32		    target_sid;
+	struct lsmblob	    target_lsm;
 	char		    target_comm[TASK_COMM_LEN];

 	struct audit_tree_refs *trees, *first_trees;
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index 3123c97d13b3..7d256fb2ec03 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -99,7 +99,7 @@ struct audit_aux_data_pids {
 	kuid_t			target_auid[AUDIT_AUX_PIDS];
 	kuid_t			target_uid[AUDIT_AUX_PIDS];
 	unsigned int		target_sessionid[AUDIT_AUX_PIDS];
-	u32			target_sid[AUDIT_AUX_PIDS];
+	struct lsmblob		target_lsm[AUDIT_AUX_PIDS];
 	char 			target_comm[AUDIT_AUX_PIDS][TASK_COMM_LEN];
 	int			pid_count;
 };
@@ -1009,7 +1009,7 @@ static void audit_reset_context(struct audit_context *ctx)
 	ctx->target_pid = 0;
 	ctx->target_auid = ctx->target_uid = KUIDT_INIT(0);
 	ctx->target_sessionid = 0;
-	ctx->target_sid = 0;
+	lsmblob_init(&ctx->target_lsm, 0);
 	ctx->target_comm[0] = '\0';
 	unroll_tree_refs(ctx, NULL, 0);
 	WARN_ON(!list_empty(&ctx->killed_trees));
@@ -1107,14 +1107,14 @@ static inline void audit_free_context(struct audit_context *context)
 }

 static int audit_log_pid_context(struct audit_context *context, pid_t pid,
-				 kuid_t auid, kuid_t uid, unsigned int sessionid,
-				 u32 sid, char *comm)
+				 kuid_t auid, kuid_t uid,
+				 unsigned int sessionid,
+				 struct lsmblob *blob, char *comm)
 {
 	struct audit_buffer *ab;
 	char *ctx = NULL;
 	u32 len;
 	int rc = 0;
-	struct lsmblob blob;

 	ab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);
 	if (!ab)
@@ -1123,9 +1123,8 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 	audit_log_format(ab, "opid=%d oauid=%d ouid=%d oses=%d", pid,
 			 from_kuid(&init_user_ns, auid),
 			 from_kuid(&init_user_ns, uid), sessionid);
-	if (sid) {
-		lsmblob_init(&blob, sid);
-		if (security_secid_to_secctx(&blob, &ctx, &len)) {
+	if (lsmblob_is_set(blob)) {
+		if (security_secid_to_secctx(blob, &ctx, &len)) {
 			audit_log_format(ab, " obj=(none)");
 			rc = 1;
 		} else {
@@ -1753,7 +1752,7 @@ static void audit_log_exit(void)
 						  axs->target_auid[i],
 						  axs->target_uid[i],
 						  axs->target_sessionid[i],
-						  axs->target_sid[i],
+						  &axs->target_lsm[i],
 						  axs->target_comm[i]))
 				call_panic = 1;
 	}
@@ -1762,7 +1761,7 @@ static void audit_log_exit(void)
 	    audit_log_pid_context(context, context->target_pid,
 				  context->target_auid, context->target_uid,
 				  context->target_sessionid,
-				  context->target_sid, context->target_comm))
+				  &context->target_lsm, context->target_comm))
 			call_panic = 1;

 	if (context->pwd.dentry && context->pwd.mnt) {
@@ -2698,15 +2697,12 @@ int __audit_sockaddr(int len, void *a)
 void __audit_ptrace(struct task_struct *t)
 {
 	struct audit_context *context = audit_context();
-	struct lsmblob blob;

 	context->target_pid = task_tgid_nr(t);
 	context->target_auid = audit_get_loginuid(t);
 	context->target_uid = task_uid(t);
 	context->target_sessionid = audit_get_sessionid(t);
-	security_task_getsecid_obj(t, &blob);
-	/* scaffolding - until target_sid is converted */
-	context->target_sid = blob.secid[0];
+	security_task_getsecid_obj(t, &context->target_lsm);
 	memcpy(context->target_comm, t->comm, TASK_COMM_LEN);
 }

@@ -2722,7 +2718,6 @@ int audit_signal_info_syscall(struct task_struct *t)
 	struct audit_aux_data_pids *axp;
 	struct audit_context *ctx = audit_context();
 	kuid_t t_uid = task_uid(t);
-	struct lsmblob blob;

 	if (!audit_signals || audit_dummy_context())
 		return 0;
@@ -2734,9 +2729,7 @@ int audit_signal_info_syscall(struct task_struct *t)
 		ctx->target_auid = audit_get_loginuid(t);
 		ctx->target_uid = t_uid;
 		ctx->target_sessionid = audit_get_sessionid(t);
-		security_task_getsecid_obj(t, &blob);
-		/* scaffolding until target_sid is converted */
-		ctx->target_sid = blob.secid[0];
+		security_task_getsecid_obj(t, &ctx->target_lsm);
 		memcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);
 		return 0;
 	}
@@ -2757,9 +2750,7 @@ int audit_signal_info_syscall(struct task_struct *t)
 	axp->target_auid[axp->pid_count] = audit_get_loginuid(t);
 	axp->target_uid[axp->pid_count] = t_uid;
 	axp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);
-	security_task_getsecid_obj(t, &blob);
-	/* scaffolding until target_sid is converted */
-	axp->target_sid[axp->pid_count] = blob.secid[0];
+	security_task_getsecid_obj(t, &axp->target_lsm[axp->pid_count]);
 	memcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);
 	axp->pid_count++;

diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index c327f93d3962..1a4f7b00253b 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -486,7 +486,6 @@ int ima_file_mprotect(struct vm_area_struct *vma, unsigned long prot)
 int ima_bprm_check(struct linux_binprm *bprm)
 {
 	int ret;
-	u32 secid;
 	struct lsmblob blob;

 	security_task_getsecid_subj(current, &blob);
@@ -496,9 +495,10 @@ int ima_bprm_check(struct linux_binprm *bprm)
 	if (ret)
 		return ret;

-	security_cred_getsecid(bprm->cred, &secid);
-	return process_measurement(bprm->file, bprm->cred, secid, NULL, 0,
-				   MAY_EXEC, CREDS_CHECK);
+	security_cred_getsecid(bprm->cred, &blob);
+	/* scaffolding until process_measurement changes */
+	return process_measurement(bprm->file, bprm->cred, blob.secid[0],
+				   NULL, 0, MAY_EXEC, CREDS_CHECK);
 }

 /**
diff --git a/security/security.c b/security/security.c
index 54b5dbe63265..f7af2444fcc3 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1800,10 +1800,16 @@ void security_transfer_creds(struct cred *new, const struct cred *old)
 	call_void_hook(cred_transfer, new, old);
 }

-void security_cred_getsecid(const struct cred *c, u32 *secid)
+void security_cred_getsecid(const struct cred *c, struct lsmblob *blob)
 {
-	*secid = 0;
-	call_void_hook(cred_getsecid, c, secid);
+	struct security_hook_list *hp;
+
+	lsmblob_init(blob, 0);
+	hlist_for_each_entry(hp, &security_hook_heads.cred_getsecid, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		hp->hook.cred_getsecid(c, &blob->secid[hp->lsmid->slot]);
+	}
 }
 EXPORT_SYMBOL(security_cred_getsecid);

--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 2F6E1C43217
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 01:59:09 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239713AbhKXCCP (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:02:15 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:33638
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S239560AbhKXCCO (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:02:14 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719145; bh=Es6Pcqg5Z1JFFJx1PN7q5y8EGZea8Hty70edLPvvNNg=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=llgqP36cXKTaGLdit1YwwRqwvBGQdB21MiMb/OoWZQQn8i7grZMDk/iZigTFXUsqS3eZn8ltXN8g/TnL+u/A5dOe7wwAUFbImr9jzaz2Q8hn+j+8TFPEVClCtRG1MZEMPPIwIc1LcBiFVsIU4xwe+dyTtfum8TUBip9rMMv9fxdAXe5HoFLwNprmGA5E1fIdqzJMAyTFueRQDSuQ1+kwfmFXQTvEvCloI79F9lKqnUXxGA7U1IdRR673ikdwVR5duM2XhXTTp7n55NzHbmKNAKLSp6NIppXjZ3dnUCuP9OJ8DSmjymAqOGgAsQD8xEmdBi2nKAURyjQ0moEWHNSIcg==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719145; bh=ZGjTAY8NZeT+3i4IZsRYQRgtGV8Pkvd+dGUyVvt0DOS=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=NZHvpA59UV6QAqC0faBQs/bm2PwhMXsoYocCSzTQBMDtwzdYeG7TZNQvAeDyBWRM7vLHqDFFIrOjDjrqqh/mxwfdK1XGHQPEaw3iCC5KVhNldLtbSr5/C0iv1XyHqPLKV3eMUbNylMawK3yo+WKvNeKfKbxh39G3rqLOH24l9k2k5TLvonBklF5LJTPjkZdQfP8MTHY5R0VsaVRHFFEfy2Lf1fY1Hv0INsrYblYtTZ8XIw6JILevWYpDTC10kDiwcvqAr+58CtqmIul1RX+7PxbPpKL5NaKp+RXSRq2ebdNUvG14GKD+XShpLIGQaVVpu3BR1q//bt9N5UC98idjKw==
X-YMail-OSG: qYUdRFUVM1l_z8Z57WOBALURZVP_auwxmWKlxuJLa4LZSeAw0Nn0UGLuDcgLP46
 7Il3BTezTZ18ZZ95IrrwzU_ySH.hlSK9Gu2JLsV7QhXMVImi1hugpbBoJrY8bQFZCH7CMADR2H.m
 9h99BeguzI8hcvEYp2nSJSRMvsrTxjT.aqXWO5l._KSc0EtJvMQalLljgWhUJMw25VRgKbdBiHjz
 oXhvTVbCLJEOKUoPX74ayXnBCww.c7o6h4lmoZVHy6YM2dGgo1e_iiPd2ddtvq8wbpsHvcHoBr0y
 morUUmMAx29JBYEbKmZB6taDvn084MrPuqcgGozJGDlaRFxqJB0did143v.ApIFLHMO.XKPbEpYq
 316gytMRLr_6RLckySWVz4jZJFKq_5skiaK96cKfE01jC26iXeVbW6c.uyRYnDIP9d3rIVigEKFK
 0QvLXhNoTxYsA4E2voGhqEPyoam6uvqnAwiR0S0wXff.Sb6eYebSpecELol7W1BN2gzltl.Ovjf0
 nDjmr6EwIQTditibLooF9EnGhjwMcJi_.ZqaxETrLZGpBpRd_l_kjgL3ymg2dl88GE2FcNbiyGFo
 tCngYo0LF3R7G_kbnxX99CManoX3Tc0X5Skg2wvxxnRRcp5q1YCXWKjOaZoRyM56tmJelgVfWp8u
 E.umwxXKqAsFVlNjjXc32NtSgNhS4hNOBqqwIwRpXMTaiYGvcMQrKgAW94NQ1PomRmNHI9LP4G1O
 5__k3KzLdRWel17.r5ZHSRhJimMar_D6dbv1BrANBM9b.B9a.u2v3u0_J.bgmIL_tqJfuRYhlOpj
 pC7Kb5HXDWhG5FkzwWPT0SCKbgr594NLNdKIfgJxUuB1DJF5jgmc2tA6Ws2DAJgCxvoMsMJFx32J
 Xhw3mLF9AIE6sMjSj.btrtIzA6xHpE.2f9hCavJtVC84B_LviUyehj4bt298ErXSUlEW4p_YonGT
 m4m0Of6XLd71kXBe4O5mxhWDwzt9BiMZ0mA820JHoxaVG6FJqvu50I9XnqnVP5MZQIlag0In7p2P
 6V5QFbFFgKQTQujPNjbWCWKMANM3V4IRrQbvJjqvri8sn.nvuNgxi7VcAmeJxWpnuMQ7E.umTjtY
 WMCk05MvqSAnqiMGnzLhbTr5Nv.V2YL3rQyZFBwh_8uBgv1GvtIOssmqHA76zE1uMcDOF_5_3QKV
 hCTjNJgc73N_oJlp03i1W_LAjUYjGXhHxywgLUZww1lPisNTLNKN6jytx8LhurlNEJTQVhEQBBNj
 leVJQLi04VJwjjTnokCWMtrO.fEpzL_1BnCuSVwYQsc08qzOMd0_oeHY3e.5c5XvjdGUqkDtixTH
 cEilblVX92J1Ylqtka_faFWidWmFEHgF_4lCJ8z3HO.IPJhnok.7elzSk5L7.s8.xlJbACSMSmRG
 Ok2cCXwBgxty9W4A6kxVbST.R5nW08j1fjwZIOdSOCjC1ups8NYgO7uSzHftA0dIuUlY1QGPFpGd
 s8dwkukOw6WJsr.U1a16T1ajKD2l44n5Yl4Wcfjd_bC6p8gvkAo1ED8VvrZEJx8ZLm1dQRf4CbyL
 PWdrEXE3XmFuWc7T8rl1FKWGFQnHo9HR1.XXhvp0EGSGwIovnPQHaexqPtjDM42dYTd63TKXnzSN
 wPxtJ7i3nlCgeQL.pVv5t.xkBHl2FQ9Mep4ib7dM61.RyN6NRmBR4TedSAntiFJXPi5.Cp_TNyjs
 jcUU9NTCFPwR7ppB_wUb7OFrB_9qn8.W7whE0uMyOMDBeWvnYGsvDjukh3V9iCoGog6WrIuduqmz
 1O3O.bRpfL8M0qNXreX5iMa.kP3UkOV4ez6JlaD6RcRzwZ2Gz_ktQhWZLsLQ6PFweLqkinRpwFMB
 yKFCkX0LaKrIdJhRJPOCqx_KmTvLZTnuhXvmyvmMjWnSiOk90ucMyd7nU3TVY02WX2L2wt4KfkKj
 F0KMRdzCszmF4krys6MH8iKB26f0xLvFySg8hjNYwMn6q_IA7sBPSSkfjsfX4AV8GZEUMZhU2SI7
 BWnDB3Zt7CWNEyBcFLq1tHqDNtkOu9sYtHUObuTsf7ctoDOHR9bzXRxRlceEMFnOUMMbpG_rYu9Y
 8eU5cDILR9OTx_MSxKAKh_WnlKBzX4gQs9V9Sh4WBkonuy6Ic9P65SXQxvjIu0W_pb0ZVLaLWkxD
 Msm3smOM45GoXwiVaMN1UhntDDpn3o7bxuFMasJPugp4NafOhA87lw902VKROknUD5rJDb9bWfy7
 47TolcVYJliZNR2lmMVMx8YxYnm6_41UmzM2NN4nbakL9q0hSa_g-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 01:59:05 +0000
Received: by kubenode512.mail-prod1.omega.ne1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 474b10c19bdf5902ffe481babb388f3b;
          Wed, 24 Nov 2021 01:59:01 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>,
        Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
        linux-api@vger.kernel.org, linux-doc@vger.kernel.org
Subject: [PATCH v30 14/28] LSM: Specify which LSM to display
Date:   Tue, 23 Nov 2021 17:43:18 -0800
Message-Id: <20211124014332.36128-15-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Create a new entry "interface_lsm" in the procfs attr directory for
controlling which LSM security information is displayed for a
process. A process can only read or write its own display value.

The name of an active LSM that supplies hooks for
human readable data may be written to "interface_lsm" to set the
value. The name of the LSM currently in use can be read from
"interface_lsm". At this point there can only be one LSM capable
of display active. A helper function lsm_task_ilsm() is
provided to get the interface lsm slot for a task_struct.

Setting the "interface_lsm" requires that all security modules using
setprocattr hooks allow the action. Each security module is
responsible for defining its policy.

AppArmor hook provided by John Johansen <john.johansen@canonical.com>
SELinux hook provided by Stephen Smalley <stephen.smalley.work@gmail.com>

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: Kees Cook <keescook@chromium.org>
Cc: Stephen Smalley <stephen.smalley.work@gmail.com>
Cc: Paul Moore <paul@paul-moore.com>
Cc: John Johansen <john.johansen@canonical.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Cc: linux-api@vger.kernel.org
Cc: linux-doc@vger.kernel.org
---
 .../ABI/testing/procfs-attr-lsm_display       |  22 +++
 Documentation/security/lsm.rst                |  14 ++
 fs/proc/base.c                                |   1 +
 include/linux/security.h                      |  17 ++
 security/apparmor/include/apparmor.h          |   3 +-
 security/apparmor/lsm.c                       |  32 ++++
 security/security.c                           | 166 ++++++++++++++++--
 security/selinux/hooks.c                      |  11 ++
 security/selinux/include/classmap.h           |   2 +-
 security/smack/smack_lsm.c                    |   7 +
 10 files changed, 256 insertions(+), 19 deletions(-)
 create mode 100644 Documentation/ABI/testing/procfs-attr-lsm_display

diff --git a/Documentation/ABI/testing/procfs-attr-lsm_display b/Documentation/ABI/testing/procfs-attr-lsm_display
new file mode 100644
index 000000000000..0f60005c235c
--- /dev/null
+++ b/Documentation/ABI/testing/procfs-attr-lsm_display
@@ -0,0 +1,22 @@
+What:		/proc/*/attr/lsm_display
+Contact:	linux-security-module@vger.kernel.org,
+Description:	The name of the Linux security module (LSM) that will
+		provide information in the /proc/*/attr/current,
+		/proc/*/attr/prev and /proc/*/attr/exec interfaces.
+		The details of permissions required to read from
+		this interface are dependent on the LSMs active on the
+		system.
+		A process cannot write to this interface unless it
+		refers to itself.
+		The other details of permissions required to write to
+		this interface are dependent on the LSMs active on the
+		system.
+		The format of the data used by this interface is a
+		text string identifying the name of an LSM. The values
+		accepted are:
+			selinux		- the SELinux LSM
+			smack		- the Smack LSM
+			apparmor	- The AppArmor LSM
+		By convention the LSM names are lower case and do not
+		contain special characters.
+Users:		LSM user-space
diff --git a/Documentation/security/lsm.rst b/Documentation/security/lsm.rst
index 6a2a2e973080..b77b4a540391 100644
--- a/Documentation/security/lsm.rst
+++ b/Documentation/security/lsm.rst
@@ -129,3 +129,17 @@ to identify it as the first security module to be registered.
 The capabilities security module does not use the general security
 blobs, unlike other modules. The reasons are historical and are
 based on overhead, complexity and performance concerns.
+
+LSM External Interfaces
+=======================
+
+The LSM infrastructure does not generally provide external interfaces.
+The individual security modules provide what external interfaces they
+require.
+
+The file ``/sys/kernel/security/lsm`` provides a comma
+separated list of the active security modules.
+
+The file ``/proc/pid/attr/interface_lsm`` contains the name of the security
+module for which the ``/proc/pid/attr/current`` interface will
+apply. This interface can be written to.
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 13eda8de2998..50dbe5612a26 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -2828,6 +2828,7 @@ static const struct pid_entry attr_dir_stuff[] = {
 	ATTR(NULL, "fscreate",		0666),
 	ATTR(NULL, "keycreate",		0666),
 	ATTR(NULL, "sockcreate",	0666),
+	ATTR(NULL, "interface_lsm",	0666),
 #ifdef CONFIG_SECURITY_SMACK
 	DIR("smack",			0555,
 	    proc_smack_attr_dir_inode_ops, proc_smack_attr_dir_ops),
diff --git a/include/linux/security.h b/include/linux/security.h
index 5271b2f4dfca..1b82590a6a59 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -219,6 +219,23 @@ static inline u32 lsmblob_value(const struct lsmblob *blob)
 	return 0;
 }

+/**
+ * lsm_task_ilsm - the "interface_lsm" for this task
+ * @task: The task to report on
+ *
+ * Returns the task's interface LSM slot.
+ */
+static inline int lsm_task_ilsm(struct task_struct *task)
+{
+#ifdef CONFIG_SECURITY
+	int *ilsm = task->security;
+
+	if (ilsm)
+		return *ilsm;
+#endif
+	return LSMBLOB_INVALID;
+}
+
 /* These functions are in security/commoncap.c */
 extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
 		       int cap, unsigned int opts);
diff --git a/security/apparmor/include/apparmor.h b/security/apparmor/include/apparmor.h
index 1fbabdb565a8..b1622fcb4394 100644
--- a/security/apparmor/include/apparmor.h
+++ b/security/apparmor/include/apparmor.h
@@ -28,8 +28,9 @@
 #define AA_CLASS_SIGNAL		10
 #define AA_CLASS_NET		14
 #define AA_CLASS_LABEL		16
+#define AA_CLASS_DISPLAY_LSM	17

-#define AA_CLASS_LAST		AA_CLASS_LABEL
+#define AA_CLASS_LAST		AA_CLASS_DISPLAY_LSM

 /* Control parameters settable through module/boot flags */
 extern enum audit_mode aa_g_audit;
diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c
index 24241db8ec54..5ed40fd93ce9 100644
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -621,6 +621,25 @@ static int apparmor_getprocattr(struct task_struct *task, char *name,
 	return error;
 }

+
+static int profile_interface_lsm(struct aa_profile *profile,
+				 struct common_audit_data *sa)
+{
+	struct aa_perms perms = { };
+	unsigned int state;
+
+	state = PROFILE_MEDIATES(profile, AA_CLASS_DISPLAY_LSM);
+	if (state) {
+		aa_compute_perms(profile->policy.dfa, state, &perms);
+		aa_apply_modes_to_perms(profile, &perms);
+		aad(sa)->label = &profile->label;
+
+		return aa_check_perms(profile, &perms, AA_MAY_WRITE, sa, NULL);
+	}
+
+	return 0;
+}
+
 static int apparmor_setprocattr(const char *name, void *value,
 				size_t size)
 {
@@ -632,6 +651,19 @@ static int apparmor_setprocattr(const char *name, void *value,
 	if (size == 0)
 		return -EINVAL;

+	/* LSM infrastructure does actual setting of interface_lsm if allowed */
+	if (!strcmp(name, "interface_lsm")) {
+		struct aa_profile *profile;
+		struct aa_label *label;
+
+		aad(&sa)->info = "set interface lsm";
+		label = begin_current_label_crit_section();
+		error = fn_for_each_confined(label, profile,
+					profile_interface_lsm(profile, &sa));
+		end_current_label_crit_section(label);
+		return error;
+	}
+
 	/* AppArmor requires that the buffer must be null terminated atm */
 	if (args[size - 1] != '\0') {
 		/* null terminate */
diff --git a/security/security.c b/security/security.c
index f7af2444fcc3..cfd75659e7e6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -78,7 +78,16 @@ static struct kmem_cache *lsm_file_cache;
 static struct kmem_cache *lsm_inode_cache;

 char *lsm_names;
-static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;
+
+/*
+ * The task blob includes the "interface_lsm" slot used for
+ * chosing which module presents contexts.
+ * Using a long to avoid potential alignment issues with
+ * module assigned task blobs.
+ */
+static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init = {
+	.lbs_task = sizeof(long),
+};

 /* Boot-time LSM user choice */
 static __initdata const char *chosen_lsm_order;
@@ -672,6 +681,8 @@ int lsm_inode_alloc(struct inode *inode)
  */
 static int lsm_task_alloc(struct task_struct *task)
 {
+	int *ilsm;
+
 	if (blob_sizes.lbs_task == 0) {
 		task->security = NULL;
 		return 0;
@@ -680,6 +691,15 @@ static int lsm_task_alloc(struct task_struct *task)
 	task->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);
 	if (task->security == NULL)
 		return -ENOMEM;
+
+	/*
+	 * The start of the task blob contains the "interface" LSM slot number.
+	 * Start with it set to the invalid slot number, indicating that the
+	 * default first registered LSM be displayed.
+	 */
+	ilsm = task->security;
+	*ilsm = LSMBLOB_INVALID;
+
 	return 0;
 }

@@ -1736,14 +1756,26 @@ int security_file_open(struct file *file)

 int security_task_alloc(struct task_struct *task, unsigned long clone_flags)
 {
+	int *oilsm = current->security;
+	int *nilsm;
 	int rc = lsm_task_alloc(task);

-	if (rc)
+	if (unlikely(rc))
 		return rc;
+
 	rc = call_int_hook(task_alloc, 0, task, clone_flags);
-	if (unlikely(rc))
+	if (unlikely(rc)) {
 		security_task_free(task);
-	return rc;
+		return rc;
+	}
+
+	if (oilsm) {
+		nilsm = task->security;
+		if (nilsm)
+			*nilsm = *oilsm;
+	}
+
+	return 0;
 }

 void security_task_free(struct task_struct *task)
@@ -2175,23 +2207,110 @@ int security_getprocattr(struct task_struct *p, const char *lsm, char *name,
 				char **value)
 {
 	struct security_hook_list *hp;
+	int ilsm = lsm_task_ilsm(current);
+	int slot = 0;
+
+	if (!strcmp(name, "interface_lsm")) {
+		/*
+		 * lsm_slot will be 0 if there are no displaying modules.
+		 */
+		if (lsm_slot == 0)
+			return -EINVAL;
+
+		/*
+		 * Only allow getting the current process' interface_lsm.
+		 * There are too few reasons to get another process'
+		 * interface_lsm and too many LSM policy issues.
+		 */
+		if (current != p)
+			return -EINVAL;
+
+		ilsm = lsm_task_ilsm(p);
+		if (ilsm != LSMBLOB_INVALID)
+			slot = ilsm;
+		*value = kstrdup(lsm_slotlist[slot]->lsm, GFP_KERNEL);
+		if (*value)
+			return strlen(*value);
+		return -ENOMEM;
+	}

 	hlist_for_each_entry(hp, &security_hook_heads.getprocattr, list) {
 		if (lsm != NULL && strcmp(lsm, hp->lsmid->lsm))
 			continue;
+		if (lsm == NULL && ilsm != LSMBLOB_INVALID &&
+		    ilsm != hp->lsmid->slot)
+			continue;
 		return hp->hook.getprocattr(p, name, value);
 	}
 	return LSM_RET_DEFAULT(getprocattr);
 }

+/**
+ * security_setprocattr - Set process attributes via /proc
+ * @lsm: name of module involved, or NULL
+ * @name: name of the attribute
+ * @value: value to set the attribute to
+ * @size: size of the value
+ *
+ * Set the process attribute for the specified security module
+ * to the specified value. Note that this can only be used to set
+ * the process attributes for the current, or "self" process.
+ * The /proc code has already done this check.
+ *
+ * Returns 0 on success, an appropriate code otherwise.
+ */
 int security_setprocattr(const char *lsm, const char *name, void *value,
 			 size_t size)
 {
 	struct security_hook_list *hp;
+	char *termed;
+	char *copy;
+	int *ilsm = current->security;
+	int rc = -EINVAL;
+	int slot = 0;
+
+	if (!strcmp(name, "interface_lsm")) {
+		/*
+		 * Change the "interface_lsm" value only if all the security
+		 * modules that support setting a procattr allow it.
+		 * It is assumed that all such security modules will be
+		 * cooperative.
+		 */
+		if (size == 0)
+			return -EINVAL;
+
+		hlist_for_each_entry(hp, &security_hook_heads.setprocattr,
+				     list) {
+			rc = hp->hook.setprocattr(name, value, size);
+			if (rc < 0)
+				return rc;
+		}
+
+		rc = -EINVAL;
+
+		copy = kmemdup_nul(value, size, GFP_KERNEL);
+		if (copy == NULL)
+			return -ENOMEM;
+
+		termed = strsep(&copy, " \n");
+
+		for (slot = 0; slot < lsm_slot; slot++)
+			if (!strcmp(termed, lsm_slotlist[slot]->lsm)) {
+				*ilsm = lsm_slotlist[slot]->slot;
+				rc = size;
+				break;
+			}
+
+		kfree(termed);
+		return rc;
+	}

 	hlist_for_each_entry(hp, &security_hook_heads.setprocattr, list) {
 		if (lsm != NULL && strcmp(lsm, hp->lsmid->lsm))
 			continue;
+		if (lsm == NULL && *ilsm != LSMBLOB_INVALID &&
+		    *ilsm != hp->lsmid->slot)
+			continue;
 		return hp->hook.setprocattr(name, value, size);
 	}
 	return LSM_RET_DEFAULT(setprocattr);
@@ -2211,15 +2330,15 @@ EXPORT_SYMBOL(security_ismaclabel);
 int security_secid_to_secctx(struct lsmblob *blob, char **secdata, u32 *seclen)
 {
 	struct security_hook_list *hp;
-	int rc;
+	int ilsm = lsm_task_ilsm(current);

 	hlist_for_each_entry(hp, &security_hook_heads.secid_to_secctx, list) {
 		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
 			continue;
-		rc = hp->hook.secid_to_secctx(blob->secid[hp->lsmid->slot],
-					      secdata, seclen);
-		if (rc != LSM_RET_DEFAULT(secid_to_secctx))
-			return rc;
+		if (ilsm == LSMBLOB_INVALID || ilsm == hp->lsmid->slot)
+			return hp->hook.secid_to_secctx(
+					blob->secid[hp->lsmid->slot],
+					secdata, seclen);
 	}

 	return LSM_RET_DEFAULT(secid_to_secctx);
@@ -2230,16 +2349,15 @@ int security_secctx_to_secid(const char *secdata, u32 seclen,
 			     struct lsmblob *blob)
 {
 	struct security_hook_list *hp;
-	int rc;
+	int ilsm = lsm_task_ilsm(current);

 	lsmblob_init(blob, 0);
 	hlist_for_each_entry(hp, &security_hook_heads.secctx_to_secid, list) {
 		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
 			continue;
-		rc = hp->hook.secctx_to_secid(secdata, seclen,
-					      &blob->secid[hp->lsmid->slot]);
-		if (rc != 0)
-			return rc;
+		if (ilsm == LSMBLOB_INVALID || ilsm == hp->lsmid->slot)
+			return hp->hook.secctx_to_secid(secdata, seclen,
+						&blob->secid[hp->lsmid->slot]);
 	}
 	return 0;
 }
@@ -2247,7 +2365,14 @@ EXPORT_SYMBOL(security_secctx_to_secid);

 void security_release_secctx(char *secdata, u32 seclen)
 {
-	call_void_hook(release_secctx, secdata, seclen);
+	struct security_hook_list *hp;
+	int ilsm = lsm_task_ilsm(current);
+
+	hlist_for_each_entry(hp, &security_hook_heads.release_secctx, list)
+		if (ilsm == LSMBLOB_INVALID || ilsm == hp->lsmid->slot) {
+			hp->hook.release_secctx(secdata, seclen);
+			return;
+		}
 }
 EXPORT_SYMBOL(security_release_secctx);

@@ -2388,8 +2513,15 @@ EXPORT_SYMBOL(security_sock_rcv_skb);
 int security_socket_getpeersec_stream(struct socket *sock, char __user *optval,
 				      int __user *optlen, unsigned len)
 {
-	return call_int_hook(socket_getpeersec_stream, -ENOPROTOOPT, sock,
-				optval, optlen, len);
+	int ilsm = lsm_task_ilsm(current);
+	struct security_hook_list *hp;
+
+	hlist_for_each_entry(hp, &security_hook_heads.socket_getpeersec_stream,
+			     list)
+		if (ilsm == LSMBLOB_INVALID || ilsm == hp->lsmid->slot)
+			return hp->hook.socket_getpeersec_stream(sock, optval,
+								 optlen, len);
+	return -ENOPROTOOPT;
 }

 int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb,
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index c295b1035bc6..824a6e4fb126 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -6441,6 +6441,17 @@ static int selinux_setprocattr(const char *name, void *value, size_t size)
 	/*
 	 * Basic control over ability to set these attributes at all.
 	 */
+
+	/*
+	 * For setting interface_lsm, we only perform a permission check;
+	 * the actual update to the interface_lsm value is handled by the
+	 * LSM framework.
+	 */
+	if (!strcmp(name, "interface_lsm"))
+		return avc_has_perm(&selinux_state,
+				    mysid, mysid, SECCLASS_PROCESS2,
+				    PROCESS2__SETDISPLAY, NULL);
+
 	if (!strcmp(name, "exec"))
 		error = avc_has_perm(&selinux_state,
 				     mysid, mysid, SECCLASS_PROCESS,
diff --git a/security/selinux/include/classmap.h b/security/selinux/include/classmap.h
index 35aac62a662e..46a7cfaf392d 100644
--- a/security/selinux/include/classmap.h
+++ b/security/selinux/include/classmap.h
@@ -53,7 +53,7 @@ struct security_class_mapping secclass_map[] = {
 	    "execmem", "execstack", "execheap", "setkeycreate",
 	    "setsockcreate", "getrlimit", NULL } },
 	{ "process2",
-	  { "nnp_transition", "nosuid_transition", NULL } },
+	  { "nnp_transition", "nosuid_transition", "setdisplay", NULL } },
 	{ "system",
 	  { "ipc_info", "syslog_read", "syslog_mod",
 	    "syslog_console", "module_request", "module_load", NULL } },
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index 9c44327d8ea7..1069ba7abf40 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -3517,6 +3517,13 @@ static int smack_setprocattr(const char *name, void *value, size_t size)
 	struct smack_known_list_elem *sklep;
 	int rc;

+	/*
+	 * Allow the /proc/.../attr/current and SO_PEERSEC "interface_lsm"
+	 * to be reset at will.
+	 */
+	if (strcmp(name, "interface_lsm") == 0)
+		return 0;
+
 	if (!smack_privileged(CAP_MAC_ADMIN) && list_empty(&tsp->smk_relabel))
 		return -EPERM;

--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 00CA3C433EF
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:00:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239749AbhKXCDV (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:03:21 -0500
Received: from sonic302-26.consmr.mail.ne1.yahoo.com ([66.163.186.152]:32986
        "EHLO sonic302-26.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S239734AbhKXCDU (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:03:20 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719211; bh=LIR7IJw8T+x6DrfrqDIrkMhlikVn9ymWzPpYTj2lKKo=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=aJWKq8VebWEYg/PkaK5WlyaGiDVAQ7NYD7eoGAocsdoyz4Hzr2dhyjOyp7OdO1dX62ePmsDcLmMZ5x1/rEoRp2PndA9ZHs2PjH4FRX4AcdDeiqVDpTsIZsfHMHugOQS3wI4WLpxxOvUbvFhxf3Zv+xhIzZW+675RgPNjpH760736AlLDBkYk3R7e2MKJ22TnsS7cBDW7CVjLVqFSs/KA62CkUEYpgUyQSTsvdueUTZ1D6dHwgqdGazGhMhFiQs6EeobGM4gzXsPGxgwGqzdgbPbmKEbXBPk8mHEZ8i/Mrz8H9IcuOfTWLXP+ewSsSHgADpwybpY645/rjQY19nV1iA==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719211; bh=34Msmpgwye2XlUVHBKdPvOxepkEtgZbJlkYOHboI9pZ=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=r6CcbetnsMJ/WAyaQgzH4eNxvpMgLCno5BQSnAHNOejSOylOiNfvef9ZQoAx/y/e3Dlqbqtp6lkUs8tfEJCt8AkT5eAMpDLOOjXX2ZSTbPaMpXeomPDoXit9pf/Xhp9b3S0zdlUCVNSMxIcqg61HcwqdBAFhschj0XCLsH7n+Dp8N3X0fE5N182KSYbNOST7cdchS/9exm7a8Lmp2nsYRPRyyTqLqlxlT+bmPXyKv03mwQCazkornfA/6A4b9htICJq7OBSR1+z8MGtNS3Z29oGc3QRld+8gNUqrfAAUwj40ihjX6ogD0Dc9hAbIYMVIUPn7Kz21zrSXgIX1jH98Og==
X-YMail-OSG: bH3grpYVM1lwnuS2O_8A1C6_Vhp5jVacAcKYtMrw56uCDzhDYTSIOQFIhcaaMM7
 BSimMPY_rhL9DQq8_oPBs0HQL_njN9hP.oRRS6i7EynqUwSqSs33.uQZp1DZBJwvRC4G3buCV31q
 F6c0wK8ksKG1PZV8O.a2F.ZEoFxaVSsRrfujYSqhcJsTrYtmZjhB4jNf9Pmr7WRYpNa9LWqjyWLG
 5fTjQKENmPfPAchFNhVe19oHGQoFvVXeQLrN8rGgCyupEvMQUjV1Jbv.yfu7gL_CZ6nJXiDUP_JX
 8Ys.vAYTy1X4p7FLCUR6HFvZpnI7C5Z8xMc_ZjHgs7RmxrEar5LJ6e5gALoLi0w1xQx1d1shG0rB
 Rf6Q_ZrgdFu5N6RHQW3vruhl3ENCLe_ZxMud8XO35A_TqGinJtDa43O.OUaM2zEaj0Q2nk30Pzhu
 TzoqoWSM.Bmq6JT2oJxkbNNxOETK0ycSwcDIXj9Z5Mak5OFFuCP2O4j74wE3hpBlkYpboj7W8G1.
 1kX1HNjBIbDCa_2KDoTHxga8bfQKExz3LojS5Ohbx2EqmMWHvYNVP6zbpdBh4TJAqnnYnKWWH5sT
 g2a17AxC9KjfquTjuHzRJAW_dvodRyzb.oew1HKrc4CALuNOubXJk3dgy_9bHmoqYHqqFtM9cGFG
 Cz4HLBuWw2Rwf4HFCcKhsoO63m0zszsFy.7tpSZzo1_DuU4G_._.rAhm0Ub4j7v3MnOpTPpgGRkw
 ZRZpxN3TSWmfljPIM3GVeRYfUxzfC8K3fHmiED7K1kElN8uyfkjCwc6EhRiUoECDZqHBljB0jHoc
 fpnl4ZkEQmSD4.j5lPVRezjtQVRY99u_F2sZYHhoNFviRnx0DRGvN74HRbslGa.tL1ZES438lC36
 xkXnkO6BCBiUb2KVDSDHSOt3hC3v77_jFbzWVCB_Mo27hqZTbvmt5bacxW_4HXL.7v.P4HulTMet
 6w6DdqgOE.RS.3aFjbyqgu7.Fu72WQZxuNNfeU.NGnLmU0e3psMw3NfgpIOsCmZupHcoWE74f.EY
 fAupJrptNnpNr9.8SjHB8nmxdNZ80KlTGIR0NV1ULJjeN5cUOK_co43ozo7FvgTTynjnBMBOCAsM
 0XPZLUlx8niCKk7ZeO10lfkIwNykBzxTCVa717OYi72VG4HTYEtnDtwNAh85vF.rQWHFeK8xmwkx
 OXqDaiClPM2vba5jCvOps_b6M_Al9kd_fonzvGUiS19mezkSQfOmIskj6AtO1m2jBlaeefLa5nuY
 Qp13W6snhtuLqXCM1MvKO49RLlQrH42W73JIjmqXyyjgsAcZFhzzBJG8Ki1MthFbUr5Xg75EbrL2
 TE0OXW0.gOUdojZwtposZj2DXH0aVhngN2riICZBa7UiI5yQSQUQ3y.ydgNCW6r4i69TPBH.ufR7
 _TJ6D2iUOXL5to3wCBKl5aLDkOq1hMduQ9Mb8wlZYTdqI7AppM424couMIMuJ1Qqbwmd.Ve34UUy
 vT9Dxrjw7lPH6obO3OgQQ9VV5oWGz1i1I4jiOC5f6mbxCODPLO6WGYYNc.eeGUUL._vwMjRa4tyq
 UbNGXvar92kIa1oOxW6XQxuAnPR1noofW_Q_yMioRnw0qT1ycI_LpuGYplflYWlXpgoNxRfbgIOH
 hwBDiZgKIVQowA4WnRmy58V1uv.NtlAZ1ryPnzHfw1HfpmSlQs8PyysDyRx0ymhHVSrVwYAB8Xcd
 KLqrvi4xnpVPk2DHpKMA7K5u7pbG1GBTe_NL._L9GQuVGem7WcJJoNEjoy5c1nzZHiLVeWqMZal2
 Rl4LrSRfLsZn5hKLhXWarxu6X3CmEHUtzgk_ys2oEIg5.iD6t6KSFPvVbS5ooyyI1FNZBRV24g3r
 neO.XcrHv9pORakVznumv_d7uZ7EGOxrthY4.C9gKcaIdmO3LYJVcMwjrTFEkp4JTGMPH.RSM2QC
 Jh56GWo6sCJ6VKZjMO418zfXt3IatTadw14G6OUt2kiK.QVBhfqsNaDufJy6SllLEW_4Ru8G3KKQ
 o8TJzdZpXyh5R0CMng0VwbN0TBc1EjcqNsSZNWHIPMqg8laBKyBZwAy547T59oKOEmVnQGODyqlN
 LmGcHVpVpu3aGVyNWtYXH6eQLO4wevPDaH2GWM5PxKzOTjXoV8MzA8Q_4jvlnLwFsrm35oB.tF7n
 _aZ8fQmYWjY6hGpadG5TTtqWFHL8Dowi1y0fJ5ubxgqqI.m0sPeX6Wn90q8vf8SHkb2CZFBQ5I0E
 KomiVh3lkdPuMHqqgglAVnEhJ2A2HYZJkE3ROJ37lwSoyv4myvGPDdFtXXNuT._SMnb9h1gplpRc
 ksHmO_XbADIIbtulHovbz5X.xCkA4w2JXhF_7.QT7sByAew--
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic302.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:00:11 +0000
Received: by kubenode542.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 71de488fbfe39b53bec47b0dde9f2e8e;
          Wed, 24 Nov 2021 02:00:07 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>,
        Chuck Lever <chuck.lever@oracle.com>,
        linux-integrity@vger.kernel.org, netdev@vger.kernel.org,
        netfilter-devel@vger.kernel.org, linux-nfs@vger.kernel.org
Subject: [PATCH v30 15/28] LSM: Ensure the correct LSM context releaser
Date:   Tue, 23 Nov 2021 17:43:19 -0800
Message-Id: <20211124014332.36128-16-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Add a new lsmcontext data structure to hold all the information
about a "security context", including the string, its size and
which LSM allocated the string. The allocation information is
necessary because LSMs have different policies regarding the
lifecycle of these strings. SELinux allocates and destroys
them on each use, whereas Smack provides a pointer to an entry
in a list that never goes away.

Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Chuck Lever <chuck.lever@oracle.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: linux-integrity@vger.kernel.org
Cc: netdev@vger.kernel.org
Cc: linux-audit@redhat.com
Cc: netfilter-devel@vger.kernel.org
To: Pablo Neira Ayuso <pablo@netfilter.org>
Cc: linux-nfs@vger.kernel.org
---
 drivers/android/binder.c                | 10 ++++---
 fs/ceph/xattr.c                         |  6 ++++-
 fs/nfs/nfs4proc.c                       |  8 ++++--
 fs/nfsd/nfs4xdr.c                       |  7 +++--
 include/linux/security.h                | 35 +++++++++++++++++++++++--
 include/net/scm.h                       |  5 +++-
 kernel/audit.c                          | 14 +++++++---
 kernel/auditsc.c                        | 12 ++++++---
 net/ipv4/ip_sockglue.c                  |  4 ++-
 net/netfilter/nf_conntrack_netlink.c    |  4 ++-
 net/netfilter/nf_conntrack_standalone.c |  4 ++-
 net/netfilter/nfnetlink_queue.c         | 13 ++++++---
 net/netlabel/netlabel_unlabeled.c       | 19 +++++++++++---
 net/netlabel/netlabel_user.c            |  4 ++-
 security/security.c                     | 11 ++++----
 15 files changed, 121 insertions(+), 35 deletions(-)

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 2be77ae9ca52..de8f0661e8ec 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -2469,6 +2469,7 @@ static void binder_transaction(struct binder_proc *proc,
 	int t_debug_id = atomic_inc_return(&binder_last_id);
 	char *secctx = NULL;
 	u32 secctx_sz = 0;
+	struct lsmcontext scaff; /* scaffolding */

 	e = binder_transaction_log_add(&binder_transaction_log);
 	e->debug_id = t_debug_id;
@@ -2771,7 +2772,8 @@ static void binder_transaction(struct binder_proc *proc,
 			t->security_ctx = 0;
 			WARN_ON(1);
 		}
-		security_release_secctx(secctx, secctx_sz);
+		lsmcontext_init(&scaff, secctx, secctx_sz, 0);
+		security_release_secctx(&scaff);
 		secctx = NULL;
 	}
 	t->buffer->debug_id = t->debug_id;
@@ -3112,8 +3114,10 @@ static void binder_transaction(struct binder_proc *proc,
 	binder_alloc_free_buf(&target_proc->alloc, t->buffer);
 err_binder_alloc_buf_failed:
 err_bad_extra_size:
-	if (secctx)
-		security_release_secctx(secctx, secctx_sz);
+	if (secctx) {
+		lsmcontext_init(&scaff, secctx, secctx_sz, 0);
+		security_release_secctx(&scaff);
+	}
 err_get_secctx_failed:
 	kfree(tcomplete);
 	binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
diff --git a/fs/ceph/xattr.c b/fs/ceph/xattr.c
index fcf7dfdecf96..df2b3bf46364 100644
--- a/fs/ceph/xattr.c
+++ b/fs/ceph/xattr.c
@@ -1374,12 +1374,16 @@ int ceph_security_init_secctx(struct dentry *dentry, umode_t mode,

 void ceph_release_acl_sec_ctx(struct ceph_acl_sec_ctx *as_ctx)
 {
+#ifdef CONFIG_CEPH_FS_SECURITY_LABEL
+	struct lsmcontext scaff; /* scaffolding */
+#endif
 #ifdef CONFIG_CEPH_FS_POSIX_ACL
 	posix_acl_release(as_ctx->acl);
 	posix_acl_release(as_ctx->default_acl);
 #endif
 #ifdef CONFIG_CEPH_FS_SECURITY_LABEL
-	security_release_secctx(as_ctx->sec_ctx, as_ctx->sec_ctxlen);
+	lsmcontext_init(&scaff, as_ctx->sec_ctx, as_ctx->sec_ctxlen, 0);
+	security_release_secctx(&scaff);
 #endif
 	if (as_ctx->pagelist)
 		ceph_pagelist_release(as_ctx->pagelist);
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index ee3bc79f6ca3..194bb09663e0 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -137,8 +137,12 @@ nfs4_label_init_security(struct inode *dir, struct dentry *dentry,
 static inline void
 nfs4_label_release_security(struct nfs4_label *label)
 {
-	if (label)
-		security_release_secctx(label->label, label->len);
+	struct lsmcontext scaff; /* scaffolding */
+
+	if (label) {
+		lsmcontext_init(&scaff, label->label, label->len, 0);
+		security_release_secctx(&scaff);
+	}
 }
 static inline u32 *nfs4_bitmask(struct nfs_server *server, struct nfs4_label *label)
 {
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index b2a1d969a172..89d50a7785d8 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -2844,6 +2844,7 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,
 	int err;
 	struct nfs4_acl *acl = NULL;
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
+	struct lsmcontext scaff; /* scaffolding */
 	void *context = NULL;
 	int contextlen;
 #endif
@@ -3345,8 +3346,10 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,

 out:
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
-	if (context)
-		security_release_secctx(context, contextlen);
+	if (context) {
+		lsmcontext_init(&scaff, context, contextlen, 0); /*scaffolding*/
+		security_release_secctx(&scaff);
+	}
 #endif /* CONFIG_NFSD_V4_SECURITY_LABEL */
 	kfree(acl);
 	if (tempfh) {
diff --git a/include/linux/security.h b/include/linux/security.h
index 1b82590a6a59..0760cf52dbfd 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -135,6 +135,37 @@ enum lockdown_reason {

 extern const char *const lockdown_reasons[LOCKDOWN_CONFIDENTIALITY_MAX+1];

+/*
+ * A "security context" is the text representation of
+ * the information used by LSMs.
+ * This structure contains the string, its length, and which LSM
+ * it is useful for.
+ */
+struct lsmcontext {
+	char	*context;	/* Provided by the module */
+	u32	len;
+	int	slot;		/* Identifies the module */
+};
+
+/**
+ * lsmcontext_init - initialize an lsmcontext structure.
+ * @cp: Pointer to the context to initialize
+ * @context: Initial context, or NULL
+ * @size: Size of context, or 0
+ * @slot: Which LSM provided the context
+ *
+ * Fill in the lsmcontext from the provided information.
+ * This is a scaffolding function that will be removed when
+ * lsmcontext integration is complete.
+ */
+static inline void lsmcontext_init(struct lsmcontext *cp, char *context,
+				   u32 size, int slot)
+{
+	cp->slot = slot;
+	cp->context = context;
+	cp->len = size;
+}
+
 /*
  * Data exported by the security modules
  *
@@ -570,7 +601,7 @@ int security_ismaclabel(const char *name);
 int security_secid_to_secctx(struct lsmblob *blob, char **secdata, u32 *seclen);
 int security_secctx_to_secid(const char *secdata, u32 seclen,
 			     struct lsmblob *blob);
-void security_release_secctx(char *secdata, u32 seclen);
+void security_release_secctx(struct lsmcontext *cp);
 void security_inode_invalidate_secctx(struct inode *inode);
 int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen);
 int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen);
@@ -1440,7 +1471,7 @@ static inline int security_secctx_to_secid(const char *secdata,
 	return -EOPNOTSUPP;
 }

-static inline void security_release_secctx(char *secdata, u32 seclen)
+static inline void security_release_secctx(struct lsmcontext *cp)
 {
 }

diff --git a/include/net/scm.h b/include/net/scm.h
index 23a35ff1b3f2..f273c4d777ec 100644
--- a/include/net/scm.h
+++ b/include/net/scm.h
@@ -92,6 +92,7 @@ static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
 #ifdef CONFIG_SECURITY_NETWORK
 static inline void scm_passec(struct socket *sock, struct msghdr *msg, struct scm_cookie *scm)
 {
+	struct lsmcontext context;
 	struct lsmblob lb;
 	char *secdata;
 	u32 seclen;
@@ -106,7 +107,9 @@ static inline void scm_passec(struct socket *sock, struct msghdr *msg, struct sc

 		if (!err) {
 			put_cmsg(msg, SOL_SOCKET, SCM_SECURITY, seclen, secdata);
-			security_release_secctx(secdata, seclen);
+			/*scaffolding*/
+			lsmcontext_init(&context, secdata, seclen, 0);
+			security_release_secctx(&context);
 		}
 	}
 }
diff --git a/kernel/audit.c b/kernel/audit.c
index 8ec64e6e8bc0..c17ec23158c4 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -1192,6 +1192,7 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	struct audit_sig_info   *sig_data;
 	char			*ctx = NULL;
 	u32			len;
+	struct lsmcontext	scaff; /* scaffolding */

 	err = audit_netlink_ok(skb, msg_type);
 	if (err)
@@ -1449,15 +1450,18 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		}
 		sig_data = kmalloc(sizeof(*sig_data) + len, GFP_KERNEL);
 		if (!sig_data) {
-			if (lsmblob_is_set(&audit_sig_lsm))
-				security_release_secctx(ctx, len);
+			if (lsmblob_is_set(&audit_sig_lsm)) {
+				lsmcontext_init(&scaff, ctx, len, 0);
+				security_release_secctx(&scaff);
+			}
 			return -ENOMEM;
 		}
 		sig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);
 		sig_data->pid = audit_sig_pid;
 		if (lsmblob_is_set(&audit_sig_lsm)) {
 			memcpy(sig_data->ctx, ctx, len);
-			security_release_secctx(ctx, len);
+			lsmcontext_init(&scaff, ctx, len, 0);
+			security_release_secctx(&scaff);
 		}
 		audit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,
 				 sig_data, sizeof(*sig_data) + len);
@@ -2132,6 +2136,7 @@ int audit_log_task_context(struct audit_buffer *ab)
 	unsigned len;
 	int error;
 	struct lsmblob blob;
+	struct lsmcontext scaff; /* scaffolding */

 	security_task_getsecid_subj(current, &blob);
 	if (!lsmblob_is_set(&blob))
@@ -2145,7 +2150,8 @@ int audit_log_task_context(struct audit_buffer *ab)
 	}

 	audit_log_format(ab, " subj=%s", ctx);
-	security_release_secctx(ctx, len);
+	lsmcontext_init(&scaff, ctx, len, 0);
+	security_release_secctx(&scaff);
 	return 0;

 error_path:
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index 7d256fb2ec03..efd1a2a4216e 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -1112,6 +1112,7 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 				 struct lsmblob *blob, char *comm)
 {
 	struct audit_buffer *ab;
+	struct lsmcontext lsmcxt;
 	char *ctx = NULL;
 	u32 len;
 	int rc = 0;
@@ -1129,7 +1130,8 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 			rc = 1;
 		} else {
 			audit_log_format(ab, " obj=%s", ctx);
-			security_release_secctx(ctx, len);
+			lsmcontext_init(&lsmcxt, ctx, len, 0); /*scaffolding*/
+			security_release_secctx(&lsmcxt);
 		}
 	}
 	audit_log_format(ab, " ocomm=");
@@ -1342,6 +1344,7 @@ static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)

 static void show_special(struct audit_context *context, int *call_panic)
 {
+	struct lsmcontext lsmcxt;
 	struct audit_buffer *ab;
 	int i;

@@ -1376,7 +1379,8 @@ static void show_special(struct audit_context *context, int *call_panic)
 				*call_panic = 1;
 			} else {
 				audit_log_format(ab, " obj=%s", ctx);
-				security_release_secctx(ctx, len);
+				lsmcontext_init(&lsmcxt, ctx, len, 0);
+				security_release_secctx(&lsmcxt);
 			}
 		}
 		if (context->ipc.has_perm) {
@@ -1533,6 +1537,7 @@ static void audit_log_name(struct audit_context *context, struct audit_names *n,
 		char *ctx = NULL;
 		u32 len;
 		struct lsmblob blob;
+		struct lsmcontext lsmcxt;

 		lsmblob_init(&blob, n->osid);
 		if (security_secid_to_secctx(&blob, &ctx, &len)) {
@@ -1541,7 +1546,8 @@ static void audit_log_name(struct audit_context *context, struct audit_names *n,
 				*call_panic = 2;
 		} else {
 			audit_log_format(ab, " obj=%s", ctx);
-			security_release_secctx(ctx, len);
+			lsmcontext_init(&lsmcxt, ctx, len, 0); /* scaffolding */
+			security_release_secctx(&lsmcxt);
 		}
 	}

diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index be7073df19a5..dbba700fb151 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -130,6 +130,7 @@ static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,

 static void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)
 {
+	struct lsmcontext context;
 	struct lsmblob lb;
 	char *secdata;
 	u32 seclen, secid;
@@ -145,7 +146,8 @@ static void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)
 		return;

 	put_cmsg(msg, SOL_IP, SCM_SECURITY, seclen, secdata);
-	security_release_secctx(secdata, seclen);
+	lsmcontext_init(&context, secdata, seclen, 0); /* scaffolding */
+	security_release_secctx(&context);
 }

 static void ip_cmsg_recv_dstaddr(struct msghdr *msg, struct sk_buff *skb)
diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
index daf554915e07..de223234963d 100644
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -342,6 +342,7 @@ static int ctnetlink_dump_secctx(struct sk_buff *skb, const struct nf_conn *ct)
 	int len, ret;
 	char *secctx;
 	struct lsmblob blob;
+	struct lsmcontext context;

 	/* lsmblob_init() puts ct->secmark into all of the secids in blob.
 	 * security_secid_to_secctx() will know which security module
@@ -362,7 +363,8 @@ static int ctnetlink_dump_secctx(struct sk_buff *skb, const struct nf_conn *ct)

 	ret = 0;
 nla_put_failure:
-	security_release_secctx(secctx, len);
+	lsmcontext_init(&context, secctx, len, 0); /* scaffolding */
+	security_release_secctx(&context);
 	return ret;
 }
 #else
diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index 79c280d1efce..3fcf44342b14 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -179,6 +179,7 @@ static void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)
 	u32 len;
 	char *secctx;
 	struct lsmblob blob;
+	struct lsmcontext context;

 	lsmblob_init(&blob, ct->secmark);
 	ret = security_secid_to_secctx(&blob, &secctx, &len);
@@ -187,7 +188,8 @@ static void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)

 	seq_printf(s, "secctx=%s ", secctx);

-	security_release_secctx(secctx, len);
+	lsmcontext_init(&context, secctx, len, 0); /* scaffolding */
+	security_release_secctx(&context);
 }
 #else
 static inline void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)
diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c
index 62c0c5b847c6..5961a9b17f66 100644
--- a/net/netfilter/nfnetlink_queue.c
+++ b/net/netfilter/nfnetlink_queue.c
@@ -397,6 +397,7 @@ nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,
 	enum ip_conntrack_info ctinfo;
 	struct nfnl_ct_hook *nfnl_ct;
 	bool csum_verify;
+	struct lsmcontext scaff; /* scaffolding */
 	char *secdata = NULL;
 	u32 seclen = 0;

@@ -626,8 +627,10 @@ nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,
 	}

 	nlh->nlmsg_len = skb->len;
-	if (seclen)
-		security_release_secctx(secdata, seclen);
+	if (seclen) {
+		lsmcontext_init(&scaff, secdata, seclen, 0);
+		security_release_secctx(&scaff);
+	}
 	return skb;

 nla_put_failure:
@@ -635,8 +638,10 @@ nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,
 	kfree_skb(skb);
 	net_err_ratelimited("nf_queue: error creating packet message\n");
 nlmsg_failure:
-	if (seclen)
-		security_release_secctx(secdata, seclen);
+	if (seclen) {
+		lsmcontext_init(&scaff, secdata, seclen, 0);
+		security_release_secctx(&scaff);
+	}
 	return NULL;
 }

diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 15b53fc4e83f..7cb6f27c8cb2 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -374,6 +374,7 @@ int netlbl_unlhsh_add(struct net *net,
 	struct net_device *dev;
 	struct netlbl_unlhsh_iface *iface;
 	struct audit_buffer *audit_buf = NULL;
+	struct lsmcontext context;
 	char *secctx = NULL;
 	u32 secctx_len;
 	struct lsmblob blob;
@@ -447,7 +448,9 @@ int netlbl_unlhsh_add(struct net *net,
 					     &secctx,
 					     &secctx_len) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s", secctx);
-			security_release_secctx(secctx, secctx_len);
+			/* scaffolding */
+			lsmcontext_init(&context, secctx, secctx_len, 0);
+			security_release_secctx(&context);
 		}
 		audit_log_format(audit_buf, " res=%u", ret_val == 0 ? 1 : 0);
 		audit_log_end(audit_buf);
@@ -478,6 +481,7 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 	struct netlbl_unlhsh_addr4 *entry;
 	struct audit_buffer *audit_buf;
 	struct net_device *dev;
+	struct lsmcontext context;
 	char *secctx;
 	u32 secctx_len;
 	struct lsmblob blob;
@@ -508,7 +512,9 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 		    security_secid_to_secctx(&blob,
 					     &secctx, &secctx_len) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s", secctx);
-			security_release_secctx(secctx, secctx_len);
+			/* scaffolding */
+			lsmcontext_init(&context, secctx, secctx_len, 0);
+			security_release_secctx(&context);
 		}
 		audit_log_format(audit_buf, " res=%u", entry != NULL ? 1 : 0);
 		audit_log_end(audit_buf);
@@ -545,6 +551,7 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 	struct netlbl_unlhsh_addr6 *entry;
 	struct audit_buffer *audit_buf;
 	struct net_device *dev;
+	struct lsmcontext context;
 	char *secctx;
 	u32 secctx_len;
 	struct lsmblob blob;
@@ -574,7 +581,8 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 		    security_secid_to_secctx(&blob,
 					     &secctx, &secctx_len) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s", secctx);
-			security_release_secctx(secctx, secctx_len);
+			lsmcontext_init(&context, secctx, secctx_len, 0);
+			security_release_secctx(&context);
 		}
 		audit_log_format(audit_buf, " res=%u", entry != NULL ? 1 : 0);
 		audit_log_end(audit_buf);
@@ -1093,6 +1101,7 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 	int ret_val = -ENOMEM;
 	struct netlbl_unlhsh_walk_arg *cb_arg = arg;
 	struct net_device *dev;
+	struct lsmcontext context;
 	void *data;
 	u32 secid;
 	char *secctx;
@@ -1163,7 +1172,9 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 			  NLBL_UNLABEL_A_SECCTX,
 			  secctx_len,
 			  secctx);
-	security_release_secctx(secctx, secctx_len);
+	/* scaffolding */
+	lsmcontext_init(&context, secctx, secctx_len, 0);
+	security_release_secctx(&context);
 	if (ret_val != 0)
 		goto list_cb_failure;

diff --git a/net/netlabel/netlabel_user.c b/net/netlabel/netlabel_user.c
index 893301ae0131..ef139d8ae7cd 100644
--- a/net/netlabel/netlabel_user.c
+++ b/net/netlabel/netlabel_user.c
@@ -84,6 +84,7 @@ struct audit_buffer *netlbl_audit_start_common(int type,
 					       struct netlbl_audit *audit_info)
 {
 	struct audit_buffer *audit_buf;
+	struct lsmcontext context;
 	char *secctx;
 	u32 secctx_len;
 	struct lsmblob blob;
@@ -103,7 +104,8 @@ struct audit_buffer *netlbl_audit_start_common(int type,
 	if (audit_info->secid != 0 &&
 	    security_secid_to_secctx(&blob, &secctx, &secctx_len) == 0) {
 		audit_log_format(audit_buf, " subj=%s", secctx);
-		security_release_secctx(secctx, secctx_len);
+		lsmcontext_init(&context, secctx, secctx_len, 0);/*scaffolding*/
+		security_release_secctx(&context);
 	}

 	return audit_buf;
diff --git a/security/security.c b/security/security.c
index cfd75659e7e6..5e6d088d94fb 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2363,16 +2363,17 @@ int security_secctx_to_secid(const char *secdata, u32 seclen,
 }
 EXPORT_SYMBOL(security_secctx_to_secid);

-void security_release_secctx(char *secdata, u32 seclen)
+void security_release_secctx(struct lsmcontext *cp)
 {
 	struct security_hook_list *hp;
-	int ilsm = lsm_task_ilsm(current);

 	hlist_for_each_entry(hp, &security_hook_heads.release_secctx, list)
-		if (ilsm == LSMBLOB_INVALID || ilsm == hp->lsmid->slot) {
-			hp->hook.release_secctx(secdata, seclen);
-			return;
+		if (cp->slot == hp->lsmid->slot) {
+			hp->hook.release_secctx(cp->context, cp->len);
+			break;
 		}
+
+	memset(cp, 0, sizeof(*cp));
 }
 EXPORT_SYMBOL(security_release_secctx);

--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 189BAC4321E
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:01:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239900AbhKXCE1 (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:04:27 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:46057
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S229675AbhKXCEZ (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:04:25 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719276; bh=FOpEW3CNmazvtueemopZkXizWcFpSROpROYQ8oXZjDo=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=WE4tZ0pdgh+Vth11BQRrTT9Qc3H0tHzcQg1H9l3+ynz3zPQTIMDGfCnc1xuGw1fBMRdMBnpZZHpfRUfjPWtFzzp0ZDPSxzS/6wOAUxdeR7BT1zk30ANhoDwYACR3vfSq+yD534ynn3SB5B2yI8adZ203o78cs/Arij6olu2/0ez2t0ti2YpiVOc5zmppBbDIU/PRa7BYeed7l9K/nUx7qiARC9WneLyqqUGu8zMscvpUjnzbGRdhQNa7AVWF1wrMZ/4bleKIrxuhCrDC95Zf4UQwhL+aFY6wDabF760lwXH5uqulIBItoFEnhkb9KYABghPAcn2aNKWIN8unFScMxw==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719276; bh=NS41o0yHTgCqYO6lZHa1NY3GgliMezAgBT9vPBjGB15=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=YrCV6Wa88toPnU+WdsPH88UeUthbJRA3/YgRx2W5RChyDkqXMsqqT27u2tHiQ5oM0dhUMle7fhR9bu8UL0sTIePmxJZkv46YFdneo7Cp3FKDsa9UdMWnCQeWVq374YmZ2RKDCyrMFJD4xGJI1nCZTHFWguK8nICZ7Q/x2OP5As4R+fP4CxdbPjvXrudwYvsffWbxVSW7NgfYe7E9rHZ/Ac6P9HninJevt/ZsYyDJAn3g2qJfTTsQYc8Helg2JEdB2DMJKYOG1L5lDyBXBFET6JKwQE/RiH+i6xfV/zJlwDZfRpuudNr61CetOMgL7TIdwzh9Y9MyWPEgL70St+ScMw==
X-YMail-OSG: RFIjt8MVM1lR4WNSyteV5GpDndIDAhSV2kcC3kDLcoe85lRW5J0k0ydaWU_NUCd
 iLhlkyE7sRNS2oELJ1rT1O.YyGZYSLLYPMOONQ1lX7o3DqMucZonmg2ZDe_xnJrVopObbz7cZN4x
 s9RULl5cYpCfCxTsxosOonhWCWv8T5yWQkcPQ3wfD85TM32q7V7gvm348dWK8WHZWq2qLpu6Wvaq
 wMi.EB4DZFTrL8sDzF8ztpSJq07IoQLfluks_un2XyGby_hzbuVn3_M0zhG1FbVEt6DIatAMO0L1
 If67I0J6fRBhg9zFD9shEC18gR8KQnP.Kfx7d3_uwWOiYxS96hXis9lnyKfiWLn7fFU2q6tBvmff
 HY4KvJf41ZluWqjJ81ZOyIqJrJMG48nRa363Vfhr1vv4ziKtCxYJh93FqyCq5HSX2.TxtEPVUTyl
 nlw76O.86q0WVvkChZZPZbC9c0Tg6m_4e6mhB0ysDNTHsS9lrdPLGfVFo8dAhriDB0I4KaKmX2xm
 9M0ZGDCq4Elf0.Q2gZmFmkc8PJeIxBZrVfKwMC60TjMr6KTVMyAQ.B.u5PkNd.CjcUp5MYO3Bgs4
 ZejH7CQGSVWz15ivx9N4phr_bn1NYyxnBehSatFv4YIwHbH7UDRN4_Srl89XIoNwTH.OoGkBWNtc
 IfZZZM7iMLuBo7ARjBUZ0vsEwUbi05asA.Q7i5DvtLS8_gKutGg.FTYpXKWmxjG8XegvdAClzTaL
 EygUykGW43EPv0tWSp5p1WdihB_V3OoHqi.hwxvJQAeiK_LP.5VzY8SpGtPdreLTqtazbJP465T3
 4_IUzh6C6I7M6Gsyr.N8.9.1uuQHVloJp.IinGhnhalvrb37zWjEu0uEAaNsU4Z3DUEfUbgDeYHj
 63l5vlQBZYv87sSo.7YDiar419TqQ38qsPlkd7ZKyt78KVMQxkKRO.aNrO2F4HgwmLbanz6IFGHi
 _sxQrubruzD1dYbif2e9.aFeqSZahMnB7u0LiyyK18jHaJ4uNsaaPgZNdpe54LV.EXjaXPpZxXxs
 xPEf86OCcJsWAB5cS_x1.ke1_OPArs4MIGMdyvh_0o7JFamYwOV0XEt5W3ZQPL74pJwQL5oKDBg2
 DHUqzuG9lrfjv4rc4XkoQRk8Rhl5ns36bifABFSOObmT3AIy_D2MAu6XZP2GOwouXtNrYVo9c0Rj
 q6DPfrLiGsD_xJ2bea3jDPYOj.BCJPKY.I5migAlKjnpfYMK_5FRu_h3zXEWIadYaViCW0SYh0ra
 yl0CsJzppk0d3SNX4iSHD7RxJOROAOe_Hj8ysqV.JwuTh_wg7Gu.XXzTt5Cj1JealfCYkazcB7M3
 LqvBfJAXRtFCKKGe9tNZJzmUxkeg1Wm65LvCB2bSrtkee2a.gJfZf8I7UpGvvRR8gpvm16HjyyHI
 mkmtH5lvsfqdWaUEX.yc08fmZ8xINC6B.boPL7FtvYwQFfBEDrgRepavQGQA4DGti1l412ezHP3G
 ZEVmuzv0kN31bC5eb9B8RHskTvn_E6O50Fbt_75.lCqb6pGMWJSudcTNO49T08mgLnBc20YGnbHn
 0Eys2rs_cdeGhtBeOSYD.ReqGDD_gygXRvfN48vfghEcBYfp19AKJBDMGYIy9GtKKdcVt.72FOnw
 9SlHJQhVNVI1iDswOUqWSlekGy.BzM77stBd0LhW56OOo99tH2yyedlbsRBHATKsDLslwYUzwZtB
 FvX8p6gFU6NnUi8dH_xtQouIgwMa0.cbLSPu3WJyle2GZg_aP0ZmgDwtYbhfkf6sSECfXzd_unlh
 YZ1l9MU4kJ5ptkgH.1ecnDdTg6zjWHFkMwDCxGKOe4QHFL9b3lrt5bdW_DBgZkZ0366sljh.q_xI
 niAcdTsAOk.fSZQ6cmtZQcB6XoqupAKde1NnHv_FBzHyw1IPWEP_g95zNaZQ38Px97omQeQxMIFZ
 sfdKjzho8iv2AvwWSUoAKbj4WJ0xQvTXQzPl2d.fE22O9FVDMHnGhraWttyosLOBzjwpIGsHV9Sk
 rLeZn.P5Ct0E2BMuX7MesLc12BywwUNa_66Pb0Xzg961XjHoJpA7w1Oh2fcWtUTwxGCRFQGdK8Qk
 FD7fqo4XC9fFM6N.9SMGTqdN6p8etPykLv2u.MPzoHDLXDjwFSRl.rWEHvCEijhH3sC6eYApXSxY
 _tn8vQTDl4FSZApP4kN7PEMvrbFkVys4xNXK3sS1SIr7w3Mf_35uHoaIwuliBmgtVVee2sGzWN3o
 wzLB3nlcd83Ez2OMc2BoDZSaaHEGS8iWjZtKpFy1if5bGrN_QvCkQKcxmRL5xPzqpfF4fpniYD1U
 GIq4p0IPD2Ro1hnW96pu6ZIt0c9E1jbKaEPqSNUsk33cWOg--
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:01:16 +0000
Received: by kubenode545.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID efb3932afd4625ce53ab6c7e61a36211;
          Wed, 24 Nov 2021 02:01:12 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>,
        netdev@vger.kernel.org, netfilter-devel@vger.kernel.org
Subject: [PATCH v30 16/28] LSM: Use lsmcontext in security_secid_to_secctx
Date:   Tue, 23 Nov 2021 17:43:20 -0800
Message-Id: <20211124014332.36128-17-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Replace the (secctx,seclen) pointer pair with a single
lsmcontext pointer to allow return of the LSM identifier
along with the context and context length. This allows
security_release_secctx() to know how to release the
context. Callers have been modified to use or save the
returned data from the new structure.

Reviewed-by: Kees Cook <keescook@chromium.org>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: netdev@vger.kernel.org
Cc: linux-audit@redhat.com
Cc: netfilter-devel@vger.kernel.org
---
 drivers/android/binder.c                | 26 +++++++---------
 include/linux/security.h                |  4 +--
 include/net/scm.h                       |  9 ++----
 kernel/audit.c                          | 39 +++++++++++-------------
 kernel/auditsc.c                        | 31 +++++++------------
 net/ipv4/ip_sockglue.c                  |  8 ++---
 net/netfilter/nf_conntrack_netlink.c    | 18 +++++------
 net/netfilter/nf_conntrack_standalone.c |  7 ++---
 net/netfilter/nfnetlink_queue.c         |  5 +++-
 net/netlabel/netlabel_unlabeled.c       | 40 ++++++++-----------------
 net/netlabel/netlabel_user.c            |  7 ++---
 security/security.c                     | 10 +++++--
 12 files changed, 81 insertions(+), 123 deletions(-)

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index de8f0661e8ec..caaee7f95514 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -2467,9 +2467,7 @@ static void binder_transaction(struct binder_proc *proc,
 	binder_size_t last_fixup_min_off = 0;
 	struct binder_context *context = proc->context;
 	int t_debug_id = atomic_inc_return(&binder_last_id);
-	char *secctx = NULL;
-	u32 secctx_sz = 0;
-	struct lsmcontext scaff; /* scaffolding */
+	struct lsmcontext lsmctx = { };

 	e = binder_transaction_log_add(&binder_transaction_log);
 	e->debug_id = t_debug_id;
@@ -2723,14 +2721,14 @@ static void binder_transaction(struct binder_proc *proc,
 		size_t added_size;

 		security_cred_getsecid(proc->cred, &blob);
-		ret = security_secid_to_secctx(&blob, &secctx, &secctx_sz);
+		ret = security_secid_to_secctx(&blob, &lsmctx);
 		if (ret) {
 			return_error = BR_FAILED_REPLY;
 			return_error_param = ret;
 			return_error_line = __LINE__;
 			goto err_get_secctx_failed;
 		}
-		added_size = ALIGN(secctx_sz, sizeof(u64));
+		added_size = ALIGN(lsmctx.len, sizeof(u64));
 		extra_buffers_size += added_size;
 		if (extra_buffers_size < added_size) {
 			/* integer overflow of extra_buffers_size */
@@ -2757,24 +2755,22 @@ static void binder_transaction(struct binder_proc *proc,
 		t->buffer = NULL;
 		goto err_binder_alloc_buf_failed;
 	}
-	if (secctx) {
+	if (lsmctx.context) {
 		int err;
 		size_t buf_offset = ALIGN(tr->data_size, sizeof(void *)) +
 				    ALIGN(tr->offsets_size, sizeof(void *)) +
 				    ALIGN(extra_buffers_size, sizeof(void *)) -
-				    ALIGN(secctx_sz, sizeof(u64));
+				    ALIGN(lsmctx.len, sizeof(u64));

 		t->security_ctx = (uintptr_t)t->buffer->user_data + buf_offset;
 		err = binder_alloc_copy_to_buffer(&target_proc->alloc,
 						  t->buffer, buf_offset,
-						  secctx, secctx_sz);
+						  lsmctx.context, lsmctx.len);
 		if (err) {
 			t->security_ctx = 0;
 			WARN_ON(1);
 		}
-		lsmcontext_init(&scaff, secctx, secctx_sz, 0);
-		security_release_secctx(&scaff);
-		secctx = NULL;
+		security_release_secctx(&lsmctx);
 	}
 	t->buffer->debug_id = t->debug_id;
 	t->buffer->transaction = t;
@@ -2831,7 +2827,7 @@ static void binder_transaction(struct binder_proc *proc,
 	off_end_offset = off_start_offset + tr->offsets_size;
 	sg_buf_offset = ALIGN(off_end_offset, sizeof(void *));
 	sg_buf_end_offset = sg_buf_offset + extra_buffers_size -
-		ALIGN(secctx_sz, sizeof(u64));
+		ALIGN(lsmctx.len, sizeof(u64));
 	off_min = 0;
 	for (buffer_offset = off_start_offset; buffer_offset < off_end_offset;
 	     buffer_offset += sizeof(binder_size_t)) {
@@ -3114,10 +3110,8 @@ static void binder_transaction(struct binder_proc *proc,
 	binder_alloc_free_buf(&target_proc->alloc, t->buffer);
 err_binder_alloc_buf_failed:
 err_bad_extra_size:
-	if (secctx) {
-		lsmcontext_init(&scaff, secctx, secctx_sz, 0);
-		security_release_secctx(&scaff);
-	}
+	if (lsmctx.context)
+		security_release_secctx(&lsmctx);
 err_get_secctx_failed:
 	kfree(tcomplete);
 	binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
diff --git a/include/linux/security.h b/include/linux/security.h
index 0760cf52dbfd..7d9a45bc5bdb 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -598,7 +598,7 @@ int security_setprocattr(const char *lsm, const char *name, void *value,
 			 size_t size);
 int security_netlink_send(struct sock *sk, struct sk_buff *skb);
 int security_ismaclabel(const char *name);
-int security_secid_to_secctx(struct lsmblob *blob, char **secdata, u32 *seclen);
+int security_secid_to_secctx(struct lsmblob *blob, struct lsmcontext *cp);
 int security_secctx_to_secid(const char *secdata, u32 seclen,
 			     struct lsmblob *blob);
 void security_release_secctx(struct lsmcontext *cp);
@@ -1459,7 +1459,7 @@ static inline int security_ismaclabel(const char *name)
 }

 static inline int security_secid_to_secctx(struct lsmblob *blob,
-					   char **secdata, u32 *seclen)
+					   struct lsmcontext *cp)
 {
 	return -EOPNOTSUPP;
 }
diff --git a/include/net/scm.h b/include/net/scm.h
index f273c4d777ec..b77a52f93389 100644
--- a/include/net/scm.h
+++ b/include/net/scm.h
@@ -94,8 +94,6 @@ static inline void scm_passec(struct socket *sock, struct msghdr *msg, struct sc
 {
 	struct lsmcontext context;
 	struct lsmblob lb;
-	char *secdata;
-	u32 seclen;
 	int err;

 	if (test_bit(SOCK_PASSSEC, &sock->flags)) {
@@ -103,12 +101,11 @@ static inline void scm_passec(struct socket *sock, struct msghdr *msg, struct sc
 		 * and the infrastructure will know which it is.
 		 */
 		lsmblob_init(&lb, scm->secid);
-		err = security_secid_to_secctx(&lb, &secdata, &seclen);
+		err = security_secid_to_secctx(&lb, &context);

 		if (!err) {
-			put_cmsg(msg, SOL_SOCKET, SCM_SECURITY, seclen, secdata);
-			/*scaffolding*/
-			lsmcontext_init(&context, secdata, seclen, 0);
+			put_cmsg(msg, SOL_SOCKET, SCM_SECURITY, context.len,
+				 context.context);
 			security_release_secctx(&context);
 		}
 	}
diff --git a/kernel/audit.c b/kernel/audit.c
index c17ec23158c4..841123390d41 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -1190,9 +1190,6 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	struct audit_buffer	*ab;
 	u16			msg_type = nlh->nlmsg_type;
 	struct audit_sig_info   *sig_data;
-	char			*ctx = NULL;
-	u32			len;
-	struct lsmcontext	scaff; /* scaffolding */

 	err = audit_netlink_ok(skb, msg_type);
 	if (err)
@@ -1440,33 +1437,34 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		kfree(new);
 		break;
 	}
-	case AUDIT_SIGNAL_INFO:
-		len = 0;
+	case AUDIT_SIGNAL_INFO: {
+		struct lsmcontext context = { };
+		int len = 0;
+
 		if (lsmblob_is_set(&audit_sig_lsm)) {
-			err = security_secid_to_secctx(&audit_sig_lsm, &ctx,
-						       &len);
+			err = security_secid_to_secctx(&audit_sig_lsm,
+						       &context);
 			if (err)
 				return err;
 		}
-		sig_data = kmalloc(sizeof(*sig_data) + len, GFP_KERNEL);
+		sig_data = kmalloc(sizeof(*sig_data) + context.len, GFP_KERNEL);
 		if (!sig_data) {
-			if (lsmblob_is_set(&audit_sig_lsm)) {
-				lsmcontext_init(&scaff, ctx, len, 0);
-				security_release_secctx(&scaff);
-			}
+			if (lsmblob_is_set(&audit_sig_lsm))
+				security_release_secctx(&context);
 			return -ENOMEM;
 		}
 		sig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);
 		sig_data->pid = audit_sig_pid;
 		if (lsmblob_is_set(&audit_sig_lsm)) {
-			memcpy(sig_data->ctx, ctx, len);
-			lsmcontext_init(&scaff, ctx, len, 0);
-			security_release_secctx(&scaff);
+			len = context.len;
+			memcpy(sig_data->ctx, context.context, len);
+			security_release_secctx(&context);
 		}
 		audit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,
 				 sig_data, sizeof(*sig_data) + len);
 		kfree(sig_data);
 		break;
+	}
 	case AUDIT_TTY_GET: {
 		struct audit_tty_status s;
 		unsigned int t;
@@ -2132,26 +2130,23 @@ void audit_log_key(struct audit_buffer *ab, char *key)

 int audit_log_task_context(struct audit_buffer *ab)
 {
-	char *ctx = NULL;
-	unsigned len;
 	int error;
 	struct lsmblob blob;
-	struct lsmcontext scaff; /* scaffolding */
+	struct lsmcontext context;

 	security_task_getsecid_subj(current, &blob);
 	if (!lsmblob_is_set(&blob))
 		return 0;

-	error = security_secid_to_secctx(&blob, &ctx, &len);
+	error = security_secid_to_secctx(&blob, &context);
 	if (error) {
 		if (error != -EINVAL)
 			goto error_path;
 		return 0;
 	}

-	audit_log_format(ab, " subj=%s", ctx);
-	lsmcontext_init(&scaff, ctx, len, 0);
-	security_release_secctx(&scaff);
+	audit_log_format(ab, " subj=%s", context.context);
+	security_release_secctx(&context);
 	return 0;

 error_path:
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index efd1a2a4216e..bdb368382e5d 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -1112,9 +1112,7 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 				 struct lsmblob *blob, char *comm)
 {
 	struct audit_buffer *ab;
-	struct lsmcontext lsmcxt;
-	char *ctx = NULL;
-	u32 len;
+	struct lsmcontext lsmctx;
 	int rc = 0;

 	ab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);
@@ -1125,13 +1123,12 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 			 from_kuid(&init_user_ns, auid),
 			 from_kuid(&init_user_ns, uid), sessionid);
 	if (lsmblob_is_set(blob)) {
-		if (security_secid_to_secctx(blob, &ctx, &len)) {
+		if (security_secid_to_secctx(blob, &lsmctx)) {
 			audit_log_format(ab, " obj=(none)");
 			rc = 1;
 		} else {
-			audit_log_format(ab, " obj=%s", ctx);
-			lsmcontext_init(&lsmcxt, ctx, len, 0); /*scaffolding*/
-			security_release_secctx(&lsmcxt);
+			audit_log_format(ab, " obj=%s", lsmctx.context);
+			security_release_secctx(&lsmctx);
 		}
 	}
 	audit_log_format(ab, " ocomm=");
@@ -1344,7 +1341,6 @@ static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)

 static void show_special(struct audit_context *context, int *call_panic)
 {
-	struct lsmcontext lsmcxt;
 	struct audit_buffer *ab;
 	int i;

@@ -1369,17 +1365,15 @@ static void show_special(struct audit_context *context, int *call_panic)
 				 from_kgid(&init_user_ns, context->ipc.gid),
 				 context->ipc.mode);
 		if (osid) {
-			char *ctx = NULL;
-			u32 len;
+			struct lsmcontext lsmcxt;
 			struct lsmblob blob;

 			lsmblob_init(&blob, osid);
-			if (security_secid_to_secctx(&blob, &ctx, &len)) {
+			if (security_secid_to_secctx(&blob, &lsmcxt)) {
 				audit_log_format(ab, " osid=%u", osid);
 				*call_panic = 1;
 			} else {
-				audit_log_format(ab, " obj=%s", ctx);
-				lsmcontext_init(&lsmcxt, ctx, len, 0);
+				audit_log_format(ab, " obj=%s", lsmcxt.context);
 				security_release_secctx(&lsmcxt);
 			}
 		}
@@ -1534,20 +1528,17 @@ static void audit_log_name(struct audit_context *context, struct audit_names *n,
 				 MAJOR(n->rdev),
 				 MINOR(n->rdev));
 	if (n->osid != 0) {
-		char *ctx = NULL;
-		u32 len;
 		struct lsmblob blob;
-		struct lsmcontext lsmcxt;
+		struct lsmcontext lsmctx;

 		lsmblob_init(&blob, n->osid);
-		if (security_secid_to_secctx(&blob, &ctx, &len)) {
+		if (security_secid_to_secctx(&blob, &lsmctx)) {
 			audit_log_format(ab, " osid=%u", n->osid);
 			if (call_panic)
 				*call_panic = 2;
 		} else {
-			audit_log_format(ab, " obj=%s", ctx);
-			lsmcontext_init(&lsmcxt, ctx, len, 0); /* scaffolding */
-			security_release_secctx(&lsmcxt);
+			audit_log_format(ab, " obj=%s", lsmctx.context);
+			security_release_secctx(&lsmctx);
 		}
 	}

diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index dbba700fb151..47d1085e037e 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -132,8 +132,7 @@ static void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)
 {
 	struct lsmcontext context;
 	struct lsmblob lb;
-	char *secdata;
-	u32 seclen, secid;
+	u32 secid;
 	int err;

 	err = security_socket_getpeersec_dgram(NULL, skb, &secid);
@@ -141,12 +140,11 @@ static void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)
 		return;

 	lsmblob_init(&lb, secid);
-	err = security_secid_to_secctx(&lb, &secdata, &seclen);
+	err = security_secid_to_secctx(&lb, &context);
 	if (err)
 		return;

-	put_cmsg(msg, SOL_IP, SCM_SECURITY, seclen, secdata);
-	lsmcontext_init(&context, secdata, seclen, 0); /* scaffolding */
+	put_cmsg(msg, SOL_IP, SCM_SECURITY, context.len, context.context);
 	security_release_secctx(&context);
 }

diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
index de223234963d..0c3e1a8aaf2b 100644
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -339,8 +339,7 @@ static int ctnetlink_dump_mark(struct sk_buff *skb, const struct nf_conn *ct)
 static int ctnetlink_dump_secctx(struct sk_buff *skb, const struct nf_conn *ct)
 {
 	struct nlattr *nest_secctx;
-	int len, ret;
-	char *secctx;
+	int ret;
 	struct lsmblob blob;
 	struct lsmcontext context;

@@ -348,7 +347,7 @@ static int ctnetlink_dump_secctx(struct sk_buff *skb, const struct nf_conn *ct)
 	 * security_secid_to_secctx() will know which security module
 	 * to use to create the secctx.  */
 	lsmblob_init(&blob, ct->secmark);
-	ret = security_secid_to_secctx(&blob, &secctx, &len);
+	ret = security_secid_to_secctx(&blob, &context);
 	if (ret)
 		return 0;

@@ -357,13 +356,12 @@ static int ctnetlink_dump_secctx(struct sk_buff *skb, const struct nf_conn *ct)
 	if (!nest_secctx)
 		goto nla_put_failure;

-	if (nla_put_string(skb, CTA_SECCTX_NAME, secctx))
+	if (nla_put_string(skb, CTA_SECCTX_NAME, context.context))
 		goto nla_put_failure;
 	nla_nest_end(skb, nest_secctx);

 	ret = 0;
 nla_put_failure:
-	lsmcontext_init(&context, secctx, len, 0); /* scaffolding */
 	security_release_secctx(&context);
 	return ret;
 }
@@ -658,15 +656,15 @@ static inline int ctnetlink_secctx_size(const struct nf_conn *ct)
 #ifdef CONFIG_NF_CONNTRACK_SECMARK
 	int len, ret;
 	struct lsmblob blob;
+	struct lsmcontext context;

-	/* lsmblob_init() puts ct->secmark into all of the secids in blob.
-	 * security_secid_to_secctx() will know which security module
-	 * to use to create the secctx.  */
-	lsmblob_init(&blob, ct->secmark);
-	ret = security_secid_to_secctx(&blob, NULL, &len);
+	ret = security_secid_to_secctx(&blob, &context);
 	if (ret)
 		return 0;

+	len = context.len;
+	security_release_secctx(&context);
+
 	return nla_total_size(0) /* CTA_SECCTX */
 	       + nla_total_size(sizeof(char) * len); /* CTA_SECCTX_NAME */
 #else
diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index 3fcf44342b14..c8825e89a21e 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -176,19 +176,16 @@ static void ct_seq_stop(struct seq_file *s, void *v)
 static void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)
 {
 	int ret;
-	u32 len;
-	char *secctx;
 	struct lsmblob blob;
 	struct lsmcontext context;

 	lsmblob_init(&blob, ct->secmark);
-	ret = security_secid_to_secctx(&blob, &secctx, &len);
+	ret = security_secid_to_secctx(&blob, &context);
 	if (ret)
 		return;

-	seq_printf(s, "secctx=%s ", secctx);
+	seq_printf(s, "secctx=%s ", context.context);

-	lsmcontext_init(&context, secctx, len, 0); /* scaffolding */
 	security_release_secctx(&context);
 }
 #else
diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c
index 5961a9b17f66..f19897b3cf39 100644
--- a/net/netfilter/nfnetlink_queue.c
+++ b/net/netfilter/nfnetlink_queue.c
@@ -306,6 +306,7 @@ static u32 nfqnl_get_sk_secctx(struct sk_buff *skb, char **secdata)
 	u32 seclen = 0;
 #if IS_ENABLED(CONFIG_NETWORK_SECMARK)
 	struct lsmblob blob;
+	struct lsmcontext context = { };

 	if (!skb || !sk_fullsock(skb->sk))
 		return 0;
@@ -317,10 +318,12 @@ static u32 nfqnl_get_sk_secctx(struct sk_buff *skb, char **secdata)
 		 * blob. security_secid_to_secctx() will know which security
 		 * module to use to create the secctx.  */
 		lsmblob_init(&blob, skb->secmark);
-		security_secid_to_secctx(&blob, secdata, &seclen);
+		security_secid_to_secctx(&blob, &context);
+		*secdata = context.context;
 	}

 	read_unlock_bh(&skb->sk->sk_callback_lock);
+	seclen = context.len;
 #endif
 	return seclen;
 }
diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 7cb6f27c8cb2..596a75814fbf 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -375,8 +375,6 @@ int netlbl_unlhsh_add(struct net *net,
 	struct netlbl_unlhsh_iface *iface;
 	struct audit_buffer *audit_buf = NULL;
 	struct lsmcontext context;
-	char *secctx = NULL;
-	u32 secctx_len;
 	struct lsmblob blob;

 	if (addr_len != sizeof(struct in_addr) &&
@@ -444,12 +442,9 @@ int netlbl_unlhsh_add(struct net *net,
 		 * security_secid_to_secctx() will know which security module
 		 * to use to create the secctx.  */
 		lsmblob_init(&blob, secid);
-		if (security_secid_to_secctx(&blob,
-					     &secctx,
-					     &secctx_len) == 0) {
-			audit_log_format(audit_buf, " sec_obj=%s", secctx);
-			/* scaffolding */
-			lsmcontext_init(&context, secctx, secctx_len, 0);
+		if (security_secid_to_secctx(&blob, &context) == 0) {
+			audit_log_format(audit_buf, " sec_obj=%s",
+					 context.context);
 			security_release_secctx(&context);
 		}
 		audit_log_format(audit_buf, " res=%u", ret_val == 0 ? 1 : 0);
@@ -482,8 +477,6 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 	struct audit_buffer *audit_buf;
 	struct net_device *dev;
 	struct lsmcontext context;
-	char *secctx;
-	u32 secctx_len;
 	struct lsmblob blob;

 	spin_lock(&netlbl_unlhsh_lock);
@@ -509,11 +502,9 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 		if (entry != NULL)
 			lsmblob_init(&blob, entry->secid);
 		if (entry != NULL &&
-		    security_secid_to_secctx(&blob,
-					     &secctx, &secctx_len) == 0) {
-			audit_log_format(audit_buf, " sec_obj=%s", secctx);
-			/* scaffolding */
-			lsmcontext_init(&context, secctx, secctx_len, 0);
+		    security_secid_to_secctx(&blob, &context) == 0) {
+			audit_log_format(audit_buf, " sec_obj=%s",
+					 context.context);
 			security_release_secctx(&context);
 		}
 		audit_log_format(audit_buf, " res=%u", entry != NULL ? 1 : 0);
@@ -552,8 +543,6 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 	struct audit_buffer *audit_buf;
 	struct net_device *dev;
 	struct lsmcontext context;
-	char *secctx;
-	u32 secctx_len;
 	struct lsmblob blob;

 	spin_lock(&netlbl_unlhsh_lock);
@@ -578,10 +567,9 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 		if (entry != NULL)
 			lsmblob_init(&blob, entry->secid);
 		if (entry != NULL &&
-		    security_secid_to_secctx(&blob,
-					     &secctx, &secctx_len) == 0) {
-			audit_log_format(audit_buf, " sec_obj=%s", secctx);
-			lsmcontext_init(&context, secctx, secctx_len, 0);
+		    security_secid_to_secctx(&blob, &context) == 0) {
+			audit_log_format(audit_buf, " sec_obj=%s",
+					 context.context);
 			security_release_secctx(&context);
 		}
 		audit_log_format(audit_buf, " res=%u", entry != NULL ? 1 : 0);
@@ -1104,8 +1092,6 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 	struct lsmcontext context;
 	void *data;
 	u32 secid;
-	char *secctx;
-	u32 secctx_len;
 	struct lsmblob blob;

 	data = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).portid,
@@ -1165,15 +1151,13 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 	 * security_secid_to_secctx() will know which security module
 	 * to use to create the secctx.  */
 	lsmblob_init(&blob, secid);
-	ret_val = security_secid_to_secctx(&blob, &secctx, &secctx_len);
+	ret_val = security_secid_to_secctx(&blob, &context);
 	if (ret_val != 0)
 		goto list_cb_failure;
 	ret_val = nla_put(cb_arg->skb,
 			  NLBL_UNLABEL_A_SECCTX,
-			  secctx_len,
-			  secctx);
-	/* scaffolding */
-	lsmcontext_init(&context, secctx, secctx_len, 0);
+			  context.len,
+			  context.context);
 	security_release_secctx(&context);
 	if (ret_val != 0)
 		goto list_cb_failure;
diff --git a/net/netlabel/netlabel_user.c b/net/netlabel/netlabel_user.c
index ef139d8ae7cd..951ba0639d20 100644
--- a/net/netlabel/netlabel_user.c
+++ b/net/netlabel/netlabel_user.c
@@ -85,8 +85,6 @@ struct audit_buffer *netlbl_audit_start_common(int type,
 {
 	struct audit_buffer *audit_buf;
 	struct lsmcontext context;
-	char *secctx;
-	u32 secctx_len;
 	struct lsmblob blob;

 	if (audit_enabled == AUDIT_OFF)
@@ -102,9 +100,8 @@ struct audit_buffer *netlbl_audit_start_common(int type,

 	lsmblob_init(&blob, audit_info->secid);
 	if (audit_info->secid != 0 &&
-	    security_secid_to_secctx(&blob, &secctx, &secctx_len) == 0) {
-		audit_log_format(audit_buf, " subj=%s", secctx);
-		lsmcontext_init(&context, secctx, secctx_len, 0);/*scaffolding*/
+	    security_secid_to_secctx(&blob, &context) == 0) {
+		audit_log_format(audit_buf, " subj=%s", context.context);
 		security_release_secctx(&context);
 	}

diff --git a/security/security.c b/security/security.c
index 5e6d088d94fb..989103ec9533 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2327,18 +2327,22 @@ int security_ismaclabel(const char *name)
 }
 EXPORT_SYMBOL(security_ismaclabel);

-int security_secid_to_secctx(struct lsmblob *blob, char **secdata, u32 *seclen)
+int security_secid_to_secctx(struct lsmblob *blob, struct lsmcontext *cp)
 {
 	struct security_hook_list *hp;
 	int ilsm = lsm_task_ilsm(current);

+	memset(cp, 0, sizeof(*cp));
+
 	hlist_for_each_entry(hp, &security_hook_heads.secid_to_secctx, list) {
 		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
 			continue;
-		if (ilsm == LSMBLOB_INVALID || ilsm == hp->lsmid->slot)
+		if (ilsm == LSMBLOB_INVALID || ilsm == hp->lsmid->slot) {
+			cp->slot = hp->lsmid->slot;
 			return hp->hook.secid_to_secctx(
 					blob->secid[hp->lsmid->slot],
-					secdata, seclen);
+					&cp->context, &cp->len);
+		}
 	}

 	return LSM_RET_DEFAULT(secid_to_secctx);
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 18DB3C433F5
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:02:28 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239965AbhKXCFf (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:05:35 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:39261
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S232132AbhKXCFa (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:05:30 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719341; bh=OHIUENr10+7RRA/KKA9Hs4E8hg8/mB4XUM7qW32AhuY=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=uaIrEQv/EOt02QeIHXcT0YJarSwAzX/0130gAI6KXlBQ2h8bzcIhTt+69+oSg6ygNwS2W4uQRkjU7fNUckQbDIHwqwq1I9IBf3eSeTJD4H3z0coSv0sRbqpea4q29p6C1JmcxJdea4rFT4Q0Jf+/HZ9wpScXsjsYc3CvNkbfYWAKrO7TcwMyOC1AOwX9+CXQK9mxWeW+IdDFRwIj0ZUKUmyCaZ3eVr7n4TtLe07fLUe9Y/OW0g51JLLMtZMqMeJuZnVLoQQbqRk4Z+cMlk8dhFJavNMWCUOGRJiN+gxZS/lu4uoTBJx0x78j5O7NvOkbP1w1z6fPALxNwhG2ECcyFg==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719341; bh=xX1jeZ9UhyP4Ggdt7wOmIp4tFrei6yagfluje3kqPyG=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=IruuJXSoLNXRZBFIr9GQl7p5ZJurAmdpwtoDBmf2Pj12HevyJlFabtKU5M3vhI+zu0BTkJR0XcE951fB/CSJT/2qrl5i3lU2qurQT1hps4tQQjF5scV/fkLXJ9wIf1MwUdK81+xde/HNSZl9ih5xGs4W/JtrJvi2a/sbYzXqrxpqZrzkZngVnC3yH9V26wyo+CtRQdljhJkHJwYe9z2FFWsJuimFaVS9IXbygA5utvQlS8X6QBIejEDYFgXfRUELG5jbcrEZN7l2IDJePpc2GOOjMjOrXTYdmAnbt0ubIB6nGww7wPflWMkaQzElvQpI50whm4CWKacnpSgV3f5JOw==
X-YMail-OSG: RzU8nKoVM1mVCOyyOEE2nZTWQODZBkIoUIUkFL14e5EmGYgX_fTSgy2Oipyw3X.
 D05nFcVRMrlPq1ySHPGBH0fWBUtAhSmPM2YBKu82DY_Ppr2y5vBLPC2_N.dpkaWCumCUzZQw9mKt
 5Nn2tpmnQjCai59l6Lae3m8U4sk0E5IQ4NrI7VWUog007rCizg8cI4c8NeJVfTNVvK9w9b2Eq8SW
 YZn_X6Dyz7SSZt0Otq1AsOcHS6KuLiVSuScTJKaklwvkqsq.RcwxIMuhM5LYmkLWjfSnYHGkG4GO
 7HfXgsOi1W1WOKtpclqLxYR5CYyyYRf7Nlp_w3gTCFV9EchNDNkyXkr0XzFIO9zzNTdWKbgdELb6
 7yg7Kn3XXaDzbIxCkmHQdXgxOMUld_HqnZYP_TyU4583uWgftM7Sk31MQqktRcDu7AxWpMhJw90f
 RxqZNldoR7pYYkNSd.Tv1Fd2E.hpSm5jjWMGQz1KEMSznxDF6azUW_dbxp1zoEP5OkE8Y1vyz05o
 uDXejf7bA3qjj70Wt9tK31LRa6RI8sP5pS.MoklzOT4ZYwy6QRzH1ETR5RXKToD4y_STX3a7wRIs
 liV9Fn29uuiaDKOTkoOwmQL_d2QLfD7dAMHW61Vbyip_l..YTmz0IPtYNmTWK6FELqsOk8jaDlTq
 0e4_2AENVKwekaQENeLUfrkRb76ogVN.32Fbinzb8bUJr9tz6WTWY0vP_ag8FkmeQEU9q.T1Q211
 gAPTA8mPs6Fwq2exCq8DG.9VPFHN8BTHctXMnGjU2ucY5ez6gYL8wQvoWsIfnMuq9nKPsK5kEy5v
 YdaqiUL08fI9tjK63f5a_Xs1Cc6RVGldjcaLWSIG_lETmhNN7VbvWGnwLWDrLqYEJ2pEVQzPVtTA
 mazLiZXoATrMX8y771FccwZ52igHnWqDIq8C30HXe5BQohmCJ8lxP1YIMuJzgjrIPZ.HB_AEch7Z
 dwT6Owcqt1GC9CVsDZX7DPmeNDU3Lmy9TPryZMFOhVJXiqqcN0ocVGyRtf1ycaWL9aa0BVRpkpSm
 s9ABVa8oAdUHwwTkQubsi5KzDasST._oHrZW0GRYwu5kQCSK54bcgzawpsnHAKhC9ozWXLzLChzy
 qWWS7NaaRcOIzcaeuK.OLRXzwP8iecSB05n1coFwHIZ0V.j8rHjjy9G2m25fTrCYYSVL2lS2D7fV
 4YSVtb3Lyp.X.MGlt.lJh_RCwzgKub...dX5_q9.WNvaGz5REVUmo7Mxu5sZzhOgReKfROgI51wb
 IHnsqcP4U_CuC2fqZ5QpNqVWXtnJHBQ4mf7KwdUCN51knW8V9AmeJb87BwaPeYCfj4FUZK6V0euU
 sj3Wh.NEp2qIpd6TJzfGR7rWX_PoTlB.V5K2BXCgbcUBJogMymnbHlWgouISqAlQdijhs0.Gcedf
 nYJM.mRD6i.zk2tfdoGCPYtLQ9GqNWNn3NNaTDvgjmON7TnQ52FV0veAmqGRYiqy3lsvs9ksssN1
 r1yMDrZgMotHoRWY0TVP5Fu.a.nbGkvX7fOeOBfpZPejpMpD.gQcU60.2B6srXhbOw2lj1iCWMJu
 zerZvwkNAyI3l.sAxamBc22S0lCsb5SyIVDN4AAuIb5jc1wZr_p4mrNs5hMgtrAqdvlO42PVrf8q
 JI.0vCC8KawsAhtaGkyIBf0Ig4ESngXKyk3C.EvFCruLHaZShVCKlhVpKYosWNjXRKW_wJ61Wdpm
 x7jmZvzSCfSvFCBnkCCHogH6ke3snvdZpAHfaYJSl524FGd7KUrARdu4vHJVCMH8xWrvba8PXw1c
 KrzGRKTkY0M1ON2jTWQum9iEo2jfHjXv9ilJXGfygSpDuL1q_hH6Bz0Era6qPXBN3RcnSekA.j3c
 dysAavGEI3.jj0aUjZYAprj4JpggZGAsOXWlsgVFzwkJS_6dfwTt3B.SLx_Um3VI.d87BCvCKbbd
 tz7eE4BrZt83.8w7lICopxZzS8bxwuu0Ty5S8pYkX2GqRn6qJQTX1HboAi1wF8t0HeaY1mBJBYrP
 pWG8PskZ8o7BYJMDPIITfWaq.x8FE63K_1VYX_xyZ2bPr_JD6Gy4DPjvbgDr2b_pE4tyxloCdVSw
 XhAtO2UAH3F_0WNmFTwZY66uWOhgYU5lXACR1m3mRo4Zgp1LFYvtPekdiBnscVPhQJfhtyeDZcx9
 nd9Y1fnRjCAPUT4BcCBrYbuBrgePRpKgCLqx8BLBYM0kYKeiu2zi92tEn36dqIw5rKSo3wdIFtWl
 IdeYW8YUmkaqubvpuIiULj0DOwnIzQ6Y1yvheYufEWJoQJiyOXwa_AQ0InYF9qZ2r23CzgCTEbbs
 olzefMptkB7B7hYin.lI-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:02:21 +0000
Received: by kubenode524.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID afc246db926b33130748a9cce0475ef5;
          Wed, 24 Nov 2021 02:02:18 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>,
        Chuck Lever <chuck.lever@oracle.com>, linux-nfs@vger.kernel.org
Subject: [PATCH v30 17/28] LSM: Use lsmcontext in security_inode_getsecctx
Date:   Tue, 23 Nov 2021 17:43:21 -0800
Message-Id: <20211124014332.36128-18-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Change the security_inode_getsecctx() interface to fill
a lsmcontext structure instead of data and length pointers.
This provides the information about which LSM created the
context so that security_release_secctx() can use the
correct hook.

Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Acked-by: Chuck Lever <chuck.lever@oracle.com>
Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: linux-nfs@vger.kernel.org
---
 fs/nfsd/nfs4xdr.c        | 23 +++++++++--------------
 include/linux/security.h |  5 +++--
 security/security.c      | 13 +++++++++++--
 3 files changed, 23 insertions(+), 18 deletions(-)

diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 89d50a7785d8..25e592b6ffd9 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -2727,11 +2727,11 @@ nfsd4_encode_layout_types(struct xdr_stream *xdr, u32 layout_types)
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
 static inline __be32
 nfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,
-			    void *context, int len)
+			    struct lsmcontext *context)
 {
 	__be32 *p;

-	p = xdr_reserve_space(xdr, len + 4 + 4 + 4);
+	p = xdr_reserve_space(xdr, context->len + 4 + 4 + 4);
 	if (!p)
 		return nfserr_resource;

@@ -2741,13 +2741,13 @@ nfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,
 	 */
 	*p++ = cpu_to_be32(0); /* lfs */
 	*p++ = cpu_to_be32(0); /* pi */
-	p = xdr_encode_opaque(p, context, len);
+	p = xdr_encode_opaque(p, context->context, context->len);
 	return 0;
 }
 #else
 static inline __be32
 nfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,
-			    void *context, int len)
+			    struct lsmcontext *context)
 { return 0; }
 #endif

@@ -2844,9 +2844,7 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,
 	int err;
 	struct nfs4_acl *acl = NULL;
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
-	struct lsmcontext scaff; /* scaffolding */
-	void *context = NULL;
-	int contextlen;
+	struct lsmcontext context = { };
 #endif
 	bool contextsupport = false;
 	struct nfsd4_compoundres *resp = rqstp->rq_resp;
@@ -2904,7 +2902,7 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,
 	     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {
 		if (exp->ex_flags & NFSEXP_SECURITY_LABEL)
 			err = security_inode_getsecctx(d_inode(dentry),
-						&context, &contextlen);
+						       &context);
 		else
 			err = -EOPNOTSUPP;
 		contextsupport = (err == 0);
@@ -3324,8 +3322,7 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,

 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
 	if (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {
-		status = nfsd4_encode_security_label(xdr, rqstp, context,
-								contextlen);
+		status = nfsd4_encode_security_label(xdr, rqstp, &context);
 		if (status)
 			goto out;
 	}
@@ -3346,10 +3343,8 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,

 out:
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
-	if (context) {
-		lsmcontext_init(&scaff, context, contextlen, 0); /*scaffolding*/
-		security_release_secctx(&scaff);
-	}
+	if (context.context)
+		security_release_secctx(&context);
 #endif /* CONFIG_NFSD_V4_SECURITY_LABEL */
 	kfree(acl);
 	if (tempfh) {
diff --git a/include/linux/security.h b/include/linux/security.h
index 7d9a45bc5bdb..a35618740b19 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -605,7 +605,7 @@ void security_release_secctx(struct lsmcontext *cp);
 void security_inode_invalidate_secctx(struct inode *inode);
 int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen);
 int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen);
-int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen);
+int security_inode_getsecctx(struct inode *inode, struct lsmcontext *cp);
 int security_locked_down(enum lockdown_reason what);
 #else /* CONFIG_SECURITY */

@@ -1487,7 +1487,8 @@ static inline int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32
 {
 	return -EOPNOTSUPP;
 }
-static inline int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)
+static inline int security_inode_getsecctx(struct inode *inode,
+					   struct lsmcontext *cp)
 {
 	return -EOPNOTSUPP;
 }
diff --git a/security/security.c b/security/security.c
index 989103ec9533..e776f71d126c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2399,9 +2399,18 @@ int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)
 }
 EXPORT_SYMBOL(security_inode_setsecctx);

-int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)
+int security_inode_getsecctx(struct inode *inode, struct lsmcontext *cp)
 {
-	return call_int_hook(inode_getsecctx, -EOPNOTSUPP, inode, ctx, ctxlen);
+	struct security_hook_list *hp;
+
+	memset(cp, 0, sizeof(*cp));
+
+	hlist_for_each_entry(hp, &security_hook_heads.inode_getsecctx, list) {
+		cp->slot = hp->lsmid->slot;
+		return hp->hook.inode_getsecctx(inode, (void **)&cp->context,
+						&cp->len);
+	}
+	return -EOPNOTSUPP;
 }
 EXPORT_SYMBOL(security_inode_getsecctx);

--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 4EC95C433EF
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:03:41 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239195AbhKXCGs (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:06:48 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:36029
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S229970AbhKXCGk (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:06:40 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719411; bh=IIKa//ZfOf9ldI+2RZhwihcRPJzmFh5O4/PZDXiqrxo=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=PmEsScGDT56QiN+Jy0pLLGWnyKN/gxJNzyhhd6aK3mRYlCg73q0c9rwol/PA/5QNmZZrs8OwZfgaO37mdxg0V4fjz15kfxwtcKEJDh+75IDWTyrTBO3u6hs9kxW5Z0vRtPMUcWMQKBiYTU5IyFpBkiT/58d4bWNAxWwPYnST3qR1gN5OP2IN77JU9xK1JxhBF7LHzY1G2Y9e0HuyLBd1RZwklhIWJOGv4hRald+W0e5RrWL81YGjPUbxSLNUoCPqxS9ERupUW2f65ctbSz30DYdtloPxOi2dvPO9//HihtPZ2Z2l6sNx48LQGfh3ebYCgjDKsJZDPI9M91ojIjpkXA==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719411; bh=Kk3ubQbKAXNodGGFZb4TOQ/XxT7hCHClgdl+jbCiNKf=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=hraTilyCEzf3Xz1/kMyToHIaVcszJP3eHqQjv2dQJ6YIKwHp7DffGV2AMA4yQSYZ7QN5ETsT8VowS4tdEbkh3++cYGFS9LFR4YMKWydNPlURkN8JUvzQ+jT94yHJB6oVSIvoxE/flx1ElvjiAihZ50VXZBUGU8hQt2kYzyPsNSHvYIrck1Jzdy2Y/GuPcBbGU1d5WOoA/FbeN6c8rFumUQ9dOJcCsJBEy50sOCS1ka1SVvYPbn81UZRMm3wz96MFXTbF22EqqDqpjFVCkcB7iyO+Hez6fYOVc7wOIdrDnL1+xkKuwt/mhOnCXhX7PjojQk2L3iJrGLgtAY384u/ktA==
X-YMail-OSG: xgUVGOkVM1nXHxEhPw3sY.j_OYRqsPJ_Huiuktw0vgRcbjLDak49Y_LL6lx24O0
 TSqN1kqHycB3BvTPaG7wX3RoKQy3FMuo82MJNTaitTth_VmKUIYsXOEfWQnLy0YJCPUh8I35jHfd
 J4ZVfuNqjumX_KtVFVb6NMpG7e7nLkdJtE0bkbKG2xvCKGgMNI9OfVjCtlGx_7mA1KshGe7x9vUE
 K.5.8ozChTGi._V87HIYJBr6vD8njc5eX1z6w15rFSTgETPuC8wpzLZZK0DPIwsBSVd_GC4xjZNj
 W1T.Y2kYFr6BLkPf0H31S_cpiUE88HlzAv.5jmm.cmbye.z95.HPsV17ANiBMxD1CnlJEM_R.z1u
 9csz7U54Fkqy9.7bdojv0i4hc8.EHOCvujS9.nnHngPkN7qdER1HoFMKCPjC_nAIKBYL3rWtpJyL
 zaEQEng0RQDUu0ViFd_EnqFDIHTHb8k_Wl.xvt4g.MrSbvLCVouSNkD9eeWA1szXUUlYuYs4Mj5z
 VpEOjsIn8PzkYEs6fM6X9MDeUUU_6gtKWn7P6rZfF975aK5EYOVXoxHXG56jGKZYGReRFK76C0h6
 Y0A2QqWJwOqHfn_naJe3HYTCWlx7qpT.7F.zB1zQfMZ4_vNGdTiuMyG2Osu5xpzoxXo6gmBYtZCY
 R35Y0pUwhKp4IWxAimSx3Da7ol_yiQT6WNwitJz5gX8kv_DwtWLJnSBeYe0pSiccJJeD5HxjOEM4
 1GdOYdV2BhRN1C1GgTBBx1JaFC7uHdgprTAbq7ndUWhugaF2ngRIISPP5zDFn_yB7DpoYvawXuuS
 .6IXhgOk.ANumooQJm3RQYwy9nrJb.lqWbNZ5BdsdTqUqO4o6I_0K6ko7wn39vQcJjN7HMJAZOBa
 QO5VtuIjSgmp2CkMpN2YJfP4KjOsjPqx2tehPWt3nAOEe0pTpDtqoW.UEZ5O0QS4XMx.oHmgkyxN
 PuC.UJbv6lC_8do6t5rCL.ZJJKyRfNtIJOVbo3PywFyQ98yHoCqEiaUnvw2zULc91TWJWrlMOhes
 CMWoEyc2tph.PfkOk54h215zmGpMdgvsWFbSM65cLtlv0yAhN8ze7_1ZTSlboKEYzGOGqBQ2PALM
 QqlO2WdmkocVV5eUd.e66rykwn_fggIuzayEN1zx8Np0V9ZXeVCqa8dFPO4TOKqqz6PavqCLmWyW
 M1fYpBAq4B1AOVUv1fex3xiRE798h_8PTSv2YpCLts3Q8WDLaiVnMqQ5cG3jj5PNUTXiaWyf8TW9
 51POf8kr7xElrzvntsRoUTX31lU0C4r6GvPqKeGV5BWUw__FBSPtDf_j7K_pdPE9.BBgigfr45s1
 bvOtgyGc46a.0AZxpeRBTSkwnbBkegjYTkqOzp0gsAYwuYcbgvDLVFEFKltqYBPw3Jk_2_RYfgkX
 ShIHrKXaj4TJr_hyHNfVwWNWCnX.2sH6ELK_Pmx4txwtq.bqofX_6SgzcSALI9_9w0NkgPP6WyMz
 cVfGlEF5M2s8qFu9g28jA_AT8pXN3ymunfJ45uAFS_tDg..0pfz46mv11CwtXFVH8RO3HfjrefeC
 gGKimdYrpfZ1FJaGVouF7VP_ZhOMMfixYrSZ.o.MLjae_0iAT3likas0bYQ5ucAfv8pqTgUE.YqP
 jYYzIKCGuT6FY0AZLhRRNEr1bg9mHbbj7dMNncrssaMCSrch7uaa1PefuGE9A2EnqI_sKGUx6tK4
 or7plbTstSE90mr08RwTRe1p26WRHpzwHUvQXGm34vNKNEX6ratDTSNLkKUs1Mg9yzFhf9qAoiAF
 nSLbW5KotBRfBcz85mXrU0vA6xD7ZN_gxn9XTjfQWa.umOmAvR9u2ap8Qb0snHSNtMED.eV.YvyH
 UPERgDFVmMELHa5MNQAY4IxXBHj6.rw34KC9J8XPK_s1ZPt7xdqAh1LERUk3ZNURtf0XpsTmHRUm
 0iMrqW6vI3ltV.EO4Xf1IVGVrLx6GV7d2KN8FYb.zPeqB7sBfknMNOS1xubHMgL2yASuqHf1zD_m
 Tk6dzvl_1uODOP2HIlavmCNclsLBn2QLsQ7TNE2USUWVzZxjZlrEpg3Uw_enI2kjkYfREXuG0QoH
 rkX3hhy5GqZyfsbx7nvh89jqVnEeC1sG.BD3Npdiuu5gliRGBQWH5nWmovj.cXaOmZKyxjP2hQlA
 2K5sB8oeIZLyDvEp4iYRq8mPvWWkA1URTR9AM1E0GYsoewADPKf3Bnj1IW1HugA0PxSwYaznr_Yd
 TQuh8jPbULIdvMCz4KduFd4Q0gEIgDszYxtGt9afKFtsiIXZ.p7TDvwDQNG72D74O5A--
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:03:31 +0000
Received: by kubenode514.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 6a5ec7ba15e43f08e83dd45ef02c9b3f;
          Wed, 24 Nov 2021 02:03:25 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>,
        Pablo Neira Ayuso <pablo@netfilter.org>,
        netdev@vger.kernel.org, netfilter-devel@vger.kernel.org
Subject: [PATCH v30 18/28] LSM: security_secid_to_secctx in netlink netfilter
Date:   Tue, 23 Nov 2021 17:43:22 -0800
Message-Id: <20211124014332.36128-19-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Change netlink netfilter interfaces to use lsmcontext
pointers, and remove scaffolding.

Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: netdev@vger.kernel.org
Cc: netfilter-devel@vger.kernel.org
---
 net/netfilter/nfnetlink_queue.c | 37 +++++++++++++--------------------
 1 file changed, 14 insertions(+), 23 deletions(-)

diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c
index f19897b3cf39..69343275c54b 100644
--- a/net/netfilter/nfnetlink_queue.c
+++ b/net/netfilter/nfnetlink_queue.c
@@ -301,15 +301,13 @@ static int nfqnl_put_sk_uidgid(struct sk_buff *skb, struct sock *sk)
 	return -1;
 }

-static u32 nfqnl_get_sk_secctx(struct sk_buff *skb, char **secdata)
+static void nfqnl_get_sk_secctx(struct sk_buff *skb, struct lsmcontext *context)
 {
-	u32 seclen = 0;
 #if IS_ENABLED(CONFIG_NETWORK_SECMARK)
 	struct lsmblob blob;
-	struct lsmcontext context = { };

 	if (!skb || !sk_fullsock(skb->sk))
-		return 0;
+		return;

 	read_lock_bh(&skb->sk->sk_callback_lock);

@@ -318,14 +316,12 @@ static u32 nfqnl_get_sk_secctx(struct sk_buff *skb, char **secdata)
 		 * blob. security_secid_to_secctx() will know which security
 		 * module to use to create the secctx.  */
 		lsmblob_init(&blob, skb->secmark);
-		security_secid_to_secctx(&blob, &context);
-		*secdata = context.context;
+		security_secid_to_secctx(&blob, context);
 	}

 	read_unlock_bh(&skb->sk->sk_callback_lock);
-	seclen = context.len;
 #endif
-	return seclen;
+	return;
 }

 static u32 nfqnl_get_bridge_size(struct nf_queue_entry *entry)
@@ -397,12 +393,10 @@ nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,
 	struct net_device *indev;
 	struct net_device *outdev;
 	struct nf_conn *ct = NULL;
+	struct lsmcontext context = { };
 	enum ip_conntrack_info ctinfo;
 	struct nfnl_ct_hook *nfnl_ct;
 	bool csum_verify;
-	struct lsmcontext scaff; /* scaffolding */
-	char *secdata = NULL;
-	u32 seclen = 0;

 	size = nlmsg_total_size(sizeof(struct nfgenmsg))
 		+ nla_total_size(sizeof(struct nfqnl_msg_packet_hdr))
@@ -470,9 +464,9 @@ nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,
 	}

 	if ((queue->flags & NFQA_CFG_F_SECCTX) && entskb->sk) {
-		seclen = nfqnl_get_sk_secctx(entskb, &secdata);
-		if (seclen)
-			size += nla_total_size(seclen);
+		nfqnl_get_sk_secctx(entskb, &context);
+		if (context.len)
+			size += nla_total_size(context.len);
 	}

 	skb = alloc_skb(size, GFP_ATOMIC);
@@ -602,7 +596,8 @@ nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,
 	    nfqnl_put_sk_uidgid(skb, entskb->sk) < 0)
 		goto nla_put_failure;

-	if (seclen && nla_put(skb, NFQA_SECCTX, seclen, secdata))
+	if (context.len &&
+	    nla_put(skb, NFQA_SECCTX, context.len, context.context))
 		goto nla_put_failure;

 	if (ct && nfnl_ct->build(skb, ct, ctinfo, NFQA_CT, NFQA_CT_INFO) < 0)
@@ -630,10 +625,8 @@ nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,
 	}

 	nlh->nlmsg_len = skb->len;
-	if (seclen) {
-		lsmcontext_init(&scaff, secdata, seclen, 0);
-		security_release_secctx(&scaff);
-	}
+	if (context.len)
+		security_release_secctx(&context);
 	return skb;

 nla_put_failure:
@@ -641,10 +634,8 @@ nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,
 	kfree_skb(skb);
 	net_err_ratelimited("nf_queue: error creating packet message\n");
 nlmsg_failure:
-	if (seclen) {
-		lsmcontext_init(&scaff, secdata, seclen, 0);
-		security_release_secctx(&scaff);
-	}
+	if (context.len)
+		security_release_secctx(&context);
 	return NULL;
 }

--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 82188C433FE
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:04:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239983AbhKXCHu (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:07:50 -0500
Received: from sonic315-27.consmr.mail.ne1.yahoo.com ([66.163.190.153]:35354
        "EHLO sonic315-27.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S229970AbhKXCHs (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:07:48 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719479; bh=GSurOhVzqUI/nNz8OcXYb0Mj9Kn5l034tUBurXhhR90=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=Na1mWuXxqZ8cQ5OD9m5SFvSzYbwAgUMhLnRVu+Wf8YEX02nyE2WmAJ5PsLWEmsxPZ2hS0K/4FxzCAVCjQKFQbUqolqwJzdOmv0mJB6W6VqBNK/Ec9mvQ/wAnH9+6UoaTqO79t48zlLOaT9v8+mDEZPmal7qMiWrCXTL7evv3Dg9fgUl2gA4H9P3ysqmVeiU/aH39rcWtONmus4tO0kOOsx8rzzLFVeEfxmVl9U10YRnOS9vlK3l3DCBJitKFSPI9R8oxlKVmTPKn/Mbe8jzopxt1/qqbz3T1ia6uJaPNORgeYXuIuiLsG9uu9kqsIpXvcxMXPckJWuD5qIV5bi+pJQ==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719479; bh=FUqBDfTbRK9yH2Zkoh3DN2W1e2z5uhxYPhqjBODTXJ7=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=WvJ9ZgZC9QAca1bB7AxtOPXfZgE9TV8gQ5oWZPTUmMmcZTQaF51N+zgPIJs8tjgCsb+trktgEhxUgODj+canPastV5pcgzJelUd92VvgpUoDPjXVWRrWJr86/n6GqTjgg6KukiDXDeZNQbmTziJ0ai25CkdUy6NPMSSFBXza+d7GF3tHctsgEIBq+iq8NEmr8ztS/YPQquW4aht42X2Q+xNJd3KT2I0XLo8yrbeGvd8SAjtxRsIYhZo9Z9T8AltgnopJtJ3vDUT1xVqZ1ljNQfmPiC3VTC+FuP8tKKThI4m3zRkoRBAqLkkHAnxFHehXJrlhk7/wcKDrWMjd6Z57kQ==
X-YMail-OSG: 7rpvYKwVM1nGyxjOi0wtE5ZPYlTo4jBVAie2oaAug4O8zHjASmyE.t29DC3mMgX
 Blsx5w616asMk.kxBkIFWvZ32CSRdYD5ObFy4iYG5MBMJN.r9V6y1Xc7ZOYIBuyQrWxnl_CS0Xk2
 z8pOrTju1gb3iyV6ZYD2846WshI3Fxwy7lINgSm9jMJgrx3HvAkAUJ6pspDwpIuJVaA1U0W3.6eX
 j2GxXlKYBCt6x97Ubxbm42e9yd.rhMD6wLZFIsz.GpzDbvCi5yUsHY7CEXdJH04OTd28K7I4qXar
 r1Ys9bmIl8MZfbk_X.jcqq4RpX_CodlpKIvyA5oBwmMbnjQhyuWwYaZMMrEuDe0k2M8h65GldJ2.
 vZxF4VAbVJKF0EdJr_qpu40C7W6JBGm006grwBf7.w57zNi_biSvQx8qU4rHHCZ6BxfLb3Ci0Mdk
 m7eo2c8QlOmSb5SXP23EPLFNcsmdQIy4cR37ZrJJvDT_vVGfK8WU_8D4vLd6vwbnFDp8iizVFql4
 MaRSodaIdaGgA1J1IPrM1jkNAJOgXISFleJAEyqgjzJnJn2UG__baxN_S.PqL2MxsBwODX4jRtco
 WnxuvLcfmd1DOEIZugvGBjriaddxYobJrbnYqLPk4hHRpMRpnu1jGJS8UxryE9OouKIjuenc0ha2
 WKLfGsXy2SgvQWqtlJ3VYxIiIAV72BKGtmFlxRSdJJ2JbYYf1TYRoWXTTAtFagNot_EKWJUQdEI_
 4Wv.zKHVYsujXD.PGkdBGUrKc8WzHxITZt8tEdFY6u.Cd6pVK045xhPsa0tk9jptaTqDCT6rEnaj
 6orCqULXH7oHyBueGwDI5.orXfGgyctKszT3EwcVGi30CGA1EGCzCvgbO0kpgUSI0dlPxU9IOmR3
 EB87QM3xJi5UftHv1U47qIcaJyUPlUf3d8AttShWijF0YZd7krls7e6z4xR64c6oWcpt0AZvLBic
 SQN9t2JnkvCwwYA95onpng8mpM9lv05xfRwoTrFGoUF0gU_oAZdsAbiIrImUTWEnPFie4nnlH_m8
 7z9.RdSJTLBRwquUEnn0qyAcVcOw9T3DyrvDpxxuYm2PGwMryF9QKeyERYTgMpUN9NddHAGEvDyI
 9yLTqzYR4zIWpDNVgMAXEc.tRYGI8RvSwkTYb8m5ZbIo3MHClUVvNrIjvQrnWooJ8FH4UPtmATnh
 iQp28IMloX37kNKxfHPORgV42mb2V3lzfF8i4n_rTb8ExrHeLp5KcQbMFulLrS5D3YB_wORO8dbz
 6sBpqdMBNad_ROIaC4NFemYhdBi3pA6GwupPosW10Nf_eeYYOHSd4BXnbSkIDhkLLklIbcEL3xid
 yr_fGV1XhXeJ4hYy4V82WGeKb_l7nXyn_jaHkeHaxsz5LgP3Y_CC9Z4sJpWIfeBjXLBJ_5EiZ.gE
 03p16bq1sUosgeoo92_Q8VEKTGxMR0_NE3BWYvw09wwnE0CsGkIr5UXJdyC_HGvXGK0OiMuZ1ahw
 nRvPSnTqrVbnIeJ2aYaUOv37n3aoLOqSVIU4xJucODo7EbK9WRw79FuScrwDH4Z0ZQA8JC_ysfaW
 zFCQF_eDE5BxsrJD24tBS17t3zd5nApjTok06EhblZaPuQMwzIj.nvW1yyDKtIGk9hTMvKAU6qRX
 rKdEP28pz_71fff6QwefJ0BI0oMv4ugEfusm0dW2JDojkbiuFavmiSmwaTZ4q8TPzQIRaNUvzW7s
 lc10rSlUgRZQ8v3hc4gkU.pGmvv419xIgCtUOoCMFrnOOoyxNplxk1T.mkd91vbzEsTnKNAa6Gvl
 OmR3ssXM2ejkuiq5rZK08K8FR4uCYFpIbYgIiaINMaZi1reTurDXBAeFxDsWXmbdDMddMaNubEgY
 VtPdopLeAscj0FtYNVq..IOqO4QCe6ShJeq3OL9HWgxdupGA7wzCaHNVPJB7V_FVrgj3GxhtaF6u
 jCqxx.b09YpPHjphVKhvlW0w896E5X0wsGY2PPeCCh8cCxdnBuhHS3H9j15.4YgXH90i3E9Yb4kx
 noR56FGliPEKHo_nHUfWQBMcudvEq4.HtFsNB9sXOhB52kGQHqgtEjiU1PNGxaxC45cOIYoprEi5
 QpIZEFs4QpNouwo9zurJosf1KG1.X3nTnFfEAGod9avENZF6evPbjlCbHKOM.zza.bNemu7N6YgT
 BaMGm7Syqg6JWUf.qRiF8rhdJ_h6u_ZxTeQ134GxXIZuhXF7srNi91wU2jlrMyWXIiQd9ASyTmQ1
 d89B2A1zyzdlQgm7VShtmTw0l3CaVLdQLXcToLsdToCLEuBnb_.TCYwqVGkaC63SDgErHR7.gH99
 eNTkvsgk79P3hjBcFztg-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic315.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:04:39 +0000
Received: by kubenode551.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID a5b8ecee55e7ad16fb8afdf394bffba9;
          Wed, 24 Nov 2021 02:04:33 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>,
        netdev@vger.kernel.org
Subject: [PATCH v30 19/28] NET: Store LSM netlabel data in a lsmblob
Date:   Tue, 23 Nov 2021 17:43:23 -0800
Message-Id: <20211124014332.36128-20-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Netlabel uses LSM interfaces requiring an lsmblob and
the internal storage is used to pass information between
these interfaces, so change the internal data from a secid
to a lsmblob. Update the netlabel interfaces and their
callers to accommodate the change. This requires that the
modules using netlabel use the lsm_id.slot to access the
correct secid when using netlabel.

Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: John Johansen <john.johansen@canonical.com>
Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: netdev@vger.kernel.org
---
 include/net/netlabel.h              |  8 +--
 net/ipv4/cipso_ipv4.c               | 26 ++++++----
 net/netlabel/netlabel_kapi.c        |  6 +--
 net/netlabel/netlabel_unlabeled.c   | 79 +++++++++--------------------
 net/netlabel/netlabel_unlabeled.h   |  2 +-
 security/selinux/hooks.c            |  2 +-
 security/selinux/include/security.h |  1 +
 security/selinux/netlabel.c         |  2 +-
 security/selinux/ss/services.c      |  4 +-
 security/smack/smack.h              |  1 +
 security/smack/smack_access.c       |  2 +-
 security/smack/smack_lsm.c          | 11 ++--
 security/smack/smackfs.c            | 10 ++--
 13 files changed, 68 insertions(+), 86 deletions(-)

diff --git a/include/net/netlabel.h b/include/net/netlabel.h
index 43ae50337685..73fc25b4042b 100644
--- a/include/net/netlabel.h
+++ b/include/net/netlabel.h
@@ -166,7 +166,7 @@ struct netlbl_lsm_catmap {
  * @attr.mls: MLS sensitivity label
  * @attr.mls.cat: MLS category bitmap
  * @attr.mls.lvl: MLS sensitivity level
- * @attr.secid: LSM specific secid token
+ * @attr.lsmblob: LSM specific data
  *
  * Description:
  * This structure is used to pass security attributes between NetLabel and the
@@ -201,7 +201,7 @@ struct netlbl_lsm_secattr {
 			struct netlbl_lsm_catmap *cat;
 			u32 lvl;
 		} mls;
-		u32 secid;
+		struct lsmblob lsmblob;
 	} attr;
 };

@@ -415,7 +415,7 @@ int netlbl_cfg_unlbl_static_add(struct net *net,
 				const void *addr,
 				const void *mask,
 				u16 family,
-				u32 secid,
+				struct lsmblob *lsmblob,
 				struct netlbl_audit *audit_info);
 int netlbl_cfg_unlbl_static_del(struct net *net,
 				const char *dev_name,
@@ -523,7 +523,7 @@ static inline int netlbl_cfg_unlbl_static_add(struct net *net,
 					      const void *addr,
 					      const void *mask,
 					      u16 family,
-					      u32 secid,
+					      struct lsmblob *lsmblob,
 					      struct netlbl_audit *audit_info)
 {
 	return -ENOSYS;
diff --git a/net/ipv4/cipso_ipv4.c b/net/ipv4/cipso_ipv4.c
index 62d5f99760aa..bb9c900da6b0 100644
--- a/net/ipv4/cipso_ipv4.c
+++ b/net/ipv4/cipso_ipv4.c
@@ -106,15 +106,17 @@ int cipso_v4_rbm_strictvalid = 1;
 /* Base length of the local tag (non-standard tag).
  *  Tag definition (may change between kernel versions)
  *
- * 0          8          16         24         32
- * +----------+----------+----------+----------+
- * | 10000000 | 00000110 | 32-bit secid value  |
- * +----------+----------+----------+----------+
- * | in (host byte order)|
- * +----------+----------+
- *
+ * 0          8          16                    16 + sizeof(struct lsmblob)
+ * +----------+----------+---------------------+
+ * | 10000000 | 00000110 | LSM blob data       |
+ * +----------+----------+---------------------+
+ *
+ * All secid and flag fields are in host byte order.
+ * The lsmblob structure size varies depending on which
+ * Linux security modules are built in the kernel.
+ * The data is opaque.
  */
-#define CIPSO_V4_TAG_LOC_BLEN         6
+#define CIPSO_V4_TAG_LOC_BLEN         (2 + sizeof(struct lsmblob))

 /*
  * Helper Functions
@@ -1460,7 +1462,11 @@ static int cipso_v4_gentag_loc(const struct cipso_v4_doi *doi_def,

 	buffer[0] = CIPSO_V4_TAG_LOCAL;
 	buffer[1] = CIPSO_V4_TAG_LOC_BLEN;
-	*(u32 *)&buffer[2] = secattr->attr.secid;
+	/* Ensure that there is sufficient space in the CIPSO header
+	 * for the LSM data. */
+	BUILD_BUG_ON(CIPSO_V4_TAG_LOC_BLEN > CIPSO_V4_OPT_LEN_MAX);
+	memcpy(&buffer[2], &secattr->attr.lsmblob,
+	       sizeof(secattr->attr.lsmblob));

 	return CIPSO_V4_TAG_LOC_BLEN;
 }
@@ -1480,7 +1486,7 @@ static int cipso_v4_parsetag_loc(const struct cipso_v4_doi *doi_def,
 				 const unsigned char *tag,
 				 struct netlbl_lsm_secattr *secattr)
 {
-	secattr->attr.secid = *(u32 *)&tag[2];
+	memcpy(&secattr->attr.lsmblob, &tag[2], sizeof(secattr->attr.lsmblob));
 	secattr->flags |= NETLBL_SECATTR_SECID;

 	return 0;
diff --git a/net/netlabel/netlabel_kapi.c b/net/netlabel/netlabel_kapi.c
index beb0e573266d..158bab993e32 100644
--- a/net/netlabel/netlabel_kapi.c
+++ b/net/netlabel/netlabel_kapi.c
@@ -196,7 +196,7 @@ int netlbl_cfg_unlbl_map_add(const char *domain,
  * @addr: IP address in network byte order (struct in[6]_addr)
  * @mask: address mask in network byte order (struct in[6]_addr)
  * @family: address family
- * @secid: LSM secid value for the entry
+ * @lsmblob: LSM data value for the entry
  * @audit_info: NetLabel audit information
  *
  * Description:
@@ -210,7 +210,7 @@ int netlbl_cfg_unlbl_static_add(struct net *net,
 				const void *addr,
 				const void *mask,
 				u16 family,
-				u32 secid,
+				struct lsmblob *lsmblob,
 				struct netlbl_audit *audit_info)
 {
 	u32 addr_len;
@@ -230,7 +230,7 @@ int netlbl_cfg_unlbl_static_add(struct net *net,

 	return netlbl_unlhsh_add(net,
 				 dev_name, addr, mask, addr_len,
-				 secid, audit_info);
+				 lsmblob, audit_info);
 }

 /**
diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 596a75814fbf..60e36324568f 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -66,7 +66,7 @@ struct netlbl_unlhsh_tbl {
 #define netlbl_unlhsh_addr4_entry(iter) \
 	container_of(iter, struct netlbl_unlhsh_addr4, list)
 struct netlbl_unlhsh_addr4 {
-	u32 secid;
+	struct lsmblob lsmblob;

 	struct netlbl_af4list list;
 	struct rcu_head rcu;
@@ -74,7 +74,7 @@ struct netlbl_unlhsh_addr4 {
 #define netlbl_unlhsh_addr6_entry(iter) \
 	container_of(iter, struct netlbl_unlhsh_addr6, list)
 struct netlbl_unlhsh_addr6 {
-	u32 secid;
+	struct lsmblob lsmblob;

 	struct netlbl_af6list list;
 	struct rcu_head rcu;
@@ -220,7 +220,7 @@ static struct netlbl_unlhsh_iface *netlbl_unlhsh_search_iface(int ifindex)
  * @iface: the associated interface entry
  * @addr: IPv4 address in network byte order
  * @mask: IPv4 address mask in network byte order
- * @secid: LSM secid value for entry
+ * @lsmblob: LSM data value for entry
  *
  * Description:
  * Add a new address entry into the unlabeled connection hash table using the
@@ -231,7 +231,7 @@ static struct netlbl_unlhsh_iface *netlbl_unlhsh_search_iface(int ifindex)
 static int netlbl_unlhsh_add_addr4(struct netlbl_unlhsh_iface *iface,
 				   const struct in_addr *addr,
 				   const struct in_addr *mask,
-				   u32 secid)
+				   struct lsmblob *lsmblob)
 {
 	int ret_val;
 	struct netlbl_unlhsh_addr4 *entry;
@@ -243,7 +243,7 @@ static int netlbl_unlhsh_add_addr4(struct netlbl_unlhsh_iface *iface,
 	entry->list.addr = addr->s_addr & mask->s_addr;
 	entry->list.mask = mask->s_addr;
 	entry->list.valid = 1;
-	entry->secid = secid;
+	entry->lsmblob = *lsmblob;

 	spin_lock(&netlbl_unlhsh_lock);
 	ret_val = netlbl_af4list_add(&entry->list, &iface->addr4_list);
@@ -260,7 +260,7 @@ static int netlbl_unlhsh_add_addr4(struct netlbl_unlhsh_iface *iface,
  * @iface: the associated interface entry
  * @addr: IPv6 address in network byte order
  * @mask: IPv6 address mask in network byte order
- * @secid: LSM secid value for entry
+ * @lsmblob: LSM data value for entry
  *
  * Description:
  * Add a new address entry into the unlabeled connection hash table using the
@@ -271,7 +271,7 @@ static int netlbl_unlhsh_add_addr4(struct netlbl_unlhsh_iface *iface,
 static int netlbl_unlhsh_add_addr6(struct netlbl_unlhsh_iface *iface,
 				   const struct in6_addr *addr,
 				   const struct in6_addr *mask,
-				   u32 secid)
+				   struct lsmblob *lsmblob)
 {
 	int ret_val;
 	struct netlbl_unlhsh_addr6 *entry;
@@ -287,7 +287,7 @@ static int netlbl_unlhsh_add_addr6(struct netlbl_unlhsh_iface *iface,
 	entry->list.addr.s6_addr32[3] &= mask->s6_addr32[3];
 	entry->list.mask = *mask;
 	entry->list.valid = 1;
-	entry->secid = secid;
+	entry->lsmblob = *lsmblob;

 	spin_lock(&netlbl_unlhsh_lock);
 	ret_val = netlbl_af6list_add(&entry->list, &iface->addr6_list);
@@ -366,7 +366,7 @@ int netlbl_unlhsh_add(struct net *net,
 		      const void *addr,
 		      const void *mask,
 		      u32 addr_len,
-		      u32 secid,
+		      struct lsmblob *lsmblob,
 		      struct netlbl_audit *audit_info)
 {
 	int ret_val;
@@ -375,7 +375,6 @@ int netlbl_unlhsh_add(struct net *net,
 	struct netlbl_unlhsh_iface *iface;
 	struct audit_buffer *audit_buf = NULL;
 	struct lsmcontext context;
-	struct lsmblob blob;

 	if (addr_len != sizeof(struct in_addr) &&
 	    addr_len != sizeof(struct in6_addr))
@@ -408,7 +407,7 @@ int netlbl_unlhsh_add(struct net *net,
 		const struct in_addr *addr4 = addr;
 		const struct in_addr *mask4 = mask;

-		ret_val = netlbl_unlhsh_add_addr4(iface, addr4, mask4, secid);
+		ret_val = netlbl_unlhsh_add_addr4(iface, addr4, mask4, lsmblob);
 		if (audit_buf != NULL)
 			netlbl_af4list_audit_addr(audit_buf, 1,
 						  dev_name,
@@ -421,7 +420,7 @@ int netlbl_unlhsh_add(struct net *net,
 		const struct in6_addr *addr6 = addr;
 		const struct in6_addr *mask6 = mask;

-		ret_val = netlbl_unlhsh_add_addr6(iface, addr6, mask6, secid);
+		ret_val = netlbl_unlhsh_add_addr6(iface, addr6, mask6, lsmblob);
 		if (audit_buf != NULL)
 			netlbl_af6list_audit_addr(audit_buf, 1,
 						  dev_name,
@@ -438,11 +437,7 @@ int netlbl_unlhsh_add(struct net *net,
 unlhsh_add_return:
 	rcu_read_unlock();
 	if (audit_buf != NULL) {
-		/* lsmblob_init() puts secid into all of the secids in blob.
-		 * security_secid_to_secctx() will know which security module
-		 * to use to create the secctx.  */
-		lsmblob_init(&blob, secid);
-		if (security_secid_to_secctx(&blob, &context) == 0) {
+		if (security_secid_to_secctx(lsmblob, &context) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s",
 					 context.context);
 			security_release_secctx(&context);
@@ -477,7 +472,6 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 	struct audit_buffer *audit_buf;
 	struct net_device *dev;
 	struct lsmcontext context;
-	struct lsmblob blob;

 	spin_lock(&netlbl_unlhsh_lock);
 	list_entry = netlbl_af4list_remove(addr->s_addr, mask->s_addr,
@@ -496,13 +490,8 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 					  (dev != NULL ? dev->name : NULL),
 					  addr->s_addr, mask->s_addr);
 		dev_put(dev);
-		/* lsmblob_init() puts entry->secid into all of the secids
-		 * in blob. security_secid_to_secctx() will know which
-		 * security module to use to create the secctx.  */
-		if (entry != NULL)
-			lsmblob_init(&blob, entry->secid);
 		if (entry != NULL &&
-		    security_secid_to_secctx(&blob, &context) == 0) {
+		    security_secid_to_secctx(&entry->lsmblob, &context) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s",
 					 context.context);
 			security_release_secctx(&context);
@@ -543,7 +532,6 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 	struct audit_buffer *audit_buf;
 	struct net_device *dev;
 	struct lsmcontext context;
-	struct lsmblob blob;

 	spin_lock(&netlbl_unlhsh_lock);
 	list_entry = netlbl_af6list_remove(addr, mask, &iface->addr6_list);
@@ -561,13 +549,8 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 					  (dev != NULL ? dev->name : NULL),
 					  addr, mask);
 		dev_put(dev);
-		/* lsmblob_init() puts entry->secid into all of the secids
-		 * in blob. security_secid_to_secctx() will know which
-		 * security module to use to create the secctx.  */
-		if (entry != NULL)
-			lsmblob_init(&blob, entry->secid);
 		if (entry != NULL &&
-		    security_secid_to_secctx(&blob, &context) == 0) {
+		    security_secid_to_secctx(&entry->lsmblob, &context) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s",
 					 context.context);
 			security_release_secctx(&context);
@@ -921,14 +904,8 @@ static int netlbl_unlabel_staticadd(struct sk_buff *skb,
 	if (ret_val != 0)
 		return ret_val;

-	/* netlbl_unlhsh_add will be changed to pass a struct lsmblob *
-	 * instead of a u32 later in this patch set. security_secctx_to_secid()
-	 * will only be setting one entry in the lsmblob struct, so it is
-	 * safe to use lsmblob_value() to get that one value. */
-
-	return netlbl_unlhsh_add(&init_net,
-				 dev_name, addr, mask, addr_len,
-				 lsmblob_value(&blob), &audit_info);
+	return netlbl_unlhsh_add(&init_net, dev_name, addr, mask, addr_len,
+				 &blob, &audit_info);
 }

 /**
@@ -975,11 +952,8 @@ static int netlbl_unlabel_staticadddef(struct sk_buff *skb,
 	if (ret_val != 0)
 		return ret_val;

-	/* security_secctx_to_secid() will only put one secid into the lsmblob
-	 * so it's safe to use lsmblob_value() to get the secid. */
-	return netlbl_unlhsh_add(&init_net,
-				 NULL, addr, mask, addr_len,
-				 lsmblob_value(&blob), &audit_info);
+	return netlbl_unlhsh_add(&init_net, NULL, addr, mask, addr_len, &blob,
+				 &audit_info);
 }

 /**
@@ -1091,8 +1065,7 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 	struct net_device *dev;
 	struct lsmcontext context;
 	void *data;
-	u32 secid;
-	struct lsmblob blob;
+	struct lsmblob *lsmb;

 	data = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).portid,
 			   cb_arg->seq, &netlbl_unlabel_gnl_family,
@@ -1130,7 +1103,7 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 		if (ret_val != 0)
 			goto list_cb_failure;

-		secid = addr4->secid;
+		lsmb = (struct lsmblob *)&addr4->lsmblob;
 	} else {
 		ret_val = nla_put_in6_addr(cb_arg->skb,
 					   NLBL_UNLABEL_A_IPV6ADDR,
@@ -1144,14 +1117,10 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 		if (ret_val != 0)
 			goto list_cb_failure;

-		secid = addr6->secid;
+		lsmb = (struct lsmblob *)&addr6->lsmblob;
 	}

-	/* lsmblob_init() secid into all of the secids in blob.
-	 * security_secid_to_secctx() will know which security module
-	 * to use to create the secctx.  */
-	lsmblob_init(&blob, secid);
-	ret_val = security_secid_to_secctx(&blob, &context);
+	ret_val = security_secid_to_secctx(lsmb, &context);
 	if (ret_val != 0)
 		goto list_cb_failure;
 	ret_val = nla_put(cb_arg->skb,
@@ -1510,7 +1479,7 @@ int netlbl_unlabel_getattr(const struct sk_buff *skb,
 					      &iface->addr4_list);
 		if (addr4 == NULL)
 			goto unlabel_getattr_nolabel;
-		secattr->attr.secid = netlbl_unlhsh_addr4_entry(addr4)->secid;
+		secattr->attr.lsmblob = netlbl_unlhsh_addr4_entry(addr4)->lsmblob;
 		break;
 	}
 #if IS_ENABLED(CONFIG_IPV6)
@@ -1523,7 +1492,7 @@ int netlbl_unlabel_getattr(const struct sk_buff *skb,
 					      &iface->addr6_list);
 		if (addr6 == NULL)
 			goto unlabel_getattr_nolabel;
-		secattr->attr.secid = netlbl_unlhsh_addr6_entry(addr6)->secid;
+		secattr->attr.lsmblob = netlbl_unlhsh_addr6_entry(addr6)->lsmblob;
 		break;
 	}
 #endif /* IPv6 */
diff --git a/net/netlabel/netlabel_unlabeled.h b/net/netlabel/netlabel_unlabeled.h
index 058e3a285d56..168920780994 100644
--- a/net/netlabel/netlabel_unlabeled.h
+++ b/net/netlabel/netlabel_unlabeled.h
@@ -211,7 +211,7 @@ int netlbl_unlhsh_add(struct net *net,
 		      const void *addr,
 		      const void *mask,
 		      u32 addr_len,
-		      u32 secid,
+		      struct lsmblob *lsmblob,
 		      struct netlbl_audit *audit_info);
 int netlbl_unlhsh_remove(struct net *net,
 			 const char *dev_name,
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 824a6e4fb126..6f790d96594d 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -7056,7 +7056,7 @@ static int selinux_uring_sqpoll(void)
 }
 #endif /* CONFIG_IO_URING */

-static struct lsm_id selinux_lsmid __lsm_ro_after_init = {
+struct lsm_id selinux_lsmid __lsm_ro_after_init = {
 	.lsm  = "selinux",
 	.slot = LSMBLOB_NEEDED
 };
diff --git a/security/selinux/include/security.h b/security/selinux/include/security.h
index ac0ece01305a..9f856f2cd277 100644
--- a/security/selinux/include/security.h
+++ b/security/selinux/include/security.h
@@ -73,6 +73,7 @@
 struct netlbl_lsm_secattr;

 extern int selinux_enabled_boot;
+extern struct lsm_id selinux_lsmid;

 /*
  * type_datum properties
diff --git a/security/selinux/netlabel.c b/security/selinux/netlabel.c
index 800ab4b4239e..0b8f99703462 100644
--- a/security/selinux/netlabel.c
+++ b/security/selinux/netlabel.c
@@ -109,7 +109,7 @@ static struct netlbl_lsm_secattr *selinux_netlbl_sock_getattr(
 		return NULL;

 	if ((secattr->flags & NETLBL_SECATTR_SECID) &&
-	    (secattr->attr.secid == sid))
+	    (secattr->attr.lsmblob.secid[selinux_lsmid.slot] == sid))
 		return secattr;

 	return NULL;
diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.c
index 8e92af7dd284..23a45c9dcf04 100644
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@ -3899,7 +3899,7 @@ int security_netlbl_secattr_to_sid(struct selinux_state *state,
 	if (secattr->flags & NETLBL_SECATTR_CACHE)
 		*sid = *(u32 *)secattr->cache->data;
 	else if (secattr->flags & NETLBL_SECATTR_SECID)
-		*sid = secattr->attr.secid;
+		*sid = secattr->attr.lsmblob.secid[selinux_lsmid.slot];
 	else if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {
 		rc = -EIDRM;
 		ctx = sidtab_search(sidtab, SECINITSID_NETMSG);
@@ -3977,7 +3977,7 @@ int security_netlbl_sid_to_secattr(struct selinux_state *state,
 	if (secattr->domain == NULL)
 		goto out;

-	secattr->attr.secid = sid;
+	secattr->attr.lsmblob.secid[selinux_lsmid.slot] = sid;
 	secattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;
 	mls_export_netlbl_lvl(policydb, ctx, secattr);
 	rc = mls_export_netlbl_cat(policydb, ctx, secattr);
diff --git a/security/smack/smack.h b/security/smack/smack.h
index 66b813e15196..44fd5bc8ba71 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -303,6 +303,7 @@ int smack_populate_secattr(struct smack_known *skp);
  * Shared data.
  */
 extern int smack_enabled __initdata;
+extern struct lsm_id smack_lsmid;
 extern int smack_cipso_direct;
 extern int smack_cipso_mapped;
 extern struct smack_known *smack_net_ambient;
diff --git a/security/smack/smack_access.c b/security/smack/smack_access.c
index d2186e2757be..c6dcafe18912 100644
--- a/security/smack/smack_access.c
+++ b/security/smack/smack_access.c
@@ -524,7 +524,7 @@ int smack_populate_secattr(struct smack_known *skp)
 {
 	int slen;

-	skp->smk_netlabel.attr.secid = skp->smk_secid;
+	skp->smk_netlabel.attr.lsmblob.secid[smack_lsmid.slot] = skp->smk_secid;
 	skp->smk_netlabel.domain = skp->smk_known;
 	skp->smk_netlabel.cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);
 	if (skp->smk_netlabel.cache != NULL) {
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index 1069ba7abf40..9832b5e5c9fd 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -3729,11 +3729,12 @@ static struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,
 	if ((sap->flags & NETLBL_SECATTR_CACHE) != 0)
 		return (struct smack_known *)sap->cache->data;

+	/*
+	 * Looks like a fallback, which gives us a secid.
+	 */
 	if ((sap->flags & NETLBL_SECATTR_SECID) != 0)
-		/*
-		 * Looks like a fallback, which gives us a secid.
-		 */
-		return smack_from_secid(sap->attr.secid);
+		return smack_from_secid(
+				sap->attr.lsmblob.secid[smack_lsmid.slot]);

 	if ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {
 		/*
@@ -4752,7 +4753,7 @@ struct lsm_blob_sizes smack_blob_sizes __lsm_ro_after_init = {
 	.lbs_superblock = sizeof(struct superblock_smack),
 };

-static struct lsm_id smack_lsmid __lsm_ro_after_init = {
+struct lsm_id smack_lsmid __lsm_ro_after_init = {
 	.lsm  = "smack",
 	.slot = LSMBLOB_NEEDED
 };
diff --git a/security/smack/smackfs.c b/security/smack/smackfs.c
index 658eab05599e..13c2fa728054 100644
--- a/security/smack/smackfs.c
+++ b/security/smack/smackfs.c
@@ -1143,6 +1143,7 @@ static void smk_net4addr_insert(struct smk_net4addr *new)
 static ssize_t smk_write_net4addr(struct file *file, const char __user *buf,
 				size_t count, loff_t *ppos)
 {
+	struct lsmblob lsmblob;
 	struct smk_net4addr *snp;
 	struct sockaddr_in newname;
 	char *smack;
@@ -1274,10 +1275,13 @@ static ssize_t smk_write_net4addr(struct file *file, const char __user *buf,
 	 * this host so that incoming packets get labeled.
 	 * but only if we didn't get the special CIPSO option
 	 */
-	if (rc == 0 && skp != NULL)
+	if (rc == 0 && skp != NULL) {
+		lsmblob_init(&lsmblob, 0);
+		lsmblob.secid[smack_lsmid.slot] = snp->smk_label->smk_secid;
 		rc = netlbl_cfg_unlbl_static_add(&init_net, NULL,
-			&snp->smk_host, &snp->smk_mask, PF_INET,
-			snp->smk_label->smk_secid, &audit_info);
+			&snp->smk_host, &snp->smk_mask, PF_INET, &lsmblob,
+			&audit_info);
+	}

 	if (rc == 0)
 		rc = count;
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 754F0C4332F
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:05:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240391AbhKXCIx (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:08:53 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:46511
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S231748AbhKXCIu (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:08:50 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719541; bh=3v7/X7hiu4RXF+yQVC1lLkFTnjkaJoiIrnHULXOrI54=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=GVYo1R6o0hVGE1b0MEWDtrgO7M7CACnKjKbXJ8OdlKvbO/POhAwJj+1fumLkpbse70FWagjv7eN3obHvmqHXXxp+2M9COu3VubvfHFQKlCfXX/ogQBGOk4wG1TaGK5if0FunVazypLfiJnnaHrB4rQ6AAjUPKx9friHO8Ni7qZ+FnLUxcpLLQIf+9EbI71Gnp7U3Iv7wRlBY6T0i6W1gaO2t2g6XwYTpr/JHG+SbX91HyMBsED+zvakV2mOuM1KW8Rj6s6gOAy2vpq5svOF4QJj4ZD8EIR4NLVEQlTDYs9dspqRtVu21UjmQqtlSMMaqhfsamvjl/NXZj3a5CmZXOw==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719541; bh=Y5p4TiosCdAEapx2UxhgKMytWswBPr7B3IFoIc4Fvmo=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=Z1f4wGkF0E4Mr+jXfSFYMxZBb6CmHSP93u0SK2TG4HXPcZv0kJwR8tkiYZvwtXv7+IoqsZmDMg9tSsaW8IbVSNswhsg2zfdS691um5gvQkXrdhXR69dLUKiWm0tNrjlm7ikeBcmUWuwzz2yfuNXkzmzH6bYgn2AtVv3nCtMEpgSxj6xtTDxeVEK21xwbv1/SYBMw1c3gls9+8j/5R4zSF87adw1RzzJhQlDRS8LgHO60VscqK4hnGKwriboj6GUxKI1c+BbjGCkfqolLKxxqLMfQ7m6wDc5AZSvGTyZJdJJXA3cYxXPcFNbUecW3b/QyCbMPY1VShloWRcSSv82cBQ==
X-YMail-OSG: 4pVm8OQVM1lDr9frRNuzsudlmngMRarX0lN1CPRwo9KIW8vrNWy_PbEPM15LC4c
 HB2ynfPqWREYqyXISb81znylg4QlfzU0vFo1Z3Xm0k7ISKtUT_uzcPA0rrYWnmzENOBN5Qm_UKRv
 GJVPjis6eKNPI2L1Nr0akml1LwmbrBd4gDSu.x_7qwY_64MqR1uPmxVCPHUUIL6S3_TQ.CR2IJ1t
 uE2zVL8ySdUdcavucXbxetARoy6.UmQlMox_wJTYnoUHXOOiByks1iNyOTJKezjxQTZpTcKTTeYe
 qWOyqu0BqUlPXMACn4mF36tg25zjTFBs6YVsygUhn9YFA4cs38z2YOkrMmV_xW9E.yHREkYiCKmO
 zPAbIMhE9GC9ILDT3N1V6LjWQ0AOiKjA8fnfp6lP.FSEePDhgDBtB_WuLVID_ZkB.fLMur6a2Qvg
 SoqoEbUgktHBkcy6KG83ovuu2PIkqlJ6PDB1vZEHr2SlScNK7tfGaaTKyPBAYbCbgfLNvXYgKpmL
 eRWHXCK5FWZFSm9b2W4iUESl0SH9tTc_FMgKhahW70QUFj7KMideYDK3v3KshsfAv18Ac5R1YAlG
 YRa553voPbfrleMGnEMr0MFL4o1vW_TtRTTVsptFZu0s_V8AwsBtXX2eJeoBmp_XoXADvZKak_g_
 3aSa7oHdCv5z7V4tmsg8Ub9oxRfvnI9AJKARIpYCaT7ivYf0NVvQl_3q99YrMJRqecjetm_ykN8b
 VBr4lg9OP_CHiTIRzyJw6wBWh.jiBVgWhjHZp1fKk0Ty1NrQQF898RxaespQHFSerz6HSBFWONRa
 jrl5rFqtnI3ErzxQJW2TVyDIeJzMrsV2A1UvpXpfU41fmBX1tFECnY8UqWkHPcybszINvznK8fhT
 _HbO.U8e0DdmVt_NACEJ9dGNyGiogcBJCA8Zmr1BEE095szpLaSI6Nx4koq9MPZJrMJVDDryTzYF
 RAuQDlcNwmLib1IWI4rSzTCRBkqS4tyXbQT2sDKUOH74oaJJpASAXQetQ8amFyvOsEN7tjauA8WW
 JS_MC5qp6LR1Z3icfZgsBkFHkLNJVyBudxzLAxD5H809D2kksD_iXa8iwMpEquD0MvA2sdrj7QOe
 hqfAlMjM8Zg4xD1EhPFAuofQIrZ6e4gFkGWqr0YmBOzf86t0Jcu4dGNwVdWRT1F8DDFFHL92Nw0i
 DdYgLVjhZoD53SP43P4yVeC2s.lN971_jzxdIan.BVToXvqgcKqcWKYyxqkSHlxpSBg3R2gt4t5V
 uNsJhpOiXP_zxW5ix.wIU8xO0Eiwb9._lA6R1y1n0oaCYthgnqpAnSFKmXW2x2DGoGrNF3JHqMHc
 lmTVnVCbEF_JUJ3Acr8c7Nt.p2d9fRBA6FXKFsHj_9aMG2yMRKqs.9KWtjFTbhMqXUSrhCjshpJn
 iLaWE0MWiDVp1VwBfZyDai_OlLjO3EHcfxylqUee6j6OxRzEgoHPwZtp9dbI6go5wvT_LO6jNzCz
 3mwnFZp200KF_vzAJMjBFcwZ_YmlcUOKzAjSmc7FMPV1XM6HQycITuM0pchpajmVjD4z1vZo9k.i
 QaZJlcitLomuhJC2.Va.pIuiLZIB06dZVw2p7Y6dJ3eTsVricXlyf98DyFK2wTWSx7sJhL75J_ex
 6LX3.3EgoEiisix5d5pdARoyA4Y7ZVYxv72awnsBcl40fPwqscsjQTsjbQ1ugKHIKzy4.RL5PX0R
 WDsFrhMHE8zJm0ckZqYDVWOf2YXEyDc6motz0gZvJiQSJYZ_XzoFxgdHm.mV3lkDiEEwXfM._7iR
 a.ImWwXFSYvNR.S7W67YpAzBgujXpzHAvKF2Jvg1l.zVsIFkSR_rZwMkoDbojUvF9Bd1V3Q3AD2Q
 HXrPod1rnwl5cVhaG.B7eRwOSErGDXJfIxmnhCUlIfybEvj4tP5kuykmRWuNt1ItofhYLVrMb051
 LkO0GaAeYQSCSgafY3TrlYBR4rV4ru9gKoE3lvGK9gWg4E0JiXIcr3NLZuxqOcMcLO.AAjI4mGl.
 85BjE8mNxyhKF62bv5RX3T.SJd78kpCxQ9m2CoU2c5Z9nqgtukO8Ox.Wrj.z8Pu1GHrGnQRAmFh7
 USo4UBqROhldWfK396Mkf4lWkS3n1gYTmKCr3k4X7dHRUlVcCV5KLCDF35Tr_VRGEkzSmd5GOejQ
 ATvScmlbwyXcSJpyxUe.Z714BTaAohMSo9ZPj5rtRAIAxTDUkX_vKLzg_WXQUdzuhzu.KMwT2rw5
 AvDc4xswOjLef42wMi2aVJ2ZqvlX02KXSxdQx3ze0orthJaoSHQmESSgA.CYYfWIvWXJEN87AT6O
 WzBZZE9RevJpWbtN2
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:05:41 +0000
Received: by kubenode517.mail-prod1.omega.ne1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 4dfa065c98a4e0d04bdaf5ccb62b1d1e;
          Wed, 24 Nov 2021 02:05:38 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 20/28] binder: Pass LSM identifier for confirmation
Date:   Tue, 23 Nov 2021 17:43:24 -0800
Message-Id: <20211124014332.36128-21-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Send an identifier for the security module interface_lsm
along with the security context. This allows the receiver
to verify that the receiver and the sender agree on which
security module's context is being used. If they don't
agree the message is rejected.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 drivers/android/binder.c          | 21 +++++++++++++++++++++
 drivers/android/binder_internal.h |  1 +
 2 files changed, 22 insertions(+)

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index caaee7f95514..7172d864579d 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -2762,6 +2762,7 @@ static void binder_transaction(struct binder_proc *proc,
 				    ALIGN(extra_buffers_size, sizeof(void *)) -
 				    ALIGN(lsmctx.len, sizeof(u64));

+		t->security_interface = lsm_task_ilsm(current);
 		t->security_ctx = (uintptr_t)t->buffer->user_data + buf_offset;
 		err = binder_alloc_copy_to_buffer(&target_proc->alloc,
 						  t->buffer, buf_offset,
@@ -4132,6 +4133,26 @@ static int binder_thread_read(struct binder_proc *proc,

 		tr.secctx = t->security_ctx;
 		if (t->security_ctx) {
+			int to_ilsm = lsm_task_ilsm(current);
+			int from_ilsm = t->security_interface;
+
+			if (to_ilsm == LSMBLOB_INVALID)
+				to_ilsm = 0;
+			if (from_ilsm == LSMBLOB_INVALID)
+				from_ilsm = 0;
+			/*
+			 * The sender provided a security context from
+			 * a different security module than the one this
+			 * process wants to report if these don't match.
+			 */
+			if (from_ilsm != to_ilsm) {
+				if (t_from)
+					binder_thread_dec_tmpref(t_from);
+
+				binder_cleanup_transaction(t, "security context mismatch",
+							   BR_FAILED_REPLY);
+				return -EINVAL;
+			}
 			cmd = BR_TRANSACTION_SEC_CTX;
 			trsize = sizeof(tr);
 		}
diff --git a/drivers/android/binder_internal.h b/drivers/android/binder_internal.h
index d6b6b8cb7346..e3a0718ce17c 100644
--- a/drivers/android/binder_internal.h
+++ b/drivers/android/binder_internal.h
@@ -545,6 +545,7 @@ struct binder_transaction {
 	long    saved_priority;
 	kuid_t  sender_euid;
 	struct list_head fd_fixups;
+	int	security_interface;
 	binder_uintptr_t security_ctx;
 	/**
 	 * @lock:  protects @from, @to_proc, and @to_thread
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 30BA7C433EF
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:06:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240399AbhKXCJ5 (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:09:57 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:34961
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S230070AbhKXCJz (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:09:55 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719606; bh=fqcTlcbDfiUQwYvQNPEEr3xdoMx6PZueujFjkwYX6NE=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=iy4jolzB2CrUq5u6FRYIERYQX57KoM4CgW8Cq2OkLJjmzOPuk9EUuZ/147i857SVnvHS5xoC+VwDfH8Vq+d4A63Xu3zatD5FSCTPdOCsNgv9Wt7/98afcPY7xR8fuuN1AnnOjWsQ0vjCP8YtVPTvcQ9vVjVJD5u3pLNXqTQtUuk5JrZGEvgXqykShGX6AsHKr/lVLfGaJmDP+xhMGbG9G76Zphfe0/zHzkEQvTp4W85NY3ky4VxT2yrg5E/JnegMbuxBxjTL6PyBleFNsl3cdBu54FI9i5qzNFp75FI/xQde63gJTconeFqu6vpkl/H8ISAKvnfskYFu8MZCKmYFow==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719606; bh=WOF3jwcf6r6TVtrhHhPD7z+nUBHxj6xT4oRvE8CHQBa=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=SlZxOGNTzfd26eyeT+nJAFKeqSNoz2WdNSOFOVLKGy1bLzc78Ec2U9k/95bdkHOZ4viJDly/MpRjF8yzBwHtJ8FCG4Eu0QTeyBFUZk1P84/2icCYZftKMwCaIJcZhiV143oQVfZJZwoEI9HcB4ELcjMKF819myN/rADwuXLPOMVnw6ISUpkWQT7gspA9+hYSGuJ8w51DPHTOJHa96Tt+Qxvb7XbK5ewg7cHbs2dcJHVtgGgM6EXb2TNcXX+Ej3luE/HJFmPMF2cNCswywBJGMbEuo8/K4J/6IQlNd7GAeRUpDWuG0mCmGd9KQEhqYeuMLGz9G4GZrguFY1WUfXW4eQ==
X-YMail-OSG: 5VHsWzEVM1l0jvin9hM4wwJB4GrEVy1i_Iodb5ukNGfSVhyFXkTYPY807dkjMJ1
 TY9pksLBgmrSxg.wtR64hGy5eh7AZtAGh_vsemSx4FqLazwHBQIxKeVjR5z3XwnOgvtl0Bj3SkJ7
 0rk9T8APPfYWg2KJdQIOpEmcSlw82BN6yO8Rkqj8z.P_dOui5w3T0a33PeCmob6QC3AdwJFD2kLM
 g.P_Qnsk1ZuPf2FPhQf4HlklGviAwLXE.gffQSh8eCVoRQoq17vscR5N4dOwq2zhsNJbSEH_GnIz
 2kTFbEzCE_z2wWPDSHtjdIfZOQ_2ZeYzsNTX7Uxo31I8cBJKTA9XfUoHzrYsoXaEZ2DdECQRJ7iB
 TgDMJ9PTqzlOKmVCRQI3m9fEDUZwRENvjfrEokOQWGy0aLyHP2d7Gy_XARtTMa7Vn.9U7MONATkK
 mem9oaleHgBlEcz__5bmQN8gw3s.2msXBCOqsXLMW3eZK1KwSvOdP0bWD7oqZWr_VSNCr4JdoudF
 raSzItNiYdt0BAux3AOhy0U3y.e6w21.WsXrPFU8A_m971X1kFx2Dq3dATUAOAmsEr_PFxPHTcVl
 YC6RttVwWh9Zq2HOudaTq8aY6yRR5iImNvOsqjjosnTSq4pVVKA3ZPvlNzTLyThUsQkQivbeAv2Q
 dHOJBDN3bsQzHtenO..YxTo4Ald5uCwxjwCmn1PD4pFoPk70w1cNlO_clJCIbKbZgge6xONZ8b9u
 4eIJfzNpFQbd2nFLZuzqbwAtp_vxugyJHyskQlLBR8qQUd7E_vjapBnY5.czmACGWg18fyBa1QmR
 xJVycy_gZ24MR_uavbJpG69pmb2OQCfQtWpg9av3FpfcAM7vlW725wKx5FegQ7ckWC4hL8sMFMFN
 DY542A9emtf9FFlkNE8Gl7Lj3FOUElc2mULSo8iAhWjAJ8N4cBIEW5qioCoJ4t0F3lDpMR6PdCCt
 sOgNfW_HS7hbYqzgJyQyExRIhqMp3hfRq.OXRnUcfToH7MzZVthoyrlmyQQMVs2Ju0xZNlTA.RIs
 CSBTr6mi7Pl4iI6lCJYZBJeZNOIL8WHFJv2Q6NwlIpI7cEfJmXB4qk9xNSjyY5vqfmVdrc8y76tU
 uNguoMkU2mzaxVLhvQzL2XF2_QvMOmiGkEhHAca5tWqEyEysQP92uIZF_wkwYEr.alWu1f0_iX64
 Aml8rLNQiOtb1kza8jrkMhL2P9dR7ggtFcam.t_tDo8BN3eq5Dz34bLiSJ7cMKAzh5wuwSVy_t8d
 Ba31cyg3e6KdtbRzqMuYIYdWroJk.o.zMUul5S19JVBCFDconDFlmWAzuibeT0Iy6oPkQoIv0HCs
 3d2HKFPvOBIRaoaDIxo5NATZJxCuh1FQ0t2pAzy0HY4gSO7b5C2XdNOG8dFpaeZzrCA1XolPaS8x
 8sC9l5lPzRyEkWWI6b7am0B406Zww.qBW.qCYtiEYpCFzGXIYAoasYrBKvDGRvmm6j1xvT7t2yvJ
 oSC_4H5d4pIZ6kqDdhN3Tbt.9iLgkz5DffXEjskUNVs4H9SjkzWcAT0fSj1j3fzNKXXjjWt9ZTqD
 tKKxEoUtWA8CBHxJikicF6N3jRVZdy6TyKTDzmkKHTiRwKUH.MD0ZfSzzBCBXa4kMMryKt7.efYt
 NVpLpmD.dQvv6OEBUZ_OiAGJvIjxR_NVfs44CvPqETnckk8.EZcxcrMxbpZtM0rGbdrdH3wa00kn
 as7yAKGBgbo4u4kivt2kW_nbm4lnUq8RxKd3ADkvEsSOf0FvRRzOwmy0pMPDgPvTqsypQO5dw7kO
 J5NabKwZB6CZxqoWs.I8FskekklfyKZAsJAr6Q0rbhclAcid3tQif41OIJICvmmiQ9BQYHe9_mz6
 tmK7kp4WPOYwRuWxzqnBIANl.buApGw4WtIktIwAN9XaQFVYBY1cnqcREp2zwJvc0dhx3qYiIjdH
 NpMm_v8tF9TUHBQnSW29MrBJo0iZSjZnPsGvvvrMLo95f7f14dB6on8SbcsMABr6gjJD9JAo8z5p
 uuaZI98mDoeRrRlsT89QQYcqGCjx4qzi7hkxmON1wKE5zY4K17Y_A_yK.8FNXuJHCraf0700ltdh
 ZsQBVqthXI5zdDVQDaKSVL_QX_phtqKLnmYwmvXdVy3VcnIQbOPeB3tMClhfBNVKpAl0kVbIiYLm
 VYrcbbs84.wlsxzkl_JikPRK0p1dAeUgTYvr9jftE_bwdxAdFMTlIM_P.44SSpfvYmXLCS61q4PL
 Iv.IdzO3.bTg4k_zb2aoev7nJhcrQzMCzg75B2LpVe4uUK76Ap0DGqalOpJR62PgAuMjok_gwfcC
 kb1_8bMZPo2XXTdLOPA--
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:06:46 +0000
Received: by kubenode516.mail-prod1.omega.ne1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 3d833dde794aa50aade8b956ea9555fd;
          Wed, 24 Nov 2021 02:06:44 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 21/28] LSM: Extend security_secid_to_secctx to include module selection
Date:   Tue, 23 Nov 2021 17:43:25 -0800
Message-Id: <20211124014332.36128-22-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Add a parameter to security_secid_to_secctx() to identify
which of the security modules that may be active should
provide the security context. If the parameter is greater
than or equal to zero, the security module associated with
that LSM "slot" is used. If the value is LSMBLOB_DISPLAY
the "interface lsm" is used. If the value is LSMBLOB_FIRST
the first security module providing a hook is used.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 drivers/android/binder.c                |  2 +-
 include/linux/security.h                |  7 +++++--
 include/net/scm.h                       |  2 +-
 kernel/audit.c                          |  4 ++--
 kernel/auditsc.c                        |  7 ++++---
 net/ipv4/ip_sockglue.c                  |  2 +-
 net/netfilter/nf_conntrack_netlink.c    |  4 ++--
 net/netfilter/nf_conntrack_standalone.c |  2 +-
 net/netfilter/nfnetlink_queue.c         |  2 +-
 net/netlabel/netlabel_unlabeled.c       | 11 +++++++----
 net/netlabel/netlabel_user.c            |  2 +-
 security/security.c                     | 19 +++++++++++++++++--
 12 files changed, 43 insertions(+), 21 deletions(-)

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 7172d864579d..38987c68f4d5 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -2721,7 +2721,7 @@ static void binder_transaction(struct binder_proc *proc,
 		size_t added_size;

 		security_cred_getsecid(proc->cred, &blob);
-		ret = security_secid_to_secctx(&blob, &lsmctx);
+		ret = security_secid_to_secctx(&blob, &lsmctx, LSMBLOB_DISPLAY);
 		if (ret) {
 			return_error = BR_FAILED_REPLY;
 			return_error_param = ret;
diff --git a/include/linux/security.h b/include/linux/security.h
index a35618740b19..763dca314c00 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -184,6 +184,8 @@ struct lsmblob {
 #define LSMBLOB_INVALID		-1	/* Not a valid LSM slot number */
 #define LSMBLOB_NEEDED		-2	/* Slot requested on initialization */
 #define LSMBLOB_NOT_NEEDED	-3	/* Slot not requested */
+#define LSMBLOB_DISPLAY		-4	/* Use the "interface_lsm" slot */
+#define LSMBLOB_FIRST		-5	/* Use the first slot */

 /**
  * lsmblob_init - initialize an lsmblob structure
@@ -598,7 +600,8 @@ int security_setprocattr(const char *lsm, const char *name, void *value,
 			 size_t size);
 int security_netlink_send(struct sock *sk, struct sk_buff *skb);
 int security_ismaclabel(const char *name);
-int security_secid_to_secctx(struct lsmblob *blob, struct lsmcontext *cp);
+int security_secid_to_secctx(struct lsmblob *blob, struct lsmcontext *cp,
+			     int ilsm);
 int security_secctx_to_secid(const char *secdata, u32 seclen,
 			     struct lsmblob *blob);
 void security_release_secctx(struct lsmcontext *cp);
@@ -1459,7 +1462,7 @@ static inline int security_ismaclabel(const char *name)
 }

 static inline int security_secid_to_secctx(struct lsmblob *blob,
-					   struct lsmcontext *cp)
+					   struct lsmcontext *cp, int ilsm)
 {
 	return -EOPNOTSUPP;
 }
diff --git a/include/net/scm.h b/include/net/scm.h
index b77a52f93389..f4d567d4885e 100644
--- a/include/net/scm.h
+++ b/include/net/scm.h
@@ -101,7 +101,7 @@ static inline void scm_passec(struct socket *sock, struct msghdr *msg, struct sc
 		 * and the infrastructure will know which it is.
 		 */
 		lsmblob_init(&lb, scm->secid);
-		err = security_secid_to_secctx(&lb, &context);
+		err = security_secid_to_secctx(&lb, &context, LSMBLOB_DISPLAY);

 		if (!err) {
 			put_cmsg(msg, SOL_SOCKET, SCM_SECURITY, context.len,
diff --git a/kernel/audit.c b/kernel/audit.c
index 841123390d41..3c6e88a9ff62 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -1443,7 +1443,7 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)

 		if (lsmblob_is_set(&audit_sig_lsm)) {
 			err = security_secid_to_secctx(&audit_sig_lsm,
-						       &context);
+						       &context, LSMBLOB_FIRST);
 			if (err)
 				return err;
 		}
@@ -2138,7 +2138,7 @@ int audit_log_task_context(struct audit_buffer *ab)
 	if (!lsmblob_is_set(&blob))
 		return 0;

-	error = security_secid_to_secctx(&blob, &context);
+	error = security_secid_to_secctx(&blob, &context, LSMBLOB_FIRST);
 	if (error) {
 		if (error != -EINVAL)
 			goto error_path;
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index bdb368382e5d..ded4e8740fa2 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -1123,7 +1123,7 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 			 from_kuid(&init_user_ns, auid),
 			 from_kuid(&init_user_ns, uid), sessionid);
 	if (lsmblob_is_set(blob)) {
-		if (security_secid_to_secctx(blob, &lsmctx)) {
+		if (security_secid_to_secctx(blob, &lsmctx, LSMBLOB_FIRST)) {
 			audit_log_format(ab, " obj=(none)");
 			rc = 1;
 		} else {
@@ -1369,7 +1369,8 @@ static void show_special(struct audit_context *context, int *call_panic)
 			struct lsmblob blob;

 			lsmblob_init(&blob, osid);
-			if (security_secid_to_secctx(&blob, &lsmcxt)) {
+			if (security_secid_to_secctx(&blob, &lsmcxt,
+						     LSMBLOB_FIRST)) {
 				audit_log_format(ab, " osid=%u", osid);
 				*call_panic = 1;
 			} else {
@@ -1532,7 +1533,7 @@ static void audit_log_name(struct audit_context *context, struct audit_names *n,
 		struct lsmcontext lsmctx;

 		lsmblob_init(&blob, n->osid);
-		if (security_secid_to_secctx(&blob, &lsmctx)) {
+		if (security_secid_to_secctx(&blob, &lsmctx, LSMBLOB_FIRST)) {
 			audit_log_format(ab, " osid=%u", n->osid);
 			if (call_panic)
 				*call_panic = 2;
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 47d1085e037e..ebbde7d9d8bc 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -140,7 +140,7 @@ static void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)
 		return;

 	lsmblob_init(&lb, secid);
-	err = security_secid_to_secctx(&lb, &context);
+	err = security_secid_to_secctx(&lb, &context, LSMBLOB_DISPLAY);
 	if (err)
 		return;

diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
index 0c3e1a8aaf2b..dc31f7a68d6d 100644
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -347,7 +347,7 @@ static int ctnetlink_dump_secctx(struct sk_buff *skb, const struct nf_conn *ct)
 	 * security_secid_to_secctx() will know which security module
 	 * to use to create the secctx.  */
 	lsmblob_init(&blob, ct->secmark);
-	ret = security_secid_to_secctx(&blob, &context);
+	ret = security_secid_to_secctx(&blob, &context, LSMBLOB_DISPLAY);
 	if (ret)
 		return 0;

@@ -658,7 +658,7 @@ static inline int ctnetlink_secctx_size(const struct nf_conn *ct)
 	struct lsmblob blob;
 	struct lsmcontext context;

-	ret = security_secid_to_secctx(&blob, &context);
+	ret = security_secid_to_secctx(&blob, &context, LSMBLOB_DISPLAY);
 	if (ret)
 		return 0;

diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index c8825e89a21e..541a49d5be9d 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -180,7 +180,7 @@ static void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)
 	struct lsmcontext context;

 	lsmblob_init(&blob, ct->secmark);
-	ret = security_secid_to_secctx(&blob, &context);
+	ret = security_secid_to_secctx(&blob, &context, LSMBLOB_DISPLAY);
 	if (ret)
 		return;

diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c
index 69343275c54b..ea43bfd14544 100644
--- a/net/netfilter/nfnetlink_queue.c
+++ b/net/netfilter/nfnetlink_queue.c
@@ -316,7 +316,7 @@ static void nfqnl_get_sk_secctx(struct sk_buff *skb, struct lsmcontext *context)
 		 * blob. security_secid_to_secctx() will know which security
 		 * module to use to create the secctx.  */
 		lsmblob_init(&blob, skb->secmark);
-		security_secid_to_secctx(&blob, context);
+		security_secid_to_secctx(&blob, context, LSMBLOB_DISPLAY);
 	}

 	read_unlock_bh(&skb->sk->sk_callback_lock);
diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 60e36324568f..a70269367827 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -437,7 +437,8 @@ int netlbl_unlhsh_add(struct net *net,
 unlhsh_add_return:
 	rcu_read_unlock();
 	if (audit_buf != NULL) {
-		if (security_secid_to_secctx(lsmblob, &context) == 0) {
+		if (security_secid_to_secctx(lsmblob, &context,
+					     LSMBLOB_FIRST) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s",
 					 context.context);
 			security_release_secctx(&context);
@@ -491,7 +492,8 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 					  addr->s_addr, mask->s_addr);
 		dev_put(dev);
 		if (entry != NULL &&
-		    security_secid_to_secctx(&entry->lsmblob, &context) == 0) {
+		    security_secid_to_secctx(&entry->lsmblob, &context,
+					     LSMBLOB_FIRST) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s",
 					 context.context);
 			security_release_secctx(&context);
@@ -550,7 +552,8 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 					  addr, mask);
 		dev_put(dev);
 		if (entry != NULL &&
-		    security_secid_to_secctx(&entry->lsmblob, &context) == 0) {
+		    security_secid_to_secctx(&entry->lsmblob, &context,
+					     LSMBLOB_FIRST) == 0) {
 			audit_log_format(audit_buf, " sec_obj=%s",
 					 context.context);
 			security_release_secctx(&context);
@@ -1120,7 +1123,7 @@ static int netlbl_unlabel_staticlist_gen(u32 cmd,
 		lsmb = (struct lsmblob *)&addr6->lsmblob;
 	}

-	ret_val = security_secid_to_secctx(lsmb, &context);
+	ret_val = security_secid_to_secctx(lsmb, &context, LSMBLOB_FIRST);
 	if (ret_val != 0)
 		goto list_cb_failure;
 	ret_val = nla_put(cb_arg->skb,
diff --git a/net/netlabel/netlabel_user.c b/net/netlabel/netlabel_user.c
index 951ba0639d20..1941877fd16f 100644
--- a/net/netlabel/netlabel_user.c
+++ b/net/netlabel/netlabel_user.c
@@ -100,7 +100,7 @@ struct audit_buffer *netlbl_audit_start_common(int type,

 	lsmblob_init(&blob, audit_info->secid);
 	if (audit_info->secid != 0 &&
-	    security_secid_to_secctx(&blob, &context) == 0) {
+	    security_secid_to_secctx(&blob, &context, LSMBLOB_FIRST) == 0) {
 		audit_log_format(audit_buf, " subj=%s", context.context);
 		security_release_secctx(&context);
 	}
diff --git a/security/security.c b/security/security.c
index e776f71d126c..1d28d25d0ade 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2327,13 +2327,28 @@ int security_ismaclabel(const char *name)
 }
 EXPORT_SYMBOL(security_ismaclabel);

-int security_secid_to_secctx(struct lsmblob *blob, struct lsmcontext *cp)
+int security_secid_to_secctx(struct lsmblob *blob, struct lsmcontext *cp,
+			     int ilsm)
 {
 	struct security_hook_list *hp;
-	int ilsm = lsm_task_ilsm(current);

 	memset(cp, 0, sizeof(*cp));

+	/*
+	 * ilsm either is the slot number use for formatting
+	 * or an instruction on which relative slot to use.
+	 */
+	if (ilsm == LSMBLOB_DISPLAY)
+		ilsm = lsm_task_ilsm(current);
+	else if (ilsm == LSMBLOB_FIRST)
+		ilsm = LSMBLOB_INVALID;
+	else if (ilsm < 0) {
+		WARN_ONCE(true, "LSM: %s unknown interface LSM\n", __func__);
+		ilsm = LSMBLOB_INVALID;
+	} else if (ilsm >= lsm_slot) {
+		WARN_ONCE(true, "LSM: %s invalid interface LSM\n", __func__);
+		ilsm = LSMBLOB_INVALID;
+	}
 	hlist_for_each_entry(hp, &security_hook_heads.secid_to_secctx, list) {
 		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
 			continue;
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 98284C433FE
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:08:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240449AbhKXCLS (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:11:18 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:32909
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S230070AbhKXCLF (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:11:05 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719676; bh=Lvy7RjRBj+rVstpaWkxhmABunUEyo3MdTDjhwV0z1KM=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=PE8o57+cOqactK1nImPS9nal5gKQvyF4ECjeDMiHUAdp/ab8trkYWXVrogyXR32P3btZKo3vtPp3+z/z/9+Ct2caPsL1JtnUqCR+GAtfUmfT1QT1xncLVRn/1Vod4Ksl55BTToe1aVNIIo+8ja9957gQsZJBzxZKvYbxVeV14vrnJtWJZRyrdrctIhm8KoHtJPLyboWZ4tlUfgKS1tNnm+SI/HpX4hswcaOlOzL7wmg3Cnh4YST371Sgc9tCs6j3l811QeZCB1fym5aR2ULuTRNfvm7aEL2mXys0g5rcrepPP+xg498/q9lu751ozoKrKpCKtTcIOW53emw3Vg7Efw==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719676; bh=V30PPQSM4bpTLcwavNa7y+eHfzTkzJTmtMuh49dtaji=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=oVLXCZ8m3XOUHuChNBVUo5e2J6zUdqvTQ5pKMSAmd2Vq5jzTDOrTwb/GANQENZGlMN7g0zUHg/wG3x0fHWdBgRiiV7opi5nolGMvWQOedfpQK7egpKXnMIRuei8OBFTazoVi+LqmDz+5lnhj97NFeqM8szPp/9t45GxJpUqnUoJ+ML8/egMqOnFTKA1BZCfbU4o1FL38OsLC3YcTc/N1A5cvPLOrhMRiRlzWPrfvKFM3alaAVGiE9VUf3RW/Ae4TaiMjq/rHlVS5Yi2mCDHobQoRXZrF3J8OWtg5rWjbLOPxBIpS+H91PC1Wulx+B/aXHkqCJX/UPvL4Gt65U9Ic+A==
X-YMail-OSG: DdiEiu0VM1kugg1MifJw3OiMgA2X5wfhuLsBzBkiIkvVNtYG9mdUR7YzigxsmpB
 y7eILzBGNFtTq7RcdS9d8RJ0HgiMj30ys6un2MoH0.GkRzwaVeiSbiY0ZFXR9STJ1j6hl_6l9.sd
 oIJA.jIl8euVAtDPY8qCUA8.1d.SkjSqRWLm1AB_Z8RQgOoD3PqKY_wmBJb4pvF4avlkL1WsKIgA
 3Aq71sxQ4QccObBGuQXqMrSGLW4_KdL2fivtzADUk3irn37Cn_yfEkysHDQLoqyQcF0K.Ss4ale5
 B55N8bzxslAkOcWTg_24557nVN0zg4ulOzWElaJ9MnOP.Y_QPN9warQ241Afs8jWB8hJxWjZFCIx
 DjhFEpPEcHF2s7upClscv2ZD.W4trzLpD51tr6bUcGNVl2Oo8qy.5zN4tj0dU6LSUJhpEttPE1zX
 RnBmpR_YIrC.hYeMfyOl0uG56TVmMTtyhH0TZttbwGoY0LO8VXwzBvraSjxnrdZXjV34cXnGVPVH
 xM1r2UGx5iuveJCTW7yu9HHuX1.F9Ut.ymFK5v0FAMs3igXNTMhxCCarXZHOncT9o3PPken3sUIM
 3ZQgSiorh.uXWGgx5MQzCa02gOe9GoArem4qZ3NiJDcFsZ0V1BsuQ_gqugwVDw2qn1JGxYhLLkUy
 48AnSqxLocSwmQhAihEJwMcEDkzrp1ujlijCD4LPNI3bRP6KmbCXm8rBHCGD2aEHZjoiihpl_Dhk
 CoibN5knZ_B_4949AXwuAPP12fNGBWmf8xlGCZU_ey6SB8ACZcw3rcMum7zNBApQDU2D9ExJiVBn
 rAOloWp6M4IuhCShwFS5PJOEL2B.BtkJPLyo.PPxV3JN1WvebB0sykd7Yl2sv243TAtXWY4Ef8gc
 uqXCKt8QhaUsIRFzcc6pXY5pF6kzMiZOnoAR1MADT2MUYss2wNftOzjH9kdg67rboJcgxfSgI0jP
 1i7NcTTYPuk.nP0LYMvpsyf6gj4vuuCDRfYuMuS0JDymphd2M5_cAjajd3FHgnLyccpTZSJPtSVo
 x0y5LB2QbQBQpuWsrW2ZgKkJTpyejRX10F35HT3YJizp0mrSbTZqqNwhCMNzOKF8sA1hPMaYbMqG
 tZU5vh.RIHIITmQdqIu7upAwxeSXVlj38kqkq7IKe6NUZWPY5k9KciJu14NlbZADJm.PmTZMZ0OJ
 39XeeOJ1Ibja0J6B6fMUBbAFb.RREilg7XnitzwVKPxUg4ylJYh7h1SPMEyrvBerlv9CkZ4SYYUx
 Vq29IfGNhZqq8FeDOTYV_Dsq3..S6zGPs98kMR.SwoxfMZ0mnuelksSz0eGes1R_pIE3WqCmjZ54
 VET4XKX3O9X2_Zc4.3vJfUVot8mX4Eo3TkDF2NN1wdmapakPFgi8ttXIygZHozNByoG_4QRq2mwI
 NXUADa1VW_bCiukY8zWICJGavelSSb5nhKBnbDz0futaJQepARcz5LbptsDxR2Y6eIA9SfX6AL4d
 XOK.QrLbi6Al050CzQ6hfi8y1dvxdyditLE6MKIEwLRRoCmkTsELOhNXUFis_NxuL8aNPYdDCBT1
 7IFF4vNocVVeM_D.DnKeDjo_xDpICgHR0BwZsBoy5jbM4MwrJ9Yu.N6NiIGuG.27M5srMRQyZ9ci
 Fe2yO75K4RaLXq3Hm.T_WAM6BFAdYliRSy42K0ioOTBYogaO39rHOOfoo3jhjVKSbEH83EJluJ6e
 0fmPYcLG8S.56H8A6x1Yoarw19JVuWwErsjLRDRC1OKbsOaqKBZy.gFdVF_wpVf76Hdw.7NQ3Pny
 waPcc4O_7HS9CN_52dIRRAr54o_cxpxwDFvaWAYGFcmWXeKqDDGho7gs8wb28eQ1PBT8LpKXN4yE
 ZnxIuhvEPo1ntZyAWyV_8OkYcDrhPME1MmCRWO5ECnmEtkUEjzZ73SsuEaMb7BvX.ULUIev2oKbz
 9dTDoO_85gIvdNmmQe9w8SSMXkxDiAEtuMPwBgSj06tlXbQJb9FvLmJ3lba.nTGwr6nrSUfniTaO
 KrGBNO.xqCY69CpoJ1kOCFeDh9DOak5UxWsDkucS51MeNIREMCDqXIzZal_LEGanbjzoTH2lxJAI
 cwvblIK0o_whJRHz5UDa6e_M44g43xGt9dcQXAXohRLLd59BlM53F79AwGHPzd3XMP9aHXiY0DrR
 t49jSFv1kvvSTIcK7YYHKWDDpdLrqTw4fJXXfN74jivkU7NIpxh.4tb5zH_1txYMkV0N72KFVl7P
 Gi4s0DE71wgVPwLAooL5.TT8YPKUZjTNJsKzY5pw-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:07:56 +0000
Received: by kubenode503.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID d78d12be2dc33b4943994887cd31af7e;
          Wed, 24 Nov 2021 02:07:51 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 22/28] Audit: Keep multiple LSM data in audit_names
Date:   Tue, 23 Nov 2021 17:43:26 -0800
Message-Id: <20211124014332.36128-23-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Replace the osid field in the audit_names structure
with a lsmblob structure. This accomodates the use
of an lsmblob in security_audit_rule_match() and
security_inode_getsecid().

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 kernel/audit.h   |  2 +-
 kernel/auditsc.c | 22 ++++++++--------------
 2 files changed, 9 insertions(+), 15 deletions(-)

diff --git a/kernel/audit.h b/kernel/audit.h
index 527d4c4acb12..a2fca1134519 100644
--- a/kernel/audit.h
+++ b/kernel/audit.h
@@ -82,7 +82,7 @@ struct audit_names {
 	kuid_t			uid;
 	kgid_t			gid;
 	dev_t			rdev;
-	u32			osid;
+	struct lsmblob		lsmblob;
 	struct audit_cap_data	fcap;
 	unsigned int		fcap_ver;
 	unsigned char		type;		/* record type */
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index ded4e8740fa2..0d0351dc0c52 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -691,17 +691,16 @@ static int audit_filter_rules(struct task_struct *tsk,
 					 * lsmblob, which happens later in
 					 * this patch set.
 					 */
-					lsmblob_init(&blob, name->osid);
 					result = security_audit_rule_match(
-								&blob,
+								&name->lsmblob,
 								f->type,
 								f->op,
 								&f->lsm_rules);
 				} else if (ctx) {
 					list_for_each_entry(n, &ctx->names_list, list) {
-						lsmblob_init(&blob, n->osid);
 						if (security_audit_rule_match(
-							&blob, f->type, f->op,
+							&n->lsmblob,
+							f->type, f->op,
 							&f->lsm_rules)) {
 							++result;
 							break;
@@ -1528,13 +1527,12 @@ static void audit_log_name(struct audit_context *context, struct audit_names *n,
 				 from_kgid(&init_user_ns, n->gid),
 				 MAJOR(n->rdev),
 				 MINOR(n->rdev));
-	if (n->osid != 0) {
-		struct lsmblob blob;
+	if (lsmblob_is_set(&n->lsmblob)) {
 		struct lsmcontext lsmctx;

-		lsmblob_init(&blob, n->osid);
-		if (security_secid_to_secctx(&blob, &lsmctx, LSMBLOB_FIRST)) {
-			audit_log_format(ab, " osid=%u", n->osid);
+		if (security_secid_to_secctx(&n->lsmblob, &lsmctx,
+					     LSMBLOB_FIRST)) {
+			audit_log_format(ab, " osid=?");
 			if (call_panic)
 				*call_panic = 2;
 		} else {
@@ -2236,17 +2234,13 @@ static void audit_copy_inode(struct audit_names *name,
 			     const struct dentry *dentry,
 			     struct inode *inode, unsigned int flags)
 {
-	struct lsmblob blob;
-
 	name->ino   = inode->i_ino;
 	name->dev   = inode->i_sb->s_dev;
 	name->mode  = inode->i_mode;
 	name->uid   = inode->i_uid;
 	name->gid   = inode->i_gid;
 	name->rdev  = inode->i_rdev;
-	security_inode_getsecid(inode, &blob);
-	/* scaffolding until osid is updated */
-	name->osid = blob.secid[0];
+	security_inode_getsecid(inode, &name->lsmblob);
 	if (flags & AUDIT_INODE_NOEVAL) {
 		name->fcap_ver = -1;
 		return;
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id EB081C433F5
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:09:04 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240444AbhKXCML (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:12:11 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:45734
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S239932AbhKXCMK (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:12:10 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719741; bh=QNUuIy+Q9ZpmqzmySzUSoehny9z7UaG/wqEe2iSuix8=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=fjBbxQjEcJcYw2c1w4lb+EU2/4uOK5+ftsk8T06Vje8K37mB/EtegEgIGg7eKA6MlNHb7U155vymYhz8i5e7rSaOOKScnM7rOAciuUNHocjh6zjqdrPj4hPkrtPl/zrC70rQHgy2d4n8QPcus6kbyAMk9nznQ/2ApZOThZPwqfx7pjHgDWwhqxl7cP6hOeZv84MVN9o8UDz1HUR3f2sRda7PJrnx4LU3aeZG54DBge+BXESuitxXSgDpvn1bXTSjcDN5Cmu4xOmw+tZWkX8mE1YZu0U06gPr/YTuMuqhdG0oIYw+Src42WkJfLascddNZs8YYAOEotKliBjqBlCjoQ==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719741; bh=IgDpy135jkWXFTFsiqcI5wE/1lj4zKtaimt6fxmYNDY=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=g7FRqB5Wsl4il15d7Va8F322Mq6o4vV0yDSbt+xy0guOGwoxoJH33kStecDRtfFvVMtG7cbmeQ5SSJJhsj1G1D7rkQGk5EzxJdpvLCDV+GDTQNQ7tzRBkkta+B1Ir7dTBQR4Qy/BX8BjMboIuL7vjC8tu+BN2dkN9pyXncnd/TF4xVZXfRNJHjvev/bvLVbS9Xg2r3Z1a0iBmt08LclcW7wK9BxYCtdb8OU8pDIwUA8G8GGlsFDqWR0G2K0UPoWHnoVtUGAUH9fDApUgr2AXlChvjY9Z0J8kpK4MXJpsKWIMb3Lw2V3HqySdcETi5yA1No+fILAvLIr2BUxjluOWgA==
X-YMail-OSG: f.36IwgVM1l_p4UWsX9wTBfZ74XMsy.739wMmAdXeKOlEdBLsi9V1kUSzA_2NI_
 Em_c0vqmlll86KK1YuHv03r1l0Ejmg8Fi1A48IGmycNCTmYpDP7BT24ZKRaYGGUr0iUOA1Fbsmc8
 aCzEETcUvG.hD7F60g0qi.lBDacVJ_ooUuvF9JPdTnET5qC0nxuWrJ2U45Jmw.xbyynJNeQHs0SO
 YeTmbt5MsMQfsSiOPc.AeircjIvo802o1LC5J4rAZX0Bi_aeNNLYAvUKvP0Daj7at9xsaTf.0xNu
 ynXJSFbxm9NK2LNgkt3VYh59LLO0Luia.pp0SqoXMWKpznCPEJLK7Pwglec6YEY8D84N9b5nIkWF
 fmb8bGbbcYJS2WCI18A6k2OZwzwLGtorLcZW3Y9oUtV1CgART_K7i4_Ry7e8crvxuoXuUobLaZA5
 Ngq_V1QJ6QME_v1pt705bALVjE4Tu588hV.EcGik_YbhkA8XEmxr.unRdLuQMyS07QYI7bPNRMOm
 sRIvHq0pQiyidh0fu3LepcSKkePy14U69hUYGTPxAvm1feVeWWOzSWIdnhnLFXpl1bKxK3udONQw
 rVavPkI2J.qabuLuqHd0w7eKa02Z_xfeReQESkcIHT3sUt_TLKdjpG4_PZ12sGe1uDwTNQNf0u5U
 BFftgXSzAmdj4cX2Ak1NK5sKUvY45WeKpfaVmuPr9kYxoW33ZVvI7lJn6ZLxZ8J5cw8RnLaCaMBT
 jQSxY1osvcjgc6o4UbrAw5lzFNRpb5PpPHqUbJJ9VJSgQzRJ_12cUCnuwH2pb2F3kEitaFnTlCOl
 T9tv4A5boQDz1dKwJCuEvNJaPlImoRXkTo4Bds7wICi8R11BPDXPYLTlJkI0vNnES.Mq6dJ7vWXs
 4a7V9iXhggciLX3uC_OfvGVGfG7xDEsMf6slKdcfMmJZiAHMqbd3l8_do6O6fxWHiPS3E06DZws5
 CIw1msSCPo_hBsHtFdp_YXYlIa0mow7M7nf.YZS.njeUdpX6z6Mz4d_7cUyWcgxOneiaMOcCwOfw
 IpXaBCZJNnYCKz1uu0iFkKDUjL_XVEx7I0RrSbH0NFPMdgw0alfPiXPcyJgoUTsmVHMG11gMs02i
 uc0..VwWKmimZ2aprFXWJ8iAiBX.acylEHm9gwOUxYnAFBBbYnx24WmC15YeQBMWnPmtugZ2.k9p
 v0X1acSrOYO.GsI.RoN6vG0fAUVvFI4J7tjCcPD3obL5AYQk3OEM6UphHJ.CGsyr.SH6tAMriN0F
 atC8A3hk.kYYBavUZ4Ifoym8id72bM37Gpu36Xho4IxstNFiFNAEyAi7iUPs2aohnIw_sr3XoHPy
 WlbwAKYGknpuCDpt0QIpat2fd1S1bRIGkQrKfCvmdrjfX2s2bRwHKmr89vKaCFIF4NKQrYwWi4zx
 TanW366tSaBcw14G4vDWWzq_UIgP47tIeYncegW73t2zoRRGntMlLkpyqyF6zK1arENc2jUfr6dG
 H3RBdRaMWMIwqTMtJxHtwf5n2HVC71Y487WtcLYRCmINFVVsKk1s2NoKgLerEVml4GF2s7mY_e7S
 G3XcbEB1pVMCXsKd5TaFcoM2BQgA.EfEYWEeOWmfsy33kNRe106F1f1ZrWEjhHbebDap07vaulvo
 .HqShQVOiHrAzuYNWisb5919zUowK9sIE2CT4h871OUC28xfJYlS.tMxHvgZ1awaLzryAB0jEilt
 DqJfy_6MeIcK5wd0Z_ip1yIReJGOVOyiUGjFyMtp0zACkU.TE9n0m97dbwbeMIrmng45dUIppc6_
 qE0nnomxWzAqvfizENZImG5JBVhJs2LCAd86uGzy7SW6.UQrsnbKCanXrI.i5qsJeOYw50O_cCvx
 dvn_TXUze04KI6jbXkJUIWPvs8xrsOABp4qMFtSJ3V3a_cv8l1SXCiAA2h8AgQnNJ7J_9EgV7RiV
 6PIpmniio5pHtuYSJiwi6vS1EX1c0U01qlLGYFY5J8Zyfwrtc54qIcAYF1cxgTg9I9OAYAXXAqnK
 BWTyorLvEc5Tszw8_AFgxK91.zLiV1YCgpVo1muwfXQ78fsFb70LVXJAj2axf8XSCiRn5vUr5LT9
 .J6oTWsO5yzmOwfg9q2HGqiNrcbp0hpkqDdDKHhWNgrz4znxu_WyWbu.O.iPflQ6lyaWHBdZeqe_
 70l_Fih0EifsU4nhGX2w5kiLPTmUE27we__Dr1Od8umtGMIamXlHrHn2MXtuyQtyA3wJ5qxTsCDY
 0eSqZZs8ExBQdKe7f6jvuIiZqBv7LvW1AK4JhrB8-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:09:01 +0000
Received: by kubenode503.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 2cc95bb42913982b444d40acf5ef28ff;
          Wed, 24 Nov 2021 02:08:57 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 23/28] Audit: Create audit_stamp structure
Date:   Tue, 23 Nov 2021 17:43:27 -0800
Message-Id: <20211124014332.36128-24-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Replace the timestamp and serial number pair used in audit records
with a structure containing the two elements.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 kernel/audit.c   | 17 +++++++++--------
 kernel/audit.h   | 12 +++++++++---
 kernel/auditsc.c | 22 +++++++++-------------
 3 files changed, 27 insertions(+), 24 deletions(-)

diff --git a/kernel/audit.c b/kernel/audit.c
index 3c6e88a9ff62..069cd4c81a61 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -1786,11 +1786,11 @@ unsigned int audit_serial(void)
 }

 static inline void audit_get_stamp(struct audit_context *ctx,
-				   struct timespec64 *t, unsigned int *serial)
+				   struct audit_stamp *stamp)
 {
-	if (!ctx || !auditsc_get_stamp(ctx, t, serial)) {
-		ktime_get_coarse_real_ts64(t);
-		*serial = audit_serial();
+	if (!ctx || !auditsc_get_stamp(ctx, stamp)) {
+		ktime_get_coarse_real_ts64(&stamp->ctime);
+		stamp->serial = audit_serial();
 	}
 }

@@ -1813,8 +1813,7 @@ struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,
 				     int type)
 {
 	struct audit_buffer *ab;
-	struct timespec64 t;
-	unsigned int serial;
+	struct audit_stamp stamp;

 	if (audit_initialized != AUDIT_INITIALIZED)
 		return NULL;
@@ -1867,12 +1866,14 @@ struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,
 		return NULL;
 	}

-	audit_get_stamp(ab->ctx, &t, &serial);
+	audit_get_stamp(ab->ctx, &stamp);
 	/* cancel dummy context to enable supporting records */
 	if (ctx)
 		ctx->dummy = 0;
 	audit_log_format(ab, "audit(%llu.%03lu:%u): ",
-			 (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);
+			 (unsigned long long)stamp.ctime.tv_sec,
+			 stamp.ctime.tv_nsec/1000000,
+			 stamp.serial);

 	return ab;
 }
diff --git a/kernel/audit.h b/kernel/audit.h
index a2fca1134519..56560846f3b0 100644
--- a/kernel/audit.h
+++ b/kernel/audit.h
@@ -99,6 +99,12 @@ struct audit_proctitle {
 	char	*value;	/* the cmdline field */
 };

+/* A timestamp/serial pair to identify an event */
+struct audit_stamp {
+	struct timespec64	ctime;	/* time of syscall entry */
+	unsigned int		serial;	/* serial number for record */
+};
+
 /* The per-task audit context. */
 struct audit_context {
 	int		    dummy;	/* must be the first element */
@@ -108,10 +114,10 @@ struct audit_context {
 		AUDIT_CTX_URING,	/* in use by io_uring */
 	} context;
 	enum audit_state    state, current_state;
+	struct audit_stamp  stamp;	/* event identifier */
 	unsigned int	    serial;     /* serial number for record */
 	int		    major;      /* syscall number */
 	int		    uring_op;   /* uring operation */
-	struct timespec64   ctime;      /* time of syscall entry */
 	unsigned long	    argv[4];    /* syscall arguments */
 	long		    return_code;/* syscall return code */
 	u64		    prio;
@@ -261,7 +267,7 @@ extern void audit_put_tty(struct tty_struct *tty);
 #ifdef CONFIG_AUDITSYSCALL
 extern unsigned int audit_serial(void);
 extern int auditsc_get_stamp(struct audit_context *ctx,
-			      struct timespec64 *t, unsigned int *serial);
+			     struct audit_stamp *stamp);

 extern void audit_put_watch(struct audit_watch *watch);
 extern void audit_get_watch(struct audit_watch *watch);
@@ -302,7 +308,7 @@ extern void audit_filter_inodes(struct task_struct *tsk,
 				struct audit_context *ctx);
 extern struct list_head *audit_killed_trees(void);
 #else /* CONFIG_AUDITSYSCALL */
-#define auditsc_get_stamp(c, t, s) 0
+#define auditsc_get_stamp(c, s) 0
 #define audit_put_watch(w) do { } while (0)
 #define audit_get_watch(w) do { } while (0)
 #define audit_to_watch(k, p, l, o) (-EINVAL)
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index 0d0351dc0c52..e6868d072648 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -983,10 +983,10 @@ static void audit_reset_context(struct audit_context *ctx)
 	 */

 	ctx->current_state = ctx->state;
-	ctx->serial = 0;
+	ctx->stamp.serial = 0;
 	ctx->major = 0;
 	ctx->uring_op = 0;
-	ctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };
+	ctx->stamp.ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };
 	memset(ctx->argv, 0, sizeof(ctx->argv));
 	ctx->return_code = 0;
 	ctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);
@@ -1889,7 +1889,7 @@ void __audit_uring_entry(u8 op)

 	ctx->context = AUDIT_CTX_URING;
 	ctx->current_state = ctx->state;
-	ktime_get_coarse_real_ts64(&ctx->ctime);
+	ktime_get_coarse_real_ts64(&ctx->stamp.ctime);
 }

 /**
@@ -2005,7 +2005,7 @@ void __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,
 	context->argv[3]    = a4;
 	context->context = AUDIT_CTX_SYSCALL;
 	context->current_state  = state;
-	ktime_get_coarse_real_ts64(&context->ctime);
+	ktime_get_coarse_real_ts64(&context->stamp.ctime);
 }

 /**
@@ -2474,21 +2474,17 @@ EXPORT_SYMBOL_GPL(__audit_inode_child);
 /**
  * auditsc_get_stamp - get local copies of audit_context values
  * @ctx: audit_context for the task
- * @t: timespec64 to store time recorded in the audit_context
- * @serial: serial value that is recorded in the audit_context
+ * @stamp: timestamp to record
  *
  * Also sets the context as auditable.
  */
-int auditsc_get_stamp(struct audit_context *ctx,
-		       struct timespec64 *t, unsigned int *serial)
+int auditsc_get_stamp(struct audit_context *ctx, struct audit_stamp *stamp)
 {
 	if (ctx->context == AUDIT_CTX_UNUSED)
 		return 0;
-	if (!ctx->serial)
-		ctx->serial = audit_serial();
-	t->tv_sec  = ctx->ctime.tv_sec;
-	t->tv_nsec = ctx->ctime.tv_nsec;
-	*serial    = ctx->serial;
+	if (!ctx->stamp.serial)
+		ctx->stamp.serial = audit_serial();
+	*stamp = ctx->stamp;
 	if (!ctx->prio) {
 		ctx->prio = 1;
 		ctx->current_state = AUDIT_STATE_RECORD;
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 6145FC433EF
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:10:11 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240468AbhKXCNR (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:13:17 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:43921
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S238586AbhKXCNP (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:13:15 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719806; bh=FYfnW5aLV+shcP/5TMFUCwsaABbn5+q2oGvuTIwRTTU=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=gtS0BGGUeTmjEzZxiOaLYKAjadHQdEhMN+DJzpkCkjlMqq4xcYth+WX7ElQK73i3ilRnJadi3Cwvz1eKWYynBSppRPha6yqaEsHVRB3p/ukCH2lapI2I31oif7kiLaTROYFf00Mi0Q3tz/MCxJ8ZXGxX1Gdr5dNHdKwkw4D831sw3QKc2RiB/dOjw2FoE9NuqaIKgngMMTlkBVlWhqJwS36jl5COAoRH5PwZ75RY1i9ubkCWd5za/0g/02IPg7N0/EjPuxFbbPk2GqoC9EiNvuML2E9zr7u1L68rqyrl+9ifFQweYqbsvIoZrKA5/bf1ghkXwdFPEeSOCPp8AHXrCg==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719806; bh=Di5hPUPZpGsAZ5Odpf8+egZj+tkXjdTZJAf9Or35Eix=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=GTK1uSmRFXzCBcXy6takztcysJ24s+sYsC/PTbSwBlgQZTFCyjsUew39GYJQV7RL9y7Fhb6/oorMUP3gaIPBqaYU34gByDPT0sL7CnsYgueOWaE+pv5f0fbIUs6Q8YsH55IqKbLgStnB6shpSkK1ctVIc8rPQ2ZcL62QOrrq37yO6a9rSgq8mLkzgKyilLdlxkt3WsvTuc+U1VBtVD+hu8jjPVAISedVUepBxlVDSxMxlIm4fCyU9QtVv6sajgTKOh88yEUlgt86dz70Rur25Ame4NyufriIFACeCfIFEhk7y1ngb3ueyRFwQHdv3jtEn+31jytc/xOpwJaJ3sYozA==
X-YMail-OSG: IW5yBxYVM1niQT5IRqng8nMPZPMjYAEQxmu9KjcobD6tB0YhZoDevZ6WvwBSSr2
 zQJwpBPuG.Tcl01nx3qdP0z7rqzODzXoZu38Sj2vDKPss1YXqv6IoOLv5_E.8PYk2fe_jWMO077p
 tHMYDRdR4wugnkV3pmVWhfJiW0re_4Q0FX0buYIVtrHeevnE3EZuoL61pkDI.g_aP_q58vZmDPnL
 nv59BGPWvoCmt_2ewh_YOGnbFnKYYu8h8qQa8H0Y5oSc5.G5ka8BxkHhP5vo.IpduZSajwNY4fxV
 0ToiTEkCGRzWf_wQpZ9J9mSU670eaf9oXFEczCe2Vl0zAUfio.uoM1FDx_DzQltBkIimosltiMpS
 ix5eFDN54xEEAssmc57uLi6r1EiziG7Oeg7cbE.OpHkVj.k.tFy48Vtg5cRlJDKv8moNuEchNnDi
 zgoic2wTNOmy_H_zDeGbVoqBwdS3B8z_28VJrcXQ39LGCy76tJIoaKPYh3e5Y4quySZ3R3kiNvor
 RZwCJ7JGMi1jQgCZnnPH3f8.c3AQ01IiNhJUYGCUVZQtJ1pMudVoJPTer6iin_vMechpWXn17PVL
 fTgbLE6whMsAoxBNkOkNjh682Ou2qgFYNbqTXhkVgBV7myXJemS_uxMyJaJWgbGUGwBGAEACcT8C
 iBdzMHYMX5C4YYpqAziodMAQIZ_JZJP7c8QFL94AMyjUhcBxssBGCeYaZFdf5d3CXU_E9HTY5mxA
 zS_ZOQZCm0or2qaeEf8uH.m9PFpoHhWTki5WdTzBDkFvvwJYwDxXhs3om8HqsKX5ldCbkeLolCfX
 u05u8CIA1tPgiEsPmoY3d1e.shDt2FzWf7s5nw4uj_reRGoW5NcuyaMJERMwEE6OEr.EtV2ZsWjt
 IyJEjXBqYPbQ_4PB3e3BwJfv.IP570amP.QhCV8hVVRE0E9eNEFGxNYaMMTC6b_zvSFKXMF21UK8
 HD9eHS1JWL6dYdJo6qhHBo4pDA.VtIVyIREtaQZ0Z5d25_..TCN6NjOHcudXc0F6Cv.5GYQi_.9v
 GqAPCO7438udz_QS.7lCCjswCgLk6RDDGbc3UB6VH3Myn6ex_zFHbpGtyrxeM3VPvNu0lOEn0H.N
 SnggRsojF4meJ3TPAa5DcWIKLFZ6LZcU4OqDKHbSjwKqrCUI3tMVi6.GqxZUjmoMM7p4rKyxjgt.
 PEhcccIYGGXAAhvPz5QsZfY3rJVU47j.pkgo3SoqYCN23lZwU4R6j568ZccIS_jgVjUJrk_TXdX6
 kGqJIuDbEKAxxMOZcFfSTQ3b0RsCNxgXPFIG7H0p4FIoNmnD.fJRnkSp5RjPTXbl2XVjYPQAMfuR
 qKB4.ux6.YNmvW1OSDtKNzk_CHQuYRbt0GQ3c4HPOQwipnZUMBIwe4ukmplDMBmldXeTxiRpoVrw
 yiT6eP8lHptwfmCXum2SLHKgXMB7JPe6mq2CsIX0Q8RcNdlCoIj78FUnREk1J4P3oqhoBrJI5cRl
 mGf_t4mH_IO.uGhT_jTnKfYRPLD5DR7msQnWkELPfWBwvgkPe4rueqkaYGkRU3Qfx9tnTzvaXdlP
 Y3E3d0QOZnh1sbX9C6t_83fkKmY2Rsc.RHnRWwpjNqH2xcL0j41Y56IvbYOC5.tB_rRMao03jigf
 .pMgowAyr6hTV9a7q3DB54sYobhBL1IAu9DqFRS5pOhEDG78VV.GCTpKapbBzqznFgPtcfoD3seN
 EFLKiae.PglmuZV7DIaTv8DCRQLB_ognUaAzN0DGyYd_07gzn8v1rEYBQKaHX9kuiHjvG85_0WaT
 5U959oP0pfTbolac4UBCPx9Tp3Gj9viJyJ7s22UKUFRHYoX0Fs9P6ZEoERxlmMnfHHsIdOoWAD4l
 chJZU79bIzI0ivX9gE8pK5MjKC73auAOqVcPwQmqu7j9V8Ei1lJyApTRSLyGh0LG.Q7VGO6wXN3_
 _XjXdHztaHDcCg0WhWAnRoWvs_BPTVLM_Gev_Lbs8EIeOCopFnByJpKlRw5TptMpZZvdPbhguHyP
 9A3_myRcBEuawkuyqUreHmYp8g0dR2NpkzYrib8fvUCN_WJ9nEfK5E3UvTF23z6zdpKdhsLGP8jh
 b_xPW8k7GLdlalb8hNTNOoLCihHhPGM6F6lGw_iWNOiT8FpaSl04_Xauu0ZphYOA1iQGvf6OysCd
 oMs.Id.GHqhsakCcqf5DZfKs45212ZMijlDlJewOdIpwgWNVm9_pgzEsuexHgA8VpgsKXzf_JxLX
 YFgEXOndXTzQ4CfKd3h3D5QRxmeuewVX.6jHH7h6dWDvWR2FdfLDFzLj6t4YUxoeazRkFSn6i4kS
 Wmd2g26vC4AwVEBFQpQ--
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:10:06 +0000
Received: by kubenode512.mail-prod1.omega.ne1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID fa97930e4df2168aeebf019ebc923940;
          Wed, 24 Nov 2021 02:10:03 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 24/28] Audit: Add framework for auxiliary records
Date:   Tue, 23 Nov 2021 17:43:28 -0800
Message-Id: <20211124014332.36128-25-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Add a list for auxiliary record data to the audit_buffer structure.
Add the audit_stamp information to the audit_buffer as there's no
guarantee that there will be an audit_context containing the stamp
associated with the event. At audit_log_end() time create auxiliary
records (none are currently defined) as have been added to the list.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 kernel/audit.c   | 85 ++++++++++++++++++++++++++++++++++++++++++------
 kernel/audit.h   |  1 +
 kernel/auditsc.c |  2 ++
 3 files changed, 78 insertions(+), 10 deletions(-)

diff --git a/kernel/audit.c b/kernel/audit.c
index 069cd4c81a61..2b22498d3532 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -191,15 +191,25 @@ static struct audit_ctl_mutex {
  * should be at least that large. */
 #define AUDIT_BUFSIZ 1024

+/* The audit_context_entry contains data required to create an
+ * auxiliary record.
+ */
+struct audit_context_entry {
+	struct list_head	list;
+	int			type;	/* Audit record type */
+};
+
 /* The audit_buffer is used when formatting an audit record.  The caller
  * locks briefly to get the record off the freelist or to allocate the
  * buffer, and locks briefly to send the buffer to the netlink layer or
  * to place it on a transmit queue.  Multiple audit_buffers can be in
  * use simultaneously. */
 struct audit_buffer {
-	struct sk_buff       *skb;	/* formatted skb ready to send */
-	struct audit_context *ctx;	/* NULL or associated context */
-	gfp_t		     gfp_mask;
+	struct sk_buff		*skb;	/* formatted skb ready to send */
+	struct audit_context	*ctx;	/* NULL or associated context */
+	struct list_head	aux_records;	/* aux record data */
+	struct audit_stamp	stamp;	/* event stamp */
+	gfp_t			gfp_mask;
 };

 struct audit_reply {
@@ -1753,6 +1763,7 @@ static struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,

 	ab->ctx = ctx;
 	ab->gfp_mask = gfp_mask;
+	INIT_LIST_HEAD(&ab->aux_records);

 	return ab;

@@ -1813,7 +1824,6 @@ struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,
 				     int type)
 {
 	struct audit_buffer *ab;
-	struct audit_stamp stamp;

 	if (audit_initialized != AUDIT_INITIALIZED)
 		return NULL;
@@ -1866,14 +1876,14 @@ struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,
 		return NULL;
 	}

-	audit_get_stamp(ab->ctx, &stamp);
+	audit_get_stamp(ab->ctx, &ab->stamp);
 	/* cancel dummy context to enable supporting records */
 	if (ctx)
 		ctx->dummy = 0;
 	audit_log_format(ab, "audit(%llu.%03lu:%u): ",
-			 (unsigned long long)stamp.ctime.tv_sec,
-			 stamp.ctime.tv_nsec/1000000,
-			 stamp.serial);
+			 (unsigned long long)ab->stamp.ctime.tv_sec,
+			 ab->stamp.ctime.tv_nsec/1000000,
+			 ab->stamp.serial);

 	return ab;
 }
@@ -2363,7 +2373,7 @@ int audit_signal_info(int sig, struct task_struct *t)
 }

 /**
- * audit_log_end - end one audit record
+ * __audit_log_end - end one audit record
  * @ab: the audit_buffer
  *
  * We can not do a netlink send inside an irq context because it blocks (last
@@ -2371,7 +2381,7 @@ int audit_signal_info(int sig, struct task_struct *t)
  * queue and a kthread is scheduled to remove them from the queue outside the
  * irq context.  May be called in any context.
  */
-void audit_log_end(struct audit_buffer *ab)
+void __audit_log_end(struct audit_buffer *ab)
 {
 	struct sk_buff *skb;
 	struct nlmsghdr *nlh;
@@ -2393,6 +2403,61 @@ void audit_log_end(struct audit_buffer *ab)
 		wake_up_interruptible(&kauditd_wait);
 	} else
 		audit_log_lost("rate limit exceeded");
+}
+
+/**
+ * audit_log_end - end one audit record
+ * @ab: the audit_buffer
+ *
+ * Let __audit_log_end() handle the message while the buffer housekeeping
+ * is done here.
+ * If there are other records that have been deferred for the event
+ * create them here.
+ */
+void audit_log_end(struct audit_buffer *ab)
+{
+	struct audit_context_entry *entry;
+	struct audit_context mcontext;
+	struct audit_context *mctx;
+	struct audit_buffer *mab;
+	struct list_head *l;
+	struct list_head *n;
+
+	if (!ab)
+		return;
+
+	__audit_log_end(ab);
+
+	if (list_empty(&ab->aux_records)) {
+		audit_buffer_free(ab);
+		return;
+	}
+
+	if (ab->ctx == NULL) {
+		mcontext.context = AUDIT_CTX_AUXRECORD;
+		mcontext.stamp = ab->stamp;
+		mctx = &mcontext;
+	} else
+		mctx = ab->ctx;
+
+	list_for_each_safe(l, n, &ab->aux_records) {
+		entry = list_entry(l, struct audit_context_entry, list);
+		mab = audit_log_start(mctx, ab->gfp_mask, entry->type);
+		if (!mab) {
+			audit_panic("alloc error in audit_log_end");
+			continue;
+		}
+		switch (entry->type) {
+		/* Don't know of any quite yet. */
+		default:
+			audit_panic("Unknown type in audit_log_end");
+			break;
+		}
+		__audit_log_end(mab);
+		audit_buffer_free(mab);
+		list_del(&entry->list);
+		kfree(entry);
+	}

 	audit_buffer_free(ab);
 }
diff --git a/kernel/audit.h b/kernel/audit.h
index 56560846f3b0..f87da8e0a5a4 100644
--- a/kernel/audit.h
+++ b/kernel/audit.h
@@ -112,6 +112,7 @@ struct audit_context {
 		AUDIT_CTX_UNUSED,	/* audit_context is currently unused */
 		AUDIT_CTX_SYSCALL,	/* in use by syscall */
 		AUDIT_CTX_URING,	/* in use by io_uring */
+		AUDIT_CTX_AUXRECORD,	/* in use for auxiliary records */
 	} context;
 	enum audit_state    state, current_state;
 	struct audit_stamp  stamp;	/* event identifier */
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index e6868d072648..c128f7e73e89 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -1681,6 +1681,8 @@ static void audit_log_exit(void)
 	case AUDIT_CTX_URING:
 		audit_log_uring(context);
 		break;
+	case AUDIT_CTX_AUXRECORD:
+		break;
 	default:
 		BUG();
 		break;
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 825D8C433EF
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:11:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240647AbhKXCOc (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:14:32 -0500
Received: from sonic306-28.consmr.mail.ne1.yahoo.com ([66.163.189.90]:33061
        "EHLO sonic306-28.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S231596AbhKXCOZ (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:14:25 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719876; bh=m9z6o5dnm8sdyVoupZTMpf/y8KugHoQUZlUN1bqiah4=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=mRlE2LP8F+SB1McJjmr23GgyjCan9y0sgGMw2Sl8hIPiOjpX8f9Yx9qK9MXiwCBHwU+UMBk1O1+vZ230ZbkkLcYEUviNUS4qc8e51TpalbPUD6xQ55psGhkQAZC57qfZhzuFfIphqK+BJD6zoHgCq3rHrzpTQgbM2MT1OXu4tZS18Z1UD9+gAeMkWH+a5g1NM7z+rBMBc/r9XszNGwohBD0+jXS2LWx0JkukpG2ufBLwtxDKslWM6wNvMPczqnNoVWIpkv6GLw3vvtYpMUrbADtJ+Nq0RdNHDiY+US2ATMNFURAbs/wmYQJRRCAp3cAiM8gjxtcTdJiY6+wbjcVWbQ==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719876; bh=plgdhcLKUxH8+Bnhd4lqtY5xCUxt4vuPx4n0hktunY2=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=tC5AoFbEmJvvWpbHITgiQ1f8b98EmNTpJL/TOwJPfuj43n5WiG+5lWuiL4PK5g/BQ+I8nNBaeXmaEeZx0Q+d1ovZwa+x3cw29hSo+DBT4PkT2R07MeeNRUBo3FyeCNJxKAujNGNrU3CYybbUWaEaLQ20mczNCahfxl9ThR1UQ5+GTVYW02sT28O0V8JdRO4RUkofT+vc1cEu4WlBbu+RHXlZ824CTPLw+5Jg4/uqaDAPS7NqmClHIzINqjpKosL+yBUt+V+9cEVBewc933ciwPAsxCf/+YB9YG62wO4Im1O7jiHcNOUB68Kn1SQpvYecLU2P11uHgPt9tRSKJetlbg==
X-YMail-OSG: 9avVOs4VM1nweajwj3WQrPrqpXoGK5xp3RRzd_JeUK26SblMsTeODD2n86ZnJVz
 XcWZ5BBeUJvCQmuGBxQXIUMnY54dp9wqRcKkFysvFKQ7ciKqb1_DMNtHZbD9tdzwaLSbrX9szTTV
 pAIuiWUoOLTtTBW9tdbFCxlYIj8OJG01gNORI24TOyzMTOU2Np_VtP_UNdrshBsIsSWQsEuW4obO
 Lk1eOwynjaa.cDShGYv0mSp5pqR5w_bxIlCh.fZsv8.yv.JLfmv1W8nk.fj0GtwvvgZDlalMKtw1
 qIEFXBjUwglaP4MbhGmU4coZt_GSeYddJVFjw3wHy1.RsvFXxfvRJLIs8iQy7ZkGL67Y9yAfvkgc
 IDmGth363isusDA0CwqBkUWNFzlx7jJwBZrGh41PJwgeTol8zUqF9XqN89AwVLvCGibtng3tUoAK
 yTPAkf8hGIqxkSs5_NWoUeRppx4c5G7bhUUwiW_M7C1NjGPbn9U9fXHJvR_tm62mVsCJIb0Pz_uV
 FId4hoX9oDv6KLAe_MIpyDqxaf.Wiwll5oF395vGRAdJQd4oXYeoaHndnjroNxaYKinyRWK7GytL
 x1yfWmyW0bGQ90eSEg6vQJsLDWIYWiMBmVtuj5XcfD0Etk_7iT53M9B5l0vpKFD_tzNo3H.saY2A
 6dKWiNUv9_JBO259OTuAmPXjRM4v20Z0ACp9OwXlOYWCUtl06A_RCk6.MLrA9aTMAlpeQceC_Y3x
 RtqpFm6vWL0s6f3fAXbq5u.vfWtdcIjPq9weGfr6xXAT7mNX.pOv9im7mCjrQUi_nIczY9oljt94
 DBEJrEFpEhhlpN8.Z9cWt.JcEIXl2hZV223aytpsqB5w26qHgTlI5UzF1NZBrkCza8bmVdqtQVlO
 rNhVd0iQd.Qu8kp8hRO8yIBeoQ2BB8_rkCMPT7CIxMFzEA5WSXum9nMgNNc3od1H0KHKx4RDJnwS
 XrDy1fPEsLWcl2aU6nttCrxoCfh4kLIVodkUaOsZ7Rm_DNMyxVtN4IKKeZyQvc8Rh1aVGLDN49VV
 YI3i7FQ8RwOBz1xWLWeVrq5iHaUf_5Bt9s.cuQ1kanh4Rl8Z8Ms5WBV7Lf9XJECuLYiRAqoW6dm3
 Jnx0Zz2qPD6Glw5zt8g0xPURAnHVacySiSfL0k_DdDMzOIkt5UCy8XE5mi1p_hAZ_1jiFi1_FxpO
 iT8A5oSO9t9UqN45SAJG_uwVpIedqQ9k9PleJlEOifD_tpcp5kSFkjJDvMn2I394PSCbGyAU2NHW
 xVFuPx9ynnJ1zqBwEhEulzc6nkBqG3w7XtrkhTGI8.kgDDvKQEu_0S5q8iTMVTSRvg5UTIyjBPh8
 gH2iMi30_sPiCXgdh3ngr.JhtIm4YJ9KdGPiw45ylJOCdSc0Z1X8WXl9S3ZmGt8lBxDi12mBJciu
 ha0V_yV6WasGqNN_94UZ8STshXLvBxlYtOKLNoUZSF1xt0xvEJ0zmeF9d1aLzdQCuIKQZEYri_FW
 QSIOqW8jyuYKjw2OS8DbbcJmnqDdWoIViTYtcQUhV8RiWo2TsayDsiH88lA8O0RN4iTAcu5coCk3
 sEKV7vnG_FfcnqZqb02xTFDZI7hitBBBscsDBXSJGGesncYFU4I9H6FckVP3K9FyY0JOMrBnN7go
 Ee_iGQ9ADIjEYTDd6KvVzWL1Ew3CPrZYq0Jwgdx5Jl2y84rVX0wo3ZYFRvDmRi6bafwF6IxYqbWe
 ftLFrXOlLlag8..7Ec7EBtFUP8BI2lSm4Vh.d5NskM0uaKTLUl.u_1AR.5v.A89t4RRHGOO0tfz8
 jTovX3f514FdSw6zlEM4dKdaGb6mlXxSU2goD9LL4jI5EIQgHxx.wLEF3yc0zCXJNg3JjFhbrp8Z
 WFrdXyvKrAoh1wlKu_sn0FvsOewB76jLU6RlgMiNjhXOV3gqSbm8_tuuQERwRKte7_Hrte3XER2l
 AguQ3Ir6Rw2W0_MITbyAzVVxYv75E82LI8.KN3u5cu8sAEnqf524fD9ZZF2C1K_86kMvf0zgBK.1
 UWkU8jkOUUPaxrOSBtX8li4d9Q2Q0ferKBRfHAvHkDNuo1w4XiDTEmBu4l.BxW_QgljHNJGkznkx
 bv5eEx.X_fmGtvG8ui7ZaLwQmn6bd2dsHWW3onY6tiWknUh_w.sEAbRFh5kJwu4FslKMGUYVCPZ0
 5z1NEodgyw4nfcbzFMtDQW_ROpP4fKMqpr.zIXNCrXUl2vqLfCP3FUdVr0XVipNZ9J1Lp9TxJoV4
 qx_rUKE0ZPKNwVWrT8Q8lFvMbAonJRQJm5T4Ume0-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic306.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:11:16 +0000
Received: by kubenode503.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 3947682d601f244e6395ec4483004229;
          Wed, 24 Nov 2021 02:11:10 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 25/28] Audit: Add record for multiple task security contexts
Date:   Tue, 23 Nov 2021 17:43:29 -0800
Message-Id: <20211124014332.36128-26-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Create a new audit record AUDIT_MAC_TASK_CONTEXTS.
An example of the MAC_TASK_CONTEXTS (1420) record is:

    type=UNKNOWN[1420]
    msg=audit(1600880931.832:113)
    subj_apparmor="=unconfined"
    subj_smack="_"

When an audit event includes a AUDIT_MAC_TASK_CONTEXTS record
the "subj=" field in other records in the event will be "subj=?".
A AUDIT_MAC_TASK_CONTEXTS record is supplied when the system has
multiple security modules that may make access decisions based
on a subject security context.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 include/linux/security.h   |  9 ++++++
 include/uapi/linux/audit.h |  1 +
 kernel/audit.c             | 66 ++++++++++++++++++++++++++++++++------
 3 files changed, 67 insertions(+), 9 deletions(-)

diff --git a/include/linux/security.h b/include/linux/security.h
index 763dca314c00..b98545d2ae04 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -231,6 +231,15 @@ static inline bool lsmblob_equal(struct lsmblob *bloba, struct lsmblob *blobb)
 extern int lsm_name_to_slot(char *name);
 extern const char *lsm_slot_to_name(int slot);

+static inline bool lsm_multiple_contexts(void)
+{
+#ifdef CONFIG_SECURITY
+	return lsm_slot_to_name(1) != NULL;
+#else
+	return false;
+#endif
+}
+
 /**
  * lsmblob_value - find the first non-zero value in an lsmblob structure.
  * @blob: Pointer to the data
diff --git a/include/uapi/linux/audit.h b/include/uapi/linux/audit.h
index 9176a095fefc..86ad3da4f0d4 100644
--- a/include/uapi/linux/audit.h
+++ b/include/uapi/linux/audit.h
@@ -143,6 +143,7 @@
 #define AUDIT_MAC_UNLBL_STCDEL	1417	/* NetLabel: del a static label */
 #define AUDIT_MAC_CALIPSO_ADD	1418	/* NetLabel: add CALIPSO DOI entry */
 #define AUDIT_MAC_CALIPSO_DEL	1419	/* NetLabel: del CALIPSO DOI entry */
+#define AUDIT_MAC_TASK_CONTEXTS	1420	/* Multiple LSM task contexts */

 #define AUDIT_FIRST_KERN_ANOM_MSG   1700
 #define AUDIT_LAST_KERN_ANOM_MSG    1799
diff --git a/kernel/audit.c b/kernel/audit.c
index 2b22498d3532..6c93545a14f3 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -197,6 +197,9 @@ static struct audit_ctl_mutex {
 struct audit_context_entry {
 	struct list_head	list;
 	int			type;	/* Audit record type */
+	union {
+		struct lsmblob	mac_task_context;
+	};
 };

 /* The audit_buffer is used when formatting an audit record.  The caller
@@ -2139,6 +2142,21 @@ void audit_log_key(struct audit_buffer *ab, char *key)
 		audit_log_format(ab, "(null)");
 }

+static int audit_add_aux_task(struct audit_buffer *ab, struct lsmblob *blob)
+{
+	struct audit_context_entry *ace;
+
+	ace = kzalloc(sizeof(*ace), GFP_KERNEL);
+	if (!ace)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&ace->list);
+	ace->type = AUDIT_MAC_TASK_CONTEXTS;
+	ace->mac_task_context = *blob;
+	list_add(&ace->list, &ab->aux_records);
+	return 0;
+}
+
 int audit_log_task_context(struct audit_buffer *ab)
 {
 	int error;
@@ -2149,16 +2167,22 @@ int audit_log_task_context(struct audit_buffer *ab)
 	if (!lsmblob_is_set(&blob))
 		return 0;

-	error = security_secid_to_secctx(&blob, &context, LSMBLOB_FIRST);
-	if (error) {
-		if (error != -EINVAL)
-			goto error_path;
+	if (!lsm_multiple_contexts()) {
+		error = security_secid_to_secctx(&blob, &context,
+						 LSMBLOB_FIRST);
+		if (error) {
+			if (error != -EINVAL)
+				goto error_path;
+			return 0;
+		}
+		audit_log_format(ab, " subj=%s", context.context);
+		security_release_secctx(&context);
 		return 0;
 	}
-
-	audit_log_format(ab, " subj=%s", context.context);
-	security_release_secctx(&context);
-	return 0;
+	audit_log_format(ab, " subj=?");
+	error = audit_add_aux_task(ab, &blob);
+	if (!error)
+		return 0;

 error_path:
 	audit_panic("error in audit_log_task_context");
@@ -2419,9 +2443,12 @@ void audit_log_end(struct audit_buffer *ab)
 	struct audit_context_entry *entry;
 	struct audit_context mcontext;
 	struct audit_context *mctx;
+	struct lsmcontext lcontext;
 	struct audit_buffer *mab;
 	struct list_head *l;
 	struct list_head *n;
+	int rc;
+	int i;

 	if (!ab)
 		return;
@@ -2448,7 +2475,28 @@ void audit_log_end(struct audit_buffer *ab)
 			continue;
 		}
 		switch (entry->type) {
-		/* Don't know of any quite yet. */
+		case AUDIT_MAC_TASK_CONTEXTS:
+			for (i = 0; i < LSMBLOB_ENTRIES; i++) {
+				if (entry->mac_task_context.secid[i] == 0)
+					continue;
+				rc = security_secid_to_secctx(
+						&entry->mac_task_context,
+						&lcontext, i);
+				if (rc) {
+					if (rc != -EINVAL)
+						audit_panic("error in audit_log_end");
+					audit_log_format(mab, "%ssubj_%s=\"?\"",
+							 i ? " " : "",
+							 lsm_slot_to_name(i));
+				} else {
+					audit_log_format(mab, "%ssubj_%s=\"%s\"",
+							 i ? " " : "",
+							 lsm_slot_to_name(i),
+							 lcontext.context);
+					security_release_secctx(&lcontext);
+				}
+			}
+			break;
 		default:
 			audit_panic("Unknown type in audit_log_end");
 			break;
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id B808EC4332F
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:12:25 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240651AbhKXCPd (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:15:33 -0500
Received: from sonic302-26.consmr.mail.ne1.yahoo.com ([66.163.186.152]:38125
        "EHLO sonic302-26.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S231596AbhKXCPb (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:15:31 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719942; bh=mtYI3oD8Hvdbv8bkBbvB/0+CbZD2oGKGTVBtkTuSY1A=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=pvdvNIFbra1u1o/Mz/dyon2J4cDhgw4sHR2BF54Hq7K/76XfwEolfCBd9cl3nWbCN2ZUcMkYzuNhFJm9bnvJF6YL4wmhUh9XPL8IXCwZRqOsRhMrynS/b6W0XshV5K5aQ3bVJIVngB05f7lmFQEGL5/qHobdUGWAqJRmttHqHQh0CisZnYqMe20U6B6+wOQXG78XLIcjAFE9AC44sVqD5ncS5kViXryxdF2wfbVOd/XqGufvt5VwROS+19/2HS4uXEyqN6Cf77h6x4HpD2h1YDxYaHTjXzgIGvSKC37tLmhpPNCmPz5VxN+PtCZnrgFzSOy86xG+sgPwX9q9clE6pg==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637719942; bh=66d/hMP7LpdIOCiEgGPsqEBO7FQ6krZslStfo2g55Jp=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=GoGnmOjVy6EPNrcS5FcGVT2b0w6wEWpUoNwshVURK/MfvGY2edeIBeK3xCACUuQTpvVWqTctYtOtUWCuzNzHnSmMupQbulEdpWMsE6IWBwYbezDefui9K5V5CpVqDtYaC+HEgukxj0pT3OpMOEsg1xGeG+bpX6NZJR1ykyStTvPTlT5P8rZs/sJJhVvpCX5h/a1/xx8T6SY8ifeF5ehCacc5qB3N0zEuQ88SDs8dtTNa1YBY1p9T6oHMZfzEO1mAA1jCIUUws+vSTZThxPNB9Sa59g7hxinQCR0WAncLxzjpK6dFrOPwseNazT96U8sRKNvPBDPQ3L/rwBaglWxi6Q==
X-YMail-OSG: 3gAa8SoVM1mvoAWazgFGJDvQTyOZIMTgZ3dw20ChD8Nu6qcj7LJvkj5csXO3DxV
 rSElV2l9WLf0QxWttUKjBusudOAYO46TszwJKBduh0w_nS6A_07nPs8nO.9HdJGMPiFqsgQ6v6iM
 WG.46kXpm0OX5Npqz3M4HqJT.5P7Kv0b7k6GwhzA9gxycdoJx1eZFMB9DnZlBY0ZkShB2dUvzSCy
 6lCiJfJ3fdbn2wMcXVp7bSxmRSQvnSIny7PXpNmLtMXWplLUQq3RhMR3V2UufsqAtRiS9tUUSSei
 Nfh4tKGIL6g_JFURyuW6g1VA57xZRBE8OTYBb9u4z3GbDtbRkTEvt.kWnpkPBU9yKV35v1dkr3fc
 QRnYsNIOR1qHmb0E7WI9qRHec78Saf8Q_u0CvJo1ayURJhmj61p4VDuvp09eVLFZhSFK7gTx7HZU
 QHZSuXG1HCE3vi8JRHQGN3_90nOBQiyzjJCLdVrvHlExoxxPyxoxIMMUhZ0g.ckkAw6_Z4AddZo7
 i.pfCbpE7eKXuYA2CCqOrTz9yoxhWxBhULSuR8W7Z1pg.bCCpyYa71_zPa.Ac8xMrTxpovzClgll
 dS1SC.Q0TL_DZJU2_yHJLQ60RQBTzDIvxhTyUVi5PJ5Y4NvB5WlaALbXETfpL433PEqRQLWacLAM
 hhz5L1SDLZcheT.QKHdqBU..Jfbfqo1d5sTr3NWnzp.uk.60erPjmW7iWdBWbyBVTg_JvlmF4Eyg
 Nf0_VQC8hKsjU4MeCAyTTH2dPHoAMmuXmkNH4K_priP_kSCL2C4.nlo_wQxCt2__QKA3eShApRV_
 UkKolkwFff2x0I_unhRxpASrLe4LZoEpNR1D4Vvw1TSklrgAa1n7zB2ARTFO23jH9BcrQncZ7.pW
 X3GW7eykW6CpF8Wy626JzK3Cx5wVNGL6xifCVdjudwW9HYdfjZJrL7_qHAoqKqyox0aVzRT0TVTA
 oUGFXrEmj.0GDiHQe.Vh69TV7lk2leHURKo48JjQ0HyU7RnO6dx26bO.soX0x.KK8.qiZBlHfxGe
 VVvNrQInBLWbNQel75.clFnbA8DdmqCMV3GTyT_loXyYmOvLO4vN8QZrzdDGxX2DX1nFHwLDuAAw
 A_LxkveEVZ0Q2NWydFl.dvZjVqqG87lKy62_sUpQrbJWAUJdcRU5MziyoZKyfY4KsKj5t_MpYBQp
 Lr79b.kwyy_Hh_eglZEOG_hi9Y1oRikoRCwj6Dcn3luWooYKMZmPmu33TsqXusOqdAoc1O5ErV0c
 IClABNZxtDEeh0.ZPh6P4BCrKEbAsxdN0wf4XVdnfchGT5JGVwV1IaqyeOss83tnmjJ.1txyushm
 qCWcu.Q3Z4X_oRXTjpLhaAfBf8Z459Q18htOqzvG.Ync80z9Kke9PF40JM8zAk9sOe4AeZsejSmo
 xrPAWJbMVsar9v84raUG79LqFKqYqMwcyX5CkGUIHSiKr1Ul_vPvJ0Tq0yYxsDbyt7ju.6T_XhS_
 yNtF7dLwrrT3O2KJPr7cB9n8RileH.Aj6RwqwT6IF9Gu9TnuupcvEw41BJuzCsRjT7bCG5mK.cHy
 d9JDEVy0dyQ3RVDtofZKi8YEiMse2T5F4EtdngCT85d3iagN1gbfpeEzCmQJyzX6vUSnmKZAkNIf
 m40BQZ8NiTsKrjfs9NSoHc9rhSjsc.0az5tK51yQD18I56qxmRVAj9klSLSRsabxnqgAvrtWllHA
 Phhb8mxHsFHnTgOfW81nz4DOdkH_a35R5Hdcv_JdGay929zHj2d91bf7GtMgwTTejndBA4dGR42t
 DRfaRktOttDxelmYhegkvsBmwyphE5bB1wUluL9ajkpU_JXyb7InNTuti_iFdrLLZsIAoWQabQov
 1nDeRgcXIndfeQN1RqXsPxWoL65wpoOtVM54T6G7IKp2xZo1WHDX_M3D9100a_RAk1XVtSVWNhU_
 dFGAWmva_3oGCx2GIH4YTb5eocKtT_q6WZ1dKlCJ8HqYVzj9fPaShbbzWDVVGDP3bkLzkeUCpr48
 LGxIq1vsR9LTZUpKyiX82HIYAr3nauKrQb5_FCmWN.fFvgsI.OI2PiDPYG1c6NDp9_aWoQaddJ7b
 aTn7FskAzZt3fbATcmsWu1GOIilwjs_sgi.DmscXavFfnGTMG1zqB0X1FcQR2.DBg84kIcQBG9Ms
 xj0tx5iNhJ24CJzgM8ojhNEH4hYQofSDi9UDzIwYirBlexsCI8Mmy30JwWugjAyuo64y1FloBruV
 OfI2tdu_oWNBgvCMczKGh7QRJP00._JeNemBoK08NVFkU9v1Nagh7gwThu6FOTmlkSHDpJGaJIPJ
 i7hMu3_LMzrknvv2mF8w-
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic302.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:12:22 +0000
Received: by kubenode548.mail-prod1.omega.bf1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID 9ef5d2f3f4863db559dc6f4e0dc49d21;
          Wed, 24 Nov 2021 02:12:18 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Subject: [PATCH v30 26/28] Audit: Add record for multiple object security contexts
Date:   Tue, 23 Nov 2021 17:43:30 -0800
Message-Id: <20211124014332.36128-27-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Create a new audit record AUDIT_MAC_OBJ_CONTEXTS.
An example of the MAC_OBJ_CONTEXTS (1421) record is:

    type=UNKNOWN[1421]
    msg=audit(1601152467.009:1050):
    obj_selinux="unconfined_u:object_r:user_home_t:s0"

When an audit event includes a AUDIT_MAC_OBJ_CONTEXTS record
the "obj=" field in other records in the event will be "obj=?".
A AUDIT_MAC_OBJ_CONTEXTS record is supplied when the system has
multiple security modules that may make access decisions based
on an object security context.

Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 include/linux/audit.h      |  5 ++++
 include/uapi/linux/audit.h |  1 +
 kernel/audit.c             | 61 ++++++++++++++++++++++++++++++++++++++
 kernel/auditsc.c           | 37 ++++-------------------
 4 files changed, 72 insertions(+), 32 deletions(-)

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 943584128399..8381afb4f49e 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -192,6 +192,8 @@ extern void		    audit_log_path_denied(int type,
 extern void		    audit_log_lost(const char *message);

 extern int audit_log_task_context(struct audit_buffer *ab);
+extern void audit_log_object_context(struct audit_buffer *ab,
+				     struct lsmblob *blob);
 extern void audit_log_task_info(struct audit_buffer *ab);

 extern int		    audit_update_lsm_rules(void);
@@ -255,6 +257,9 @@ static inline int audit_log_task_context(struct audit_buffer *ab)
 {
 	return 0;
 }
+static inline void audit_log_object_context(struct audit_buffer *ab,
+					    struct lsmblob *blob);
+{ }
 static inline void audit_log_task_info(struct audit_buffer *ab)
 { }

diff --git a/include/uapi/linux/audit.h b/include/uapi/linux/audit.h
index 86ad3da4f0d4..116566d0fc03 100644
--- a/include/uapi/linux/audit.h
+++ b/include/uapi/linux/audit.h
@@ -144,6 +144,7 @@
 #define AUDIT_MAC_CALIPSO_ADD	1418	/* NetLabel: add CALIPSO DOI entry */
 #define AUDIT_MAC_CALIPSO_DEL	1419	/* NetLabel: del CALIPSO DOI entry */
 #define AUDIT_MAC_TASK_CONTEXTS	1420	/* Multiple LSM task contexts */
+#define AUDIT_MAC_OBJ_CONTEXTS	1421	/* Multiple LSM objext contexts */

 #define AUDIT_FIRST_KERN_ANOM_MSG   1700
 #define AUDIT_LAST_KERN_ANOM_MSG    1799
diff --git a/kernel/audit.c b/kernel/audit.c
index 6c93545a14f3..55fdcc2c88e4 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -199,6 +199,7 @@ struct audit_context_entry {
 	int			type;	/* Audit record type */
 	union {
 		struct lsmblob	mac_task_context;
+		struct lsmblob	mac_obj_context;
 	};
 };

@@ -2190,6 +2191,44 @@ int audit_log_task_context(struct audit_buffer *ab)
 }
 EXPORT_SYMBOL(audit_log_task_context);

+void audit_log_object_context(struct audit_buffer *ab, struct lsmblob *blob)
+{
+	struct audit_context_entry *ace;
+	struct lsmcontext context;
+	int error;
+
+	if (!lsm_multiple_contexts()) {
+		error = security_secid_to_secctx(blob, &context, LSMBLOB_FIRST);
+		if (error) {
+			if (error != -EINVAL)
+				goto error_path;
+			return;
+		}
+		audit_log_format(ab, " obj=%s", context.context);
+		security_release_secctx(&context);
+		return;
+	}
+	/*
+	 * If there is more than one security module that has a
+	 * object "context" it's necessary to put the object data
+	 * into a separate record to maintain compatibility.
+	 */
+	audit_log_format(ab, " obj=?");
+	ace = kzalloc(sizeof(*ace), GFP_KERNEL);
+	if (ace) {
+		INIT_LIST_HEAD(&ace->list);
+		ace->type = AUDIT_MAC_OBJ_CONTEXTS;
+		ace->mac_obj_context = *blob;
+		list_add(&ace->list, &ab->aux_records);
+		return;
+	}
+	error = -ENOMEM;
+
+error_path:
+	audit_panic("error in audit_log_object_context");
+}
+EXPORT_SYMBOL(audit_log_object_context);
+
 void audit_log_d_path_exe(struct audit_buffer *ab,
 			  struct mm_struct *mm)
 {
@@ -2497,6 +2536,28 @@ void audit_log_end(struct audit_buffer *ab)
 				}
 			}
 			break;
+		case AUDIT_MAC_OBJ_CONTEXTS:
+			for (i = 0; i < LSMBLOB_ENTRIES; i++) {
+				if (entry->mac_obj_context.secid[i] == 0)
+					continue;
+				rc = security_secid_to_secctx(
+							&entry->mac_obj_context,
+							&lcontext, i);
+				if (rc) {
+					if (rc != -EINVAL)
+						audit_panic("error in audit_log_end");
+					audit_log_format(mab, "%sobj_%s=\"?\"",
+							 i ? " " : "",
+							 lsm_slot_to_name(i));
+				} else {
+					audit_log_format(mab, "%sobj_%s=\"%s\"",
+							 i ? " " : "",
+							 lsm_slot_to_name(i),
+							 lcontext.context);
+					security_release_secctx(&lcontext);
+				}
+			}
+			break;
 		default:
 			audit_panic("Unknown type in audit_log_end");
 			break;
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index c128f7e73e89..dc8531a79174 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -1111,7 +1111,6 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 				 struct lsmblob *blob, char *comm)
 {
 	struct audit_buffer *ab;
-	struct lsmcontext lsmctx;
 	int rc = 0;

 	ab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);
@@ -1121,15 +1120,8 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 	audit_log_format(ab, "opid=%d oauid=%d ouid=%d oses=%d", pid,
 			 from_kuid(&init_user_ns, auid),
 			 from_kuid(&init_user_ns, uid), sessionid);
-	if (lsmblob_is_set(blob)) {
-		if (security_secid_to_secctx(blob, &lsmctx, LSMBLOB_FIRST)) {
-			audit_log_format(ab, " obj=(none)");
-			rc = 1;
-		} else {
-			audit_log_format(ab, " obj=%s", lsmctx.context);
-			security_release_secctx(&lsmctx);
-		}
-	}
+	if (lsmblob_is_set(blob))
+		audit_log_object_context(ab, blob);
 	audit_log_format(ab, " ocomm=");
 	audit_log_untrustedstring(ab, comm);
 	audit_log_end(ab);
@@ -1364,18 +1356,10 @@ static void show_special(struct audit_context *context, int *call_panic)
 				 from_kgid(&init_user_ns, context->ipc.gid),
 				 context->ipc.mode);
 		if (osid) {
-			struct lsmcontext lsmcxt;
 			struct lsmblob blob;

 			lsmblob_init(&blob, osid);
-			if (security_secid_to_secctx(&blob, &lsmcxt,
-						     LSMBLOB_FIRST)) {
-				audit_log_format(ab, " osid=%u", osid);
-				*call_panic = 1;
-			} else {
-				audit_log_format(ab, " obj=%s", lsmcxt.context);
-				security_release_secctx(&lsmcxt);
-			}
+			audit_log_object_context(ab, &blob);
 		}
 		if (context->ipc.has_perm) {
 			audit_log_end(ab);
@@ -1527,19 +1511,8 @@ static void audit_log_name(struct audit_context *context, struct audit_names *n,
 				 from_kgid(&init_user_ns, n->gid),
 				 MAJOR(n->rdev),
 				 MINOR(n->rdev));
-	if (lsmblob_is_set(&n->lsmblob)) {
-		struct lsmcontext lsmctx;
-
-		if (security_secid_to_secctx(&n->lsmblob, &lsmctx,
-					     LSMBLOB_FIRST)) {
-			audit_log_format(ab, " osid=?");
-			if (call_panic)
-				*call_panic = 2;
-		} else {
-			audit_log_format(ab, " obj=%s", lsmctx.context);
-			security_release_secctx(&lsmctx);
-		}
-	}
+	if (lsmblob_is_set(&n->lsmblob))
+		audit_log_object_context(ab, &n->lsmblob);

 	/* log the audit_names record type */
 	switch (n->type) {
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 74197C43217
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:13:33 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240671AbhKXCQk (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:16:40 -0500
Received: from sonic315-27.consmr.mail.ne1.yahoo.com ([66.163.190.153]:33023
        "EHLO sonic315-27.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S231847AbhKXCQi (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:16:38 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637720009; bh=9CzQ9uHdy4do/PNMLqTG82ebvy/4VhJrLPLfMtCcFBQ=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=chjqV0NlpJzct41szmGkgoYyH3DSCRdmIhyQg1OTBiWgCesfkE2pdtv5PEkxnQzsGTB0hnaeuEUTaL5Pw7Vfw3YuONmt6g5wtch9DwmLW6eWd9Dzx+wbsIlA7o3T2EisDgEU61lrT7PVE4NgwmnhcgNeWeASHPMSmJ8ybLfdEjblrjqg2AVbzP7QYr4IwaSJdZX4aFgmpA+l4Kk8KMRNdfXMDAR0tmkYplqMqCSYz5QE6ACqAfs6vjp4Q1KiuGfiwP+A6IijL5Lv+yeiP3XUTcqy5juyzK/3zcu6n+Mv1fWzrJXaAgMHJP2nGdjB54g/K2at+o8tacLXzAtT9OhICg==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637720009; bh=8z/AzwUIY2lRskZNKaFJQUzvZAMMTCozzFrXqsPm1tm=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=YbPxhaqpxt4VVK+B+iE5D0AMbWvkc+Ko6DWmRIuAh9SR2MicROyf4xcx1GvSFjXJbU4yU7ikhyPnNy5U676DLyBcJyPWzglDtJvkOTCIAjeuhq3FyhLCBzbxRf5qqRDQ9NsuhrNLjHl1oTdBdxzPVPmkwvwUo5tP7bGO3w2PiTYkohhYrRYbrz3Op82ansvZGZoUnoCqP0YgCM5qB6gWoqJ0jnj7g4XxQ/wC+6cO8cKjBJc7OHSal1ioYdb/K0+PFaD+tfjuKvRfHD3obDnBIKQz4XpgGg/Gx6zi7cG3vc0EHqKEn4UD/FYkt6FhgyuTVcWa9/+alzT31ePVfaY+Nw==
X-YMail-OSG: lFGB794VM1ldpuqp8mFwcE.bKpo78XErB9W6mO8sCrBmJZm7yNlMpWkQc.EhJTf
 iYt4a5eYnmEWoMAWpka05_p6Z8GrXNRuXAFKvRvdjo0MFCSg6wEoMh9ShIVWTps_5n.3BxotmtqP
 3KR0E0ftDmPncc0I9OSSzuWPU3D4yIpLj4SnAK8wsMVSDHQeOyjaTW4Qlx7D12JprZinDebCubWl
 Uixi3U7I9vm0i03nWcm_dijFQVZHxh6VH4E5y5sVk3N1hPh_CBf_9wrOPgITwQUNhnaP54_T0ksc
 dUV4O_ywqA17oJkIOAUn_dsG0bnyB1fCZRvlj9MdDJj2hVhBkf7_UMozmh83u5v2WVrw63aOxQpV
 bMAF6i.9j0xIQZTnNcyue2jk3PdI87cmLlRTF3JC.wzPzg9rLC.DEtsEFvEPZg66EHi5sJz_m9kG
 ESPXOLyo4cZErSz_BadJhhNw9HT1EgdQ3sQpFdygPXkD3tpsXMqM3zZwVJex03MAITw5ZoT5pIIw
 bQwjF7jY9w2bG6x.9fmtYN_kWrOwLlOiHEFjWA1d92L78aR53Riewk3kYSBZK_uWieIQSpTi2Yi4
 lZ0Sb7C4Keqv._cCmztLAqk10cPV2RkIh3.fB59b6lNzwuooGIojCuOLuVx0guKGrcNf3Fi8OvCo
 vhapLJDJ2b5ypplh4ygIvTBRe8Vw5eW9YHPAS4BUyDXJjdndAJ7jIGRU9yDVWILrLgXFlw.0EDq.
 pXgfUs45JGJbKw1TLpANOmdKT7TzcBROYIpUw4IyijYub2JxNCCQ7nGwkabJUko1XO0pqL1Hp0kh
 OFiz51vaQcaTxaLWqL3ebXAhC3FO2KRa9oISFDRCy9ByBqd356TyuN3h7EHt9DH9EvXVQuMwMpqr
 zcWJXf4jsFyqhK.21wXt2Y2v0do0_De.nD2GODk3qaWMAC2JPfAxHUkrbDdUVfYD1lbl.NnnBM6e
 2wNliEV3cCYkhWqVuYP2DmsnBcDWSeL8D80RmyWjJSM0LqRry9ECOMNN5k42ekL7d8IUYZL5XMBK
 ihwQuySoqH2oK4nBhnrDhGrfZJ1mX29fF2jcTDJxQixAn_Hq1kYZTYiPBLS2jWimd0Ysku_TYhMP
 MAZq_B3eeM_eimEoF_WC6fAcmTwWUxCsF9.66ySw.kz3gC7fjYpYAo.5xcKrqpVFARkPSQQjIBvs
 0usFVujGfSkzsJ6AcwRrNrNI6kj9iQfBkLGOBzyBhet93v_YCQ8KriHP6L_laIXti4wu.oOGYJRz
 r8ZAIpbPtD3NOsrwkxONnxo.Bs3tsZkDaksE2cvymMyH3Tbynay2QP1QROQq4jMGgtwbl.0_EAbm
 Ok3JCn37fclLv5aN0ss8.jbz6ufsvZHhyQB6uW.56WkuDe6HSio.2_WftrN9i4DbB26UDuWUGLGf
 4qr7N_NiW0cIe2rNargdR22WrN4zJRRS6KOTrjqcWA99nmLTbRWO8BIHyYYk07GiQfMcNlsYxmlj
 X1drG.TsTS0qhcg32f5fCwU8vFKhKduKm4PByQWjsoToYgXW2AaoBQOk0oHgzGy7I0VAJO5cOAW.
 _NuhAvujVzcFl3amF1eAh_7zin17aixcoOoDQ_NmTnaCIi2u.6k7cB7FsfX.RWiW17pFeke5aZwE
 ezHvyNq6XEeKdmkvt7M8OP6lwMBQx8wWfb8Q0rPjGLHTiNvqLQxJQT.Tv3dbK7alFNcjJ2oFwg2O
 x.9mO8tbPUDxWrSKG.sVJcYI71l59Tu323wLo1192wCsR78XogkM2B_k52aeh_Fad2K6Rzz_ErE6
 o5WH15yVbkDuiumc0qmwzDKLy1UCXDIUgRRTI5Gh7z9J5CaSk.zOsS099lVkhxForMRddNlBu33R
 bU28Hn9jMHw8Bt.ynMSDYgVZEpvXSWlNYp8U8Y2KVnH.19jkfqVfAO0unh1nbzbF9JdzPMsGjWyg
 eB2XuiMnTnNoGNHdCbHAkTVhJFm9z12CmB9U99oCSS8oxzqFILcLl4ityP2CxYNAT7wvJnPmmLl5
 zwEf7MIYAV6AmeYndf4zQdgphys1FyT_GT9s4GNRbVNsL._n2jqnUGCUw8TyUgLTx_l2ri3wr5A5
 i8vsn8U1.EdhAZh6pYE.zczs8Wk4TrwrIU3vl9hEEJQqUSgocCQGdX1.QYjrIZUpTm8MXXODefzQ
 CMmbrcY2orNacihIrXwftth.ZVC1biIvra4ig_7lghk30OJ2DIYbGRqqy7dvWp9ASy1bVXDjKWcK
 01RRwu0PiAnq4HWh0ZkUWs5XJwtboSf7vEBVhYaU02w--
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic315.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:13:29 +0000
Received: by kubenode524.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID fef1b8bbd5fbeb140c8e00bf0e5b2b51;
          Wed, 24 Nov 2021 02:13:24 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        linux-api@vger.kernel.org, linux-doc@vger.kernel.org
Subject: [PATCH v30 27/28] LSM: Add /proc attr entry for full LSM context
Date:   Tue, 23 Nov 2021 17:43:31 -0800
Message-Id: <20211124014332.36128-28-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Add an entry /proc/.../attr/context which displays the full
process security "context" in compound format:
        lsm1\0value\0lsm2\0value\0...
This entry is not writable.

A security module may decide that its policy does not allow
this information to be displayed. In this case none of the
information will be displayed.

Reviewed-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
Cc: linux-api@vger.kernel.org
Cc: linux-doc@vger.kernel.org
---
 Documentation/security/lsm.rst       | 14 +++++
 fs/proc/base.c                       |  1 +
 include/linux/lsm_hooks.h            |  6 +++
 security/apparmor/include/procattr.h |  2 +-
 security/apparmor/lsm.c              |  8 ++-
 security/apparmor/procattr.c         | 22 ++++----
 security/security.c                  | 79 ++++++++++++++++++++++++++++
 security/selinux/hooks.c             |  2 +-
 security/smack/smack_lsm.c           |  2 +-
 9 files changed, 121 insertions(+), 15 deletions(-)

diff --git a/Documentation/security/lsm.rst b/Documentation/security/lsm.rst
index b77b4a540391..070225ae6ceb 100644
--- a/Documentation/security/lsm.rst
+++ b/Documentation/security/lsm.rst
@@ -143,3 +143,17 @@ separated list of the active security modules.
 The file ``/proc/pid/attr/interface_lsm`` contains the name of the security
 module for which the ``/proc/pid/attr/current`` interface will
 apply. This interface can be written to.
+
+The infrastructure does provide an interface for the special
+case where multiple security modules provide a process context.
+This is provided in compound context format.
+
+-  `lsm\0value\0lsm\0value\0`
+
+The `lsm` and `value` fields are NUL-terminated bytestrings.
+Each field may contain whitespace or non-printable characters.
+The NUL bytes are included in the size of a compound context.
+The context ``Bell\0Secret\0Biba\0Loose\0`` has a size of 23.
+
+The file ``/proc/pid/attr/context`` provides the security
+context of the identified process.
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 50dbe5612a26..c90022027357 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -2829,6 +2829,7 @@ static const struct pid_entry attr_dir_stuff[] = {
 	ATTR(NULL, "keycreate",		0666),
 	ATTR(NULL, "sockcreate",	0666),
 	ATTR(NULL, "interface_lsm",	0666),
+	ATTR(NULL, "context",		0444),
 #ifdef CONFIG_SECURITY_SMACK
 	DIR("smack",			0555,
 	    proc_smack_attr_dir_inode_ops, proc_smack_attr_dir_ops),
diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
index 490545f0db6d..b919d5ab9120 100644
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@ -1400,6 +1400,12 @@
  *	@pages contains the number of pages.
  *	Return 0 if permission is granted.
  *
+ * @getprocattr:
+ *	Provide the named process attribute for display in special files in
+ *	the /proc/.../attr directory.  Attribute naming and the data displayed
+ *	is at the discretion of the security modules.  The exception is the
+ *	"context" attribute, which will contain the security context of the
+ *	task as a nul terminated text string without trailing whitespace.
  * @ismaclabel:
  *	Check if the extended attribute specified by @name
  *	represents a MAC label. Returns 1 if name is a MAC
diff --git a/security/apparmor/include/procattr.h b/security/apparmor/include/procattr.h
index 31689437e0e1..03dbfdb2f2c0 100644
--- a/security/apparmor/include/procattr.h
+++ b/security/apparmor/include/procattr.h
@@ -11,7 +11,7 @@
 #ifndef __AA_PROCATTR_H
 #define __AA_PROCATTR_H

-int aa_getprocattr(struct aa_label *label, char **string);
+int aa_getprocattr(struct aa_label *label, char **string, bool newline);
 int aa_setprocattr_changehat(char *args, size_t size, int flags);

 #endif /* __AA_PROCATTR_H */
diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c
index 5ed40fd93ce9..28ed41a3ffcf 100644
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -602,6 +602,7 @@ static int apparmor_getprocattr(struct task_struct *task, char *name,
 	const struct cred *cred = get_task_cred(task);
 	struct aa_task_ctx *ctx = task_ctx(current);
 	struct aa_label *label = NULL;
+	bool newline = true;

 	if (strcmp(name, "current") == 0)
 		label = aa_get_newest_label(cred_label(cred));
@@ -609,11 +610,14 @@ static int apparmor_getprocattr(struct task_struct *task, char *name,
 		label = aa_get_newest_label(ctx->previous);
 	else if (strcmp(name, "exec") == 0 && ctx->onexec)
 		label = aa_get_newest_label(ctx->onexec);
-	else
+	else if (strcmp(name, "context") == 0) {
+		label = aa_get_newest_label(cred_label(cred));
+		newline = false;
+	} else
 		error = -EINVAL;

 	if (label)
-		error = aa_getprocattr(label, value);
+		error = aa_getprocattr(label, value, newline);

 	aa_put_label(label);
 	put_cred(cred);
diff --git a/security/apparmor/procattr.c b/security/apparmor/procattr.c
index fde332e0ea7d..172550f67fc0 100644
--- a/security/apparmor/procattr.c
+++ b/security/apparmor/procattr.c
@@ -20,6 +20,7 @@
  * aa_getprocattr - Return the profile information for @profile
  * @profile: the profile to print profile info about  (NOT NULL)
  * @string: Returns - string containing the profile info (NOT NULL)
+ * @newline: Should a newline be added to @string.
  *
  * Requires: profile != NULL
  *
@@ -28,20 +29,21 @@
  *
  * Returns: size of string placed in @string else error code on failure
  */
-int aa_getprocattr(struct aa_label *label, char **string)
+int aa_getprocattr(struct aa_label *label, char **string, bool newline)
 {
 	struct aa_ns *ns = labels_ns(label);
 	struct aa_ns *current_ns = aa_get_current_ns();
+	int flags = FLAG_VIEW_SUBNS | FLAG_HIDDEN_UNCONFINED;
 	int len;

 	if (!aa_ns_visible(current_ns, ns, true)) {
 		aa_put_ns(current_ns);
 		return -EACCES;
 	}
+	if (newline)
+		flags |= FLAG_SHOW_MODE;

-	len = aa_label_snxprint(NULL, 0, current_ns, label,
-				FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
-				FLAG_HIDDEN_UNCONFINED);
+	len = aa_label_snxprint(NULL, 0, current_ns, label, flags);
 	AA_BUG(len < 0);

 	*string = kmalloc(len + 2, GFP_KERNEL);
@@ -50,19 +52,19 @@ int aa_getprocattr(struct aa_label *label, char **string)
 		return -ENOMEM;
 	}

-	len = aa_label_snxprint(*string, len + 2, current_ns, label,
-				FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
-				FLAG_HIDDEN_UNCONFINED);
+	len = aa_label_snxprint(*string, len + 2, current_ns, label, flags);
 	if (len < 0) {
 		aa_put_ns(current_ns);
 		return len;
 	}

-	(*string)[len] = '\n';
-	(*string)[len + 1] = 0;
+	if (newline) {
+		(*string)[len] = '\n';
+		(*string)[++len] = 0;
+	}

 	aa_put_ns(current_ns);
-	return len + 1;
+	return len;
 }

 /**
diff --git a/security/security.c b/security/security.c
index 1d28d25d0ade..83b588a87de2 100644
--- a/security/security.c
+++ b/security/security.c
@@ -802,6 +802,57 @@ static int lsm_superblock_alloc(struct super_block *sb)
 	return 0;
 }

+/**
+ * append_ctx - append a lsm/context pair to a compound context
+ * @ctx: the existing compound context
+ * @ctxlen: size of the old context, including terminating nul byte
+ * @lsm: new lsm name, nul terminated
+ * @new: new context, possibly nul terminated
+ * @newlen: maximum size of @new
+ *
+ * replace @ctx with a new compound context, appending @newlsm and @new
+ * to @ctx. On exit the new data replaces the old, which is freed.
+ * @ctxlen is set to the new size, which includes a trailing nul byte.
+ *
+ * Returns 0 on success, -ENOMEM if no memory is available.
+ */
+static int append_ctx(char **ctx, int *ctxlen, const char *lsm, char *new,
+		      int newlen)
+{
+	char *final;
+	size_t llen;
+	size_t nlen;
+	size_t flen;
+
+	llen = strlen(lsm) + 1;
+	/*
+	 * A security module may or may not provide a trailing nul on
+	 * when returning a security context. There is no definition
+	 * of which it should be, and there are modules that do it
+	 * each way.
+	 */
+	nlen = strnlen(new, newlen);
+
+	flen = *ctxlen + llen + nlen + 1;
+	final = kzalloc(flen, GFP_KERNEL);
+
+	if (final == NULL)
+		return -ENOMEM;
+
+	if (*ctxlen)
+		memcpy(final, *ctx, *ctxlen);
+
+	memcpy(final + *ctxlen, lsm, llen);
+	memcpy(final + *ctxlen + llen, new, nlen);
+
+	kfree(*ctx);
+
+	*ctx = final;
+	*ctxlen = flen;
+
+	return 0;
+}
+
 /*
  * The default value of the LSM hook is defined in linux/lsm_hook_defs.h and
  * can be accessed with:
@@ -2207,6 +2258,10 @@ int security_getprocattr(struct task_struct *p, const char *lsm, char *name,
 				char **value)
 {
 	struct security_hook_list *hp;
+	char *final = NULL;
+	char *cp;
+	int rc = 0;
+	int finallen = 0;
 	int ilsm = lsm_task_ilsm(current);
 	int slot = 0;

@@ -2234,6 +2289,30 @@ int security_getprocattr(struct task_struct *p, const char *lsm, char *name,
 		return -ENOMEM;
 	}

+	if (!strcmp(name, "context")) {
+		hlist_for_each_entry(hp, &security_hook_heads.getprocattr,
+				     list) {
+			rc = hp->hook.getprocattr(p, "context", &cp);
+			if (rc == -EINVAL)
+				continue;
+			if (rc < 0) {
+				kfree(final);
+				return rc;
+			}
+			rc = append_ctx(&final, &finallen, hp->lsmid->lsm,
+					cp, rc);
+			kfree(cp);
+			if (rc < 0) {
+				kfree(final);
+				return rc;
+			}
+		}
+		if (final == NULL)
+			return -EINVAL;
+		*value = final;
+		return finallen;
+	}
+
 	hlist_for_each_entry(hp, &security_hook_heads.getprocattr, list) {
 		if (lsm != NULL && strcmp(lsm, hp->lsmid->lsm))
 			continue;
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 6f790d96594d..cbacfdabbc30 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -6399,7 +6399,7 @@ static int selinux_getprocattr(struct task_struct *p,
 			goto bad;
 	}

-	if (!strcmp(name, "current"))
+	if (!strcmp(name, "current") || !strcmp(name, "context"))
 		sid = __tsec->sid;
 	else if (!strcmp(name, "prev"))
 		sid = __tsec->osid;
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index 9832b5e5c9fd..e5437d72699b 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -3486,7 +3486,7 @@ static int smack_getprocattr(struct task_struct *p, char *name, char **value)
 	char *cp;
 	int slen;

-	if (strcmp(name, "current") != 0)
+	if (strcmp(name, "current") != 0 && strcmp(name, "context") != 0)
 		return -EINVAL;

 	cp = kstrdup(skp->smk_known, GFP_KERNEL);
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 29906C433F5
	for <linux-kernel@archiver.kernel.org>; Wed, 24 Nov 2021 02:14:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240691AbhKXCRy (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Tue, 23 Nov 2021 21:17:54 -0500
Received: from sonic302-26.consmr.mail.ne1.yahoo.com ([66.163.186.152]:44132
        "EHLO sonic302-26.consmr.mail.ne1.yahoo.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S231555AbhKXCRl (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 23 Nov 2021 21:17:41 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637720072; bh=ILfwu5YCWq+aaMpJ0ICX0L0I4dees4dHGOc836rinKI=; h=From:To:Cc:Subject:Date:In-Reply-To:References:From:Subject:Reply-To; b=FcehUgNGgdaZ8bYJYqJ0gwcR47myELZIen+NDS7OmuXxWqIg2jWNfAavpZfSKguRKlD62Isp9u6mOPp9ImmbXmwO8BQgU11J4HE6UohAbTO7+VIbMywoM0pyrCno8Km4MgattrwnP82UVKiICiQ0a6dpbcDO1yZXs0azw1ZYLk3cPpEjccKnROMWv98gh08NejCpt76/XiR7kOn9fuaREOsnvkD+UrEjniFyDhFbRFymf4LfpCoUMLjYlZ0nzzvwXI4dxwIsDmFjPSkujYkYzMCjmhKXHugcGUiv/tv2ckbMPXbYyWj+hi5/Hvc+vDD3Q3o23CS2RuC5nQIyMeF9zw==
X-SONIC-DKIM-SIGN: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s2048; t=1637720072; bh=xBiLKlq3uTDxd4bd6pUOra3LliEZJKEkhJA2olglmkN=; h=X-Sonic-MF:From:To:Subject:Date:From:Subject; b=fITZ4yZFwbiv7TJaf3royrkUmIIQRr+uyJ2ZxHT8ewbli+jK0xWAKFdemNbbiWUnjKt/6GWCvIQ4zd1EqxrzhwKltjYp8auekXHGA3rf6u0IAI1yHuBCoX6eUXul6QV/dDDcCKYn1bswwkMC86CnMPSxSfoLz0z5trwXbEFgXDaQz5cI+LxneMa55GBofjCHWjXLeLuct830HR8N9IGXng2CI+q3u26L/s1Yg+Hex3GzjIAP9+A/X6rvStAeKsIhyniCYdCVRdoihY7ZfzgL94GfatiulKWwyR5ISCfJgc3YXUJh76bgg2e9s4+j4/UcTzQkZTewhpIdnSZviB6Vuw==
X-YMail-OSG: 45jzrVAVM1lZbcepjp.ENRkly5I2ZMoM9pmMkK4kFE_dqLdnuEr4TSLhpjaw0kr
 A71NSpJ_BSl5RakQVM.jHAf2B9zGBGDPDZQTY2J797OAqscJ6VGuRDwRDZnqszIZqyGeWoBJ9s3F
 vgMNn3FyUAoMO4idCsaGNm_nfwkVpF8FArwzYEQQDeRqhk6Y7bTLJzCyq.PNgT8iDwPWeJdYCqzz
 4Xt5Q1TY9XOq6XAzCqruRU75p0leUS4Fvsfhiv3OX9NAWrfhEjNT8N9tFYwdtlo8hSbtvw1OpGcc
 rgrsdeN5f8_hbaPoGMmIvrxeWHjjx5W60_7WbGBAyqZFex0crZJt9SLt5oteud3LIHT6v2WinzjP
 KmDCZdfYZwMOT1LnK8jUWChYEFkj.G15xhHwO_81hKFSOvF0odnurJiCQQms3SKrcGIXDsg_rqRO
 PQyASJTgxacvhXCbxjPSARxXcDFYkXEhc9tn2m5AwnBQ.fgC2z9tXKXSi1A9SqZDYy_a6oy8H0yb
 B_V2Ivc8HrW3ZFyqaRfqX5vlJWfKkgBrd0t7zNYLoVuYa7p0Noot7ph.061oF4TuM6iS62Kyt_Q0
 .Bq0Sdss_QvhT6uL.ifTg2wKex.SxrCQHFyq.BoTIOMBQFQDB66c.x8FomJDCC2s4yoaKb.OFE3R
 tWivyRN7.7EejIC.yvoWT6mP075y8TQJe_JbwtyI3tHeecfjt5valdk0G9GwMrOmBeXviC9s7DI_
 wZ6w6xTgoDtpoyi6PcVXam7z1ecqs7ofwD0OacRwTWd9xmejveDu2fD.ZM7imEezJQk7Qf7jJkrL
 2g_MNHya6LwRyQaUPtvF.Knj.tYMper.3gsIeI82LRrWSFqdIXl54lMJM1J6OO4iLiAAILl_wKbn
 d4OxCW2ZJu.JUKvm4XdxChD6T5csU9Cxr6yjYIlpLSKCpqKk0QS0DBhEEwmTg4zGFu36CPJ73jqZ
 .TlNeS7rjNhnw1.s1xpUKmGKbv_44PwB6d.XofrgHVts.GolL3OG.PUkPDkYc.YA40zBvpMTi2CB
 sARxaOyHByD2PQTihrmViCFEVDqtAWpsemvqqWuOMrgyegYsFRFdy91Rpr4pl1mM4tSEF4qy.8Hg
 dJ9UmohNcN_EcDHjA5mmib5.LCbuhisqBQ.nMvXZVlFFPdJC8MFR3l4zjUkHqUXJOEqLWaJcvqCn
 hr4Zu_oD2uSikzW5c0B2fp5bX5_CFWYGgGp07f6Dbyd6KiNjyWljtS34jIR17khaQ5P94IFieqEC
 bZiVh9p6Sy9TiQOPjJXlI3zh5KkWFkLzDCImmFwqngjHb.a3jDmuKgTM6WPxrB3_.6zZGlP364xW
 pvFZ7YdoDa5HBpE3.NzusRay.wGiMKRb1KBaamZx7BX__fvbXUsAdUoifcIpurb7vC51XOxPplCP
 QwTYtYPZSiMsUSCMPVCdJeh9ho5PMGPopg72SG.I0dZW94BLZwepyVT9tv5ioBoPFeCZZ.fU1Wrv
 8myxQCtWbJRihvSQ8vZtNkQCdLG2YgvWBAwggK9K5ZL7srw2jUJN76zhcnrtubqqNAdbuViyGlki
 PFMs2Bz5FetWjhHijaAVUE5CTrrBxFGPpZhjwqLpTrsL4j01JTXDQaznSJXnrvcYKU0tIRGLBdh0
 DzkJaCOqASUo011EZLueIESFxC3cwtaFILdxYNHTGx4MnYaDAiUwFRZeXGquCSCcAsuVt9NR8eqX
 InDH06Qa_YCGNkwirp6GXYqM7aNxyvt4xdiNdxXa.7lr1iVr7k7PT6kuTk9rM4nD9erBHxqiD6lj
 s70lZMsO.RtV98W.Actt45ZR1p2mNLhblbizXOAmsuqrtCK5tBwEFA9kmqENoXicr5Ncl57nSbzV
 E838HtAzHdOKGepegGzVjIMlI6Xc3k8Js9qWRVSBu53vGIrWDZVv6yXVow4yUGaACoz2484ZbiGq
 tHZE3DS_dWiMmHk65CemhrNPbkgnJs8M6cTxB69H660LUUtwpulvFY0mMPC4Zch6u2fg0JoLrpez
 leX7TCD1KUEdgsOiYiPAci6h5pbelnwllAwpeyzmjFETZW44UJVSE5uYWpPJg08Irq9ipsAym_Ao
 1R4mWpHKki7vDaodadkdqAZUGPO6Uw5AoJGPcp45gh0qFxCr.14fTsWZRS.ok.2sGHdD_WxB8CE3
 ENkLEd5fikesB4bIWF_qXMVkhNAK563hyw1OibzBBADLDbsDilVqpb00hAFhSaRNKTLvBGqFNCS8
 ltx.mQJRZ7PbeSjX3biy4LUfHl.6Db3RFLOBdM9DQZrwzhcEyPn1dJneeZFqOMHqMikfACvlJ3ee
 2mue7aQAEbK6STs9T
X-Sonic-MF: <casey@schaufler-ca.com>
Received: from sonic.gate.mail.ne1.yahoo.com by sonic302.consmr.mail.ne1.yahoo.com with HTTP; Wed, 24 Nov 2021 02:14:32 +0000
Received: by kubenode545.mail-prod1.omega.gq1.yahoo.com (VZM Hermes SMTP Server) with ESMTPA ID d31ad0ab77aa94fadbac5ad1dbcc6cd1;
          Wed, 24 Nov 2021 02:14:30 +0000 (UTC)
From:   Casey Schaufler <casey@schaufler-ca.com>
To:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org
Cc:     casey@schaufler-ca.com, linux-audit@redhat.com,
        keescook@chromium.org, john.johansen@canonical.com,
        penguin-kernel@i-love.sakura.ne.jp, paul@paul-moore.com,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org,
        Stephen Smalley <stephen.smalley.work@gmail.com>
Subject: [PATCH v30 28/28] AppArmor: Remove the exclusive flag
Date:   Tue, 23 Nov 2021 17:43:32 -0800
Message-Id: <20211124014332.36128-29-casey@schaufler-ca.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20211124014332.36128-1-casey@schaufler-ca.com>
References: <20211124014332.36128-1-casey@schaufler-ca.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

With the inclusion of the interface LSM process attribute
mechanism AppArmor no longer needs to be treated as an
"exclusive" security module. Remove the flag that indicates
it is exclusive. Remove the stub getpeersec_dgram AppArmor
hook as it has no effect in the single LSM case and
interferes in the multiple LSM case.

Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
Acked-by: John Johansen <john.johansen@canonical.com>
Reviewed-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
---
 security/apparmor/lsm.c | 20 +-------------------
 1 file changed, 1 insertion(+), 19 deletions(-)

diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c
index 28ed41a3ffcf..816145276c74 100644
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -1138,22 +1138,6 @@ static int apparmor_socket_getpeersec_stream(struct socket *sock,
 	return error;
 }

-/**
- * apparmor_socket_getpeersec_dgram - get security label of packet
- * @sock: the peer socket
- * @skb: packet data
- * @secid: pointer to where to put the secid of the packet
- *
- * Sets the netlabel socket state on sk from parent
- */
-static int apparmor_socket_getpeersec_dgram(struct socket *sock,
-					    struct sk_buff *skb, u32 *secid)
-
-{
-	/* TODO: requires secid support */
-	return -ENOPROTOOPT;
-}
-
 /**
  * apparmor_sock_graft - Initialize newly created socket
  * @sk: child sock
@@ -1257,8 +1241,6 @@ static struct security_hook_list apparmor_hooks[] __lsm_ro_after_init = {
 #endif
 	LSM_HOOK_INIT(socket_getpeersec_stream,
 		      apparmor_socket_getpeersec_stream),
-	LSM_HOOK_INIT(socket_getpeersec_dgram,
-		      apparmor_socket_getpeersec_dgram),
 	LSM_HOOK_INIT(sock_graft, apparmor_sock_graft),
 #ifdef CONFIG_NETWORK_SECMARK
 	LSM_HOOK_INIT(inet_conn_request, apparmor_inet_conn_request),
@@ -1912,7 +1894,7 @@ static int __init apparmor_init(void)

 DEFINE_LSM(apparmor) = {
 	.name = "apparmor",
-	.flags = LSM_FLAG_LEGACY_MAJOR | LSM_FLAG_EXCLUSIVE,
+	.flags = LSM_FLAG_LEGACY_MAJOR,
 	.enabled = &apparmor_enabled,
 	.blobs = &apparmor_blob_sizes,
 	.init = apparmor_init,
--
2.31.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id E659DC4332F
	for <linux-kernel@archiver.kernel.org>; Mon,  6 Dec 2021 02:43:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234677AbhLFCrJ (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Sun, 5 Dec 2021 21:47:09 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55028 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234650AbhLFCrI (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 5 Dec 2021 21:47:08 -0500
Received: from mail-ed1-x52c.google.com (mail-ed1-x52c.google.com [IPv6:2a00:1450:4864:20::52c])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 37E13C061354
        for <linux-kernel@vger.kernel.org>; Sun,  5 Dec 2021 18:43:40 -0800 (PST)
Received: by mail-ed1-x52c.google.com with SMTP id z5so37231370edd.3
        for <linux-kernel@vger.kernel.org>; Sun, 05 Dec 2021 18:43:40 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=paul-moore-com.20210112.gappssmtp.com; s=20210112;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc;
        bh=ymd6P5lILm8kCnpIAJpyY3MsDDsYTeqTIxl8Yef5YWE=;
        b=2kbZxWStBRfrT81SzE2HO3kF9ABLfHYL5BL3VYUs6WwWLjmIDonJdWwwSJ9a0FvgR7
         hHRmvcq5ouCeg94MAMPJaHwsVNINcmhY2+ZqsiMQpJZo5reyI+DDzmzM9MauDkiiYvtr
         v7M/5wqBN8XVpod5/DwNhhFA6zy8xjJL5b5QSgbzR/FKNyLtCKjRwhm9PAm+6rqUIrK4
         Y8STUO1xfj0nt+F9BpY0n1I6XFzf6itjiN53dg3KSj3chasVh48UWyjDBJ2HyutQ2vCe
         vT4UrdgFcjdr6YP+oL4Dugb3Uo18z5zmJHqTj6aL/LtYKoUL/DALbbHT1XQhpZ/LeNt+
         X6fQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc;
        bh=ymd6P5lILm8kCnpIAJpyY3MsDDsYTeqTIxl8Yef5YWE=;
        b=lW+2dTvTw0oIrYWHp2/J5AoA0dflvNn1AsbccAt/uKxj6LoQ2WXr3L42GPbmByH+r4
         LMls9gZc37vXxme8GNiDf3LZu1IGVVvZKD8M0tyOLskq9tTxng9spxL40jw9Wy/7zZ6H
         IZh+HpZcucS3Nh/u6BTcoZCcimDT6ZpJP4pcQx01xKxz7Mh3pU81q4O/bUJmIb6GILx8
         tNdXVDzT0zSnN61lTQfCDe/FNy2hi5aO0Jhol25r6bnKgFoDeLD39t2/jkVBmw8tiKtP
         kLy8FHCoLBV40zRUfXzOmuSEdP1eQ07eFMyvZzMJ0jM5YG9BezygQupvXHzaZVYU+uNC
         yqdQ==
X-Gm-Message-State: AOAM531rhKYJzAPOG1vVTDWyi1pZuhIyEAZmNnf4uyHKRFCY36xRIii+
        DHbtCrVMhYE8KhEBxLekEGtMJfDIaH974dpljpnE
X-Google-Smtp-Source: ABdhPJx69ThSSJXqiAFgrgGcClluUyTxJgmFaPaaQ09XYzcsxYERZ20FcG40EB3q9kgHLNGQC2XObsEZv7oJQWgCako=
X-Received: by 2002:a17:907:2d12:: with SMTP id gs18mr41876657ejc.126.1638758618582;
 Sun, 05 Dec 2021 18:43:38 -0800 (PST)
MIME-Version: 1.0
References: <20211124014332.36128-1-casey@schaufler-ca.com> <20211124014332.36128-2-casey@schaufler-ca.com>
In-Reply-To: <20211124014332.36128-2-casey@schaufler-ca.com>
From:   Paul Moore <paul@paul-moore.com>
Date:   Sun, 5 Dec 2021 21:43:27 -0500
Message-ID: <CAHC9VhRSnxf2S=Re8etrDnBqEkRemFwA0F9THK9FNeV3edLXfg@mail.gmail.com>
Subject: Re: [PATCH v30 01/28] integrity: disassociate ima_filter_rule from security_audit_rule
To:     Casey Schaufler <casey@schaufler-ca.com>
Cc:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org,
        linux-audit@redhat.com, keescook@chromium.org,
        john.johansen@canonical.com, penguin-kernel@i-love.sakura.ne.jp,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Content-Type: text/plain; charset="UTF-8"
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, Nov 23, 2021 at 8:45 PM Casey Schaufler <casey@schaufler-ca.com> wrote:
>
> Create real functions for the ima_filter_rule interfaces.
> These replace #defines that obscure the reuse of audit
> interfaces. The new fuctions are put in security.c because
> they use security module registered hooks that we don't
> want exported.
>
> Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
> ---
>  include/linux/security.h     | 26 ++++++++++++++++++++++++++
>  security/integrity/ima/ima.h | 26 --------------------------
>  security/security.c          | 21 +++++++++++++++++++++
>  3 files changed, 47 insertions(+), 26 deletions(-)

Acked-by: Paul Moore <paul@paul-moore.com> # audit


--
paul moore
www.paul-moore.com

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 0C997C433FE
	for <linux-kernel@archiver.kernel.org>; Mon,  6 Dec 2021 02:44:28 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234727AbhLFCry (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Sun, 5 Dec 2021 21:47:54 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55200 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234697AbhLFCrx (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 5 Dec 2021 21:47:53 -0500
Received: from mail-ed1-x52c.google.com (mail-ed1-x52c.google.com [IPv6:2a00:1450:4864:20::52c])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 67877C061354
        for <linux-kernel@vger.kernel.org>; Sun,  5 Dec 2021 18:44:25 -0800 (PST)
Received: by mail-ed1-x52c.google.com with SMTP id r11so36654960edd.9
        for <linux-kernel@vger.kernel.org>; Sun, 05 Dec 2021 18:44:25 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=paul-moore-com.20210112.gappssmtp.com; s=20210112;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc;
        bh=Jolb7Z2E3vQPbl5IKSlRQLil6VgsmE1hIu1eFEbQx74=;
        b=NMyAehe6JFrvDzK0o0k7ivWHR/WAgEYmeG+ZSsEKSr1OF56N6qvSfnMUIJE72ZNfLC
         3C0NDd3FKEujWoJuLUlLjiLO/O13sJbdj0gmzJgss4YqdSzo+C898LLfqNZFEgdsjLFn
         UX1QukprgJMj5fTLkRrjK6/alcGWQF8mW6aMo335/jtGkLkjRo0QER1/4SISoqAEnfbl
         0eONp2bTGmI+HWyoSmUGoxQ+ndouumBaN53GUxgD/36HZppEqpyCUZXxBO8f22fuvDYu
         lm8WV2M3AOr145B2SCatd0cy0e9rfC7LCIwPrHLzBv12/5k0ZRxZx5UD+QAPD4FjqMtI
         wBdQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc;
        bh=Jolb7Z2E3vQPbl5IKSlRQLil6VgsmE1hIu1eFEbQx74=;
        b=zQbV/kNGbMyt3ktN7qMRdDKMRpYHEOoFJOVR5dbprw+QGeDiXBoPMOSdu8Vmw7Qv9D
         oJWiaG7WadJ0uiIfCe/et33wj+H9G1/NnKKo1iRBMvSS1MaoylLPWZopIYCAV3GID9tF
         wAyBtiWoxsgWnWIPU+n4bcAvjqma4s9RwKfZ7E1GzKUoy/s5b0NPPc/IrDEDx2AjzDe5
         JbeFRYJ8jC4xbSAdS5GD3xWLJ1UpG/ypq9OSWYUMlVF50+m9ZWGTafoWZu2An3LB3Fwh
         iF9HaQynHM65qcG+KJUUlaeosKOSbgK8pptvsd2ep0gphJyKa0/7EieQRSlqRMP9DLcX
         8Kig==
X-Gm-Message-State: AOAM5335f7dunn6nYcXw2hfp7L8titPQNzAoZZLkh8TztC02JebYjeJW
        oCb+ltYG6ZnkCuGBfqolag0cmkiBRkdwc6ukxeXC
X-Google-Smtp-Source: ABdhPJwRrhPSJNMuYDnyiTs9XT+eCI/7geA7mQVYBBaRGEqrkv/s51N3owOCPU+A7cUhUd/5tWXCxsHI4JIFMWpxV7U=
X-Received: by 2002:a17:907:868f:: with SMTP id qa15mr42542158ejc.187.1638758663920;
 Sun, 05 Dec 2021 18:44:23 -0800 (PST)
MIME-Version: 1.0
References: <20211124014332.36128-1-casey@schaufler-ca.com> <20211124014332.36128-4-casey@schaufler-ca.com>
In-Reply-To: <20211124014332.36128-4-casey@schaufler-ca.com>
From:   Paul Moore <paul@paul-moore.com>
Date:   Sun, 5 Dec 2021 21:44:13 -0500
Message-ID: <CAHC9VhTOMt3NSvpJ2uE4tD4t3PTK6p6_ribSOXwRo8nucZ2XqA@mail.gmail.com>
Subject: Re: [PATCH v30 03/28] LSM: Add the lsmblob data structure.
To:     Casey Schaufler <casey@schaufler-ca.com>
Cc:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org,
        linux-audit@redhat.com, keescook@chromium.org,
        john.johansen@canonical.com, penguin-kernel@i-love.sakura.ne.jp,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Content-Type: text/plain; charset="UTF-8"
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, Nov 23, 2021 at 8:47 PM Casey Schaufler <casey@schaufler-ca.com> wrote:
>
> When more than one security module is exporting data to
> audit and networking sub-systems a single 32 bit integer
> is no longer sufficient to represent the data. Add a
> structure to be used instead.
>
> The lsmblob structure is currently an array of
> u32 "secids". There is an entry for each of the
> security modules built into the system that would
> use secids if active. The system assigns the module
> a "slot" when it registers hooks. If modules are
> compiled in but not registered there will be unused
> slots.
>
> A new lsm_id structure, which contains the name
> of the LSM and its slot number, is created. There
> is an instance for each LSM, which assigns the name
> and passes it to the infrastructure to set the slot.
>
> The audit rules data is expanded to use an array of
> security module data rather than a single instance.
> A new structure audit_rules is defined to avoid the
> confusion which commonly accompanies the use of
> void ** parameters.
>
> Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
> ---
>  include/linux/audit.h        | 10 ++++-
>  include/linux/lsm_hooks.h    | 12 +++++-
>  include/linux/security.h     | 74 +++++++++++++++++++++++++++++---
>  kernel/auditfilter.c         | 24 ++++++-----
>  kernel/auditsc.c             | 17 +++-----
>  security/apparmor/lsm.c      |  7 ++-
>  security/bpf/hooks.c         | 12 +++++-
>  security/commoncap.c         |  7 ++-
>  security/landlock/cred.c     |  2 +-
>  security/landlock/fs.c       |  2 +-
>  security/landlock/ptrace.c   |  2 +-
>  security/landlock/setup.c    |  5 +++
>  security/landlock/setup.h    |  1 +
>  security/loadpin/loadpin.c   |  8 +++-
>  security/lockdown/lockdown.c |  7 ++-
>  security/safesetid/lsm.c     |  8 +++-
>  security/security.c          | 82 ++++++++++++++++++++++++++++++------
>  security/selinux/hooks.c     |  8 +++-
>  security/smack/smack_lsm.c   |  7 ++-
>  security/tomoyo/tomoyo.c     |  8 +++-
>  security/yama/yama_lsm.c     |  7 ++-
>  21 files changed, 254 insertions(+), 56 deletions(-)
>
> diff --git a/include/linux/audit.h b/include/linux/audit.h
> index d06134ac6245..943584128399 100644
> --- a/include/linux/audit.h
> +++ b/include/linux/audit.h
> @@ -11,6 +11,7 @@
>
>  #include <linux/sched.h>
>  #include <linux/ptrace.h>
> +#include <linux/security.h>
>  #include <linux/audit_arch.h>
>  #include <uapi/linux/audit.h>
>  #include <uapi/linux/netfilter/nf_tables.h>
> @@ -59,6 +60,10 @@ struct audit_krule {
>  /* Flag to indicate legacy AUDIT_LOGINUID unset usage */
>  #define AUDIT_LOGINUID_LEGACY          0x1
>
> +struct audit_rules {
> +       void    *rule[LSMBLOB_ENTRIES];
> +};

It would be nice to call this struct "audit_lsm_rules" to help
distinguish it from general audit filter rules.

>  struct audit_field {
>         u32                             type;
>         union {
> @@ -66,8 +71,9 @@ struct audit_field {
>                 kuid_t                  uid;
>                 kgid_t                  gid;
>                 struct {
> -                       char            *lsm_str;
> -                       void            *lsm_rule;
> +                       bool                    lsm_isset;
> +                       char                    *lsm_str;
> +                       struct audit_rules      lsm_rules;
>                 };

Is lsm_isset strictly necessary?  Unless I missed something it seems
like a NULL check on lsm_str would serve the same purpose.

--
paul moore
www.paul-moore.com

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id D786AC43217
	for <linux-kernel@archiver.kernel.org>; Mon,  6 Dec 2021 02:44:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234838AbhLFCsJ (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Sun, 5 Dec 2021 21:48:09 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55280 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234736AbhLFCsI (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 5 Dec 2021 21:48:08 -0500
Received: from mail-ed1-x52e.google.com (mail-ed1-x52e.google.com [IPv6:2a00:1450:4864:20::52e])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 419B7C061354
        for <linux-kernel@vger.kernel.org>; Sun,  5 Dec 2021 18:44:40 -0800 (PST)
Received: by mail-ed1-x52e.google.com with SMTP id l25so36803044eda.11
        for <linux-kernel@vger.kernel.org>; Sun, 05 Dec 2021 18:44:40 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=paul-moore-com.20210112.gappssmtp.com; s=20210112;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc;
        bh=ZEpXl2rjEsQ/iZu4ZR5a4fZjtkeItsGvSxcWdc7M5Zk=;
        b=fEC0JL3Q3DjRFMGWonua7hcYvacbTymemEAL9m0L1IKQTYU7jXdvqbKOdfIpkZL9PP
         LOK81AbIdOhxqqfzvEagihtDvbP1lSk6FfLLVqgzCsbu5dYFHc4zoGRR1IZWg6MR2JQG
         akNV1TgQ9qiDpcTn8e1M942LzVjUjeeuaeihjCg3eoPQzL/111zPayRC0gOZcZYOyB2a
         1kUox4ZvMvtFNj5mlra3Cu3c6819pwgWHkTbqGqFxvuFkMjsQNcG6PMSgVL/3KCm1MEQ
         99sze4mx73lV+Lc2HQOjxFTsVw8RZXRn24p2v1pC0xXiRVRSo3Tsp9/DID/WopxTP8d7
         CBTw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc;
        bh=ZEpXl2rjEsQ/iZu4ZR5a4fZjtkeItsGvSxcWdc7M5Zk=;
        b=F7pDNuRFUR6TVnBkC2+YWEUXxpGv79eFVFtsQuikjIc8TLmZjndyAnDEP0JuEd/Dok
         F73lLcpS+jb/BDIIz//HifTL8TvP1wamgCwZw8YdO7LjI3PmZK4GElKYvEaueNckF+Mn
         dGOUU+j+lndpv4hUO36/AmdujKXXRy3Qar1ogBgYjD+vaWuK8dQL3xNOEjdORSnNgcP9
         WgnoPvSF7Shvv/PUzDGQOlyGC7RYtauSfXOhMdfrP58Rmsas0G+dzOC74rIY7eS1jt8y
         jdMskGBYIT1eZjZgGqh/KQjajufJSzcbMmjNKSv0d2PFf9sMLULJ8FlEDtSRDBfTFOmB
         h0dg==
X-Gm-Message-State: AOAM532N4Uga4KUdDIzqQkNED0+73OFSrUCvzFZY74fRvdxiiuVhIvpN
        fm6ynCycIaQRmnIo5Ht7KG/A9VNRGsB3w5DW5LK+
X-Google-Smtp-Source: ABdhPJz88VaoH/gPDTPj32gZHevyPs1vCaW00GNL3rgM+vqLPf2Urzonomb/cc2eL8/nvqRm7/jHabq1R3VDBOzvnNo=
X-Received: by 2002:a17:907:9196:: with SMTP id bp22mr40290591ejb.69.1638758678834;
 Sun, 05 Dec 2021 18:44:38 -0800 (PST)
MIME-Version: 1.0
References: <20211124014332.36128-1-casey@schaufler-ca.com> <20211124014332.36128-7-casey@schaufler-ca.com>
In-Reply-To: <20211124014332.36128-7-casey@schaufler-ca.com>
From:   Paul Moore <paul@paul-moore.com>
Date:   Sun, 5 Dec 2021 21:44:28 -0500
Message-ID: <CAHC9VhRnFehuM4ODOMeUo9MZ-6K5bDL6KdakgzrivJKeUGDQFA@mail.gmail.com>
Subject: Re: [PATCH v30 06/28] LSM: Use lsmblob in security_audit_rule_match
To:     Casey Schaufler <casey@schaufler-ca.com>
Cc:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org,
        linux-audit@redhat.com, keescook@chromium.org,
        john.johansen@canonical.com, penguin-kernel@i-love.sakura.ne.jp,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Content-Type: text/plain; charset="UTF-8"
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, Nov 23, 2021 at 8:50 PM Casey Schaufler <casey@schaufler-ca.com> wrote:
>
> Change the secid parameter of security_audit_rule_match
> to a lsmblob structure pointer. Pass the entry from the
> lsmblob structure for the approprite slot to the LSM hook.
>
> Change the users of security_audit_rule_match to use the
> lsmblob instead of a u32. The scaffolding function lsmblob_init()
> fills the blob with the value of the old secid, ensuring that
> it is available to the appropriate module hook. The sources of
> the secid, security_task_getsecid() and security_inode_getsecid(),
> will be converted to use the blob structure later in the series.
> At the point the use of lsmblob_init() is dropped.
>
> Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
> Cc: linux-audit@redhat.com
> ---
>  include/linux/security.h |  5 +++--
>  kernel/auditfilter.c     |  6 ++++--
>  kernel/auditsc.c         | 16 +++++++++++-----
>  security/security.c      |  5 +++--
>  4 files changed, 21 insertions(+), 11 deletions(-)
>
> diff --git a/include/linux/security.h b/include/linux/security.h
> index ddd4cf48413c..d846d90f5624 100644
> --- a/include/linux/security.h
> +++ b/include/linux/security.h
> @@ -1954,7 +1954,7 @@ static inline int security_key_getsecurity(struct key *key, char **_buffer)
>  int security_audit_rule_init(u32 field, u32 op, char *rulestr,
>                              struct audit_rules *lsmrules);
>  int security_audit_rule_known(struct audit_krule *krule);
> -int security_audit_rule_match(u32 secid, u32 field, u32 op,
> +int security_audit_rule_match(struct lsmblob *blob, u32 field, u32 op,
>                               struct audit_rules *lsmrules);
>  void security_audit_rule_free(struct audit_rules *lsmrules);
>
> @@ -1971,7 +1971,8 @@ static inline int security_audit_rule_known(struct audit_krule *krule)
>         return 0;
>  }
>
> -static inline int security_audit_rule_match(u32 secid, u32 field, u32 op,
> +static inline int security_audit_rule_match(struct lsmblob *blob secid,
> +                                           u32 field, u32 op,
>                                             struct audit_rules *lsmrules)
>  {
>         return 0;

Assuming you fixup the typo above that the test robot found it looks
reasonable to me.

Acked-by: Paul Moore <paul@paul-moore.com>

--
paul moore
www.paul-moore.com

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id E43B3C433FE
	for <linux-kernel@archiver.kernel.org>; Mon,  6 Dec 2021 02:44:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234913AbhLFCsS (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Sun, 5 Dec 2021 21:48:18 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55332 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234877AbhLFCsR (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 5 Dec 2021 21:48:17 -0500
Received: from mail-ed1-x533.google.com (mail-ed1-x533.google.com [IPv6:2a00:1450:4864:20::533])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id E53A1C061359
        for <linux-kernel@vger.kernel.org>; Sun,  5 Dec 2021 18:44:48 -0800 (PST)
Received: by mail-ed1-x533.google.com with SMTP id l25so36803940eda.11
        for <linux-kernel@vger.kernel.org>; Sun, 05 Dec 2021 18:44:48 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=paul-moore-com.20210112.gappssmtp.com; s=20210112;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc;
        bh=QwrOTleNvelk5p5BDjcQ97ZYJxlrPxB5VMlww1oIuLE=;
        b=y2wuwSzXt84lZj63b2WI7/Ekw0WAaeL+GkQ/WfSRUm5yOH600JCdGyra8wrwKGTV/a
         gXbLSCE/8PkSnFSKzXmSNgfTCgYQ6frUoz12quMOSJ7jpCxcNmhmkKOH8N2MBFBbhbOR
         8gsLoVAPHWNyKxAs5hgtL6lORTWUkw7g1NP62RwFxzAT2mjaUR57eRyMAAQsRh0+D8nS
         JrKZvi3HqGNuMWgcDSJo2CQ35JhrJBha30Qh4O6f8R9gsW82Rx5t9iLZXOf1GywOAYxs
         HIJMKwQ9kbZZBHz6SUEpM5Q3VGj1KXfH0gyw4ecs41Sm4HHZ0A5WLynWq0dq5/SHveBw
         c5Wg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc;
        bh=QwrOTleNvelk5p5BDjcQ97ZYJxlrPxB5VMlww1oIuLE=;
        b=HP6u7tRU1QTautCsjPM+bwpNef+oUKKwwtpssRp5Hr+1YLrg/iQRJTASkbs3PP2dfE
         /zx+Ok4hdA+zKe4dCC45/hTCa09ofgw9GOqLTPGMH/4UNSuOAXYOkLJnhUlnTTxWYoTk
         8tmCV21xlAMTVop13AWz5gucdOUjIodvqk3EKQbnY2F06DGiyRN6QwkRKZndTK4Y7zN+
         HlbDECFc8DbM55lPDhPIvhmBEvb+jRoSSR7g9e53Kzity7b76rkqdpWwdMTTblImdtjF
         vbZREr+w1CnBtGupZEQrmI4f0uZ2xsQiRK7rLkJGhqK/ajNy6nwjoRCwQOTYTmeCwRgr
         GFdw==
X-Gm-Message-State: AOAM531/IldP8TPFsPm2OKxKgQXj0sNe4SzGMvFyaRiI7a/GvtmoiyUc
        70PSBsZ80xQAq3G0YpEjzLgyg377gXFhNtubSh9b
X-Google-Smtp-Source: ABdhPJwxvsJ8Ii2vt7If/p7huJgKo6ZVH6nQnuWVUB09BvQKN1/5/qWv8/v9f67OJ4VChwQbr5Rc8EVGUbg9IXxtziE=
X-Received: by 2002:a17:906:d96e:: with SMTP id rp14mr41344264ejb.104.1638758687494;
 Sun, 05 Dec 2021 18:44:47 -0800 (PST)
MIME-Version: 1.0
References: <20211124014332.36128-1-casey@schaufler-ca.com> <20211124014332.36128-23-casey@schaufler-ca.com>
In-Reply-To: <20211124014332.36128-23-casey@schaufler-ca.com>
From:   Paul Moore <paul@paul-moore.com>
Date:   Sun, 5 Dec 2021 21:44:36 -0500
Message-ID: <CAHC9VhSupFaTHp7FZ1y8XM1ZTUebyaQCVs0McMM40rJKi8qqgw@mail.gmail.com>
Subject: Re: [PATCH v30 22/28] Audit: Keep multiple LSM data in audit_names
To:     Casey Schaufler <casey@schaufler-ca.com>
Cc:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org,
        linux-audit@redhat.com, keescook@chromium.org,
        john.johansen@canonical.com, penguin-kernel@i-love.sakura.ne.jp,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Content-Type: text/plain; charset="UTF-8"
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, Nov 23, 2021 at 9:07 PM Casey Schaufler <casey@schaufler-ca.com> wrote:
>
> Replace the osid field in the audit_names structure
> with a lsmblob structure. This accomodates the use
> of an lsmblob in security_audit_rule_match() and
> security_inode_getsecid().
>
> Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
> ---
>  kernel/audit.h   |  2 +-
>  kernel/auditsc.c | 22 ++++++++--------------
>  2 files changed, 9 insertions(+), 15 deletions(-)

Acked-by: Paul Moore <paul@paul-moore.com>

--
paul moore
www.paul-moore.com

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 1003DC433F5
	for <linux-kernel@archiver.kernel.org>; Mon,  6 Dec 2021 02:45:05 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234938AbhLFCsb (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Sun, 5 Dec 2021 21:48:31 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55400 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234932AbhLFCs2 (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 5 Dec 2021 21:48:28 -0500
Received: from mail-ed1-x52b.google.com (mail-ed1-x52b.google.com [IPv6:2a00:1450:4864:20::52b])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 26EA9C0613F8
        for <linux-kernel@vger.kernel.org>; Sun,  5 Dec 2021 18:45:00 -0800 (PST)
Received: by mail-ed1-x52b.google.com with SMTP id v1so36975937edx.2
        for <linux-kernel@vger.kernel.org>; Sun, 05 Dec 2021 18:45:00 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=paul-moore-com.20210112.gappssmtp.com; s=20210112;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc;
        bh=MPkDgfSi39yTo3lA/qjUWlLR+uwbqkTX1ixff0nrnrA=;
        b=SFmn2wVsvV+hAxDhb7OcQgutgDiQ0TcwF/tXl2AWq0Ff5K2IUrX0rynCLNKdQozDNK
         Se63NXOlWvajuN06XNGP18fkfeARwldpEyDOO7+AC5M9VLfCa+Maykv/mzdBazqpnxzf
         yMziZm2AxVVcuEP+paOzfP2cVkf8+tG+9r7L3fd6B/a7WjR0Jfq1htp0PHS8zGXUl4OC
         XkcM072wzlerKetR69/pYPg+2xVaUZOZ5FvmQFrHAXbXYDFgmIwHKlxKj58WGvKm39y1
         5Hth9HZsjfIvXqVFg9ESfILQx1iIswyVG99BONxVpC7fi6YFyp8htDAqI2kAFRALvOQn
         WB4Q==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc;
        bh=MPkDgfSi39yTo3lA/qjUWlLR+uwbqkTX1ixff0nrnrA=;
        b=3cOn0misMPDrzGtWThAyI1zBLzAQjtm/mbjgni8SIDrRB4Ah5akfqA5E71wMBU4ojn
         40P1Imsri6utFB8iohfLmNL/4q8yKd+TuAEganwzoHetgurcTcjL56+pp0c/UVvKjRIs
         Ml1amKW3w6R/taTKjxdBevpYmnLKY/aDCUH5QZ3SBHidzhO/ky3qIm9pym336dXUGFGU
         hQfhunJsJxurJ0qhbn2EARsJT9EMrZoHNvqRbWuTwkARuDdFbNolGpTzvj2nPbLNj82t
         KsiOSxtSA4bU0BeJJOijZhP0QJIa35wi+BjudXdlLotLA1pVStiw4KTacZSXSBhsU87s
         je4w==
X-Gm-Message-State: AOAM5323xtFuB23s3DKtFBpfuijxh3ARnP3D1JUuVhuWDhFg0/0AnT7y
        4FJUcDw3/xcfZklHXf2TrrGr6gZTvTM9rlf0/G8M
X-Google-Smtp-Source: ABdhPJzW5eYEzA65lBlc1aKKHLqgHO6wHSlCcEI7uABDh3oOz2BbJsPx6uCf1VOYbxXAxj1GKlV68FSntswX2zKhjxc=
X-Received: by 2002:a17:907:7dac:: with SMTP id oz44mr11834244ejc.307.1638758698688;
 Sun, 05 Dec 2021 18:44:58 -0800 (PST)
MIME-Version: 1.0
References: <20211124014332.36128-1-casey@schaufler-ca.com> <20211124014332.36128-24-casey@schaufler-ca.com>
In-Reply-To: <20211124014332.36128-24-casey@schaufler-ca.com>
From:   Paul Moore <paul@paul-moore.com>
Date:   Sun, 5 Dec 2021 21:44:47 -0500
Message-ID: <CAHC9VhRxkbb0L2gjMTt4eo7B0JUvPDT3hyA8FimieErp+vkweQ@mail.gmail.com>
Subject: Re: [PATCH v30 23/28] Audit: Create audit_stamp structure
To:     Casey Schaufler <casey@schaufler-ca.com>
Cc:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org,
        linux-audit@redhat.com, keescook@chromium.org,
        john.johansen@canonical.com, penguin-kernel@i-love.sakura.ne.jp,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Content-Type: text/plain; charset="UTF-8"
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, Nov 23, 2021 at 9:09 PM Casey Schaufler <casey@schaufler-ca.com> wrote:
>
> Replace the timestamp and serial number pair used in audit records
> with a structure containing the two elements.
>
> Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
> ---
>  kernel/audit.c   | 17 +++++++++--------
>  kernel/audit.h   | 12 +++++++++---
>  kernel/auditsc.c | 22 +++++++++-------------
>  3 files changed, 27 insertions(+), 24 deletions(-)

Acked-by: Paul Moore <paul@paul-moore.com>

--
paul moore
www.paul-moore.com

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 38277C4332F
	for <linux-kernel@archiver.kernel.org>; Mon,  6 Dec 2021 02:45:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235001AbhLFCso (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Sun, 5 Dec 2021 21:48:44 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55478 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234940AbhLFCsn (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 5 Dec 2021 21:48:43 -0500
Received: from mail-ed1-x534.google.com (mail-ed1-x534.google.com [IPv6:2a00:1450:4864:20::534])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id B9CA5C061354
        for <linux-kernel@vger.kernel.org>; Sun,  5 Dec 2021 18:45:15 -0800 (PST)
Received: by mail-ed1-x534.google.com with SMTP id g14so36429870edb.8
        for <linux-kernel@vger.kernel.org>; Sun, 05 Dec 2021 18:45:15 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=paul-moore-com.20210112.gappssmtp.com; s=20210112;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc;
        bh=wAqLEhawabMbQV194y5YFmZq2jiOl3Yl5uRuU1ILn/c=;
        b=E5qnU4tVTah85BsdBfEOSw8FvPnK0S2mHV4cqaySt2ugRRQ9RJz0RjTQ3jtsXRcg0T
         B8oE0Be0HDi65rxNyEsGA7fGY93pmUuaptb4LnK/oanKBGiOj+PZbdR4kAfvDSn+ACnD
         qjLAruh1qWxbXQ5aRfd2XeXmlaXJ8Ea8yJxCJ5Hd97wa0cWLEN+xUCTThKLbqArl2XTc
         3nje08+L8SZ25fCoIn7hjFIsBko6pXGK0IBrjRFMZki8ePUfD2Vxjw7XBpACYvFxgZoc
         exWY6w1wHXQqDwcHsNqf7MXGEoQCZoXhL79TqjipWv7zT/1+JaTG7TAA6LrloVtwJnXJ
         tm6Q==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc;
        bh=wAqLEhawabMbQV194y5YFmZq2jiOl3Yl5uRuU1ILn/c=;
        b=4CYRug3B36X14U5UzLECC1AlxiBF8c/Ko1Uui6Sf7CUU4sbngN9fIpZ6TRHct4w0PC
         DWxKD9tF4IYWNl3xKQtKJ93IV+PBQXO8E0fM3bd66xl0FyWy+8a7QPcpgf/J15f23fe3
         IiMYOoc6y+0XTrc/PtKKc57OoZfTTQOAurCr2Mb4OJAOmgh9AtHM4brBULpgC2Sk5i7z
         53SytpsOqQf+Qs9zm1dZ+hSeD5DNYv9rY5MEaNuVVu6ex7RMVx4WnWwFbYvVg922r4pl
         IlMiAODjvs5QkGIYJiiwXZ3q/1IW2YCY+aU04qjU5g75oPG8Y37Q94thhDUl8ziWv5Fh
         wzsw==
X-Gm-Message-State: AOAM5320IeBGy5jWijCOSzlBpwrcpIhoGy1tExLXyw/sSnpFP+4uZhKd
        8hcm/oJ04VT0or4TCEnqfTUxa5WT8+1ujQ+L8xon
X-Google-Smtp-Source: ABdhPJzUhTmcpWp+XkxysnbAKVRGWDWT+G+5mAL1GAUbzyGljvtUoDC5K0rY89HkFvjdEPc1fkJ2KYEXpZ73b/o9pKw=
X-Received: by 2002:a05:6402:4311:: with SMTP id m17mr50512266edc.103.1638758714336;
 Sun, 05 Dec 2021 18:45:14 -0800 (PST)
MIME-Version: 1.0
References: <20211124014332.36128-1-casey@schaufler-ca.com> <20211124014332.36128-25-casey@schaufler-ca.com>
In-Reply-To: <20211124014332.36128-25-casey@schaufler-ca.com>
From:   Paul Moore <paul@paul-moore.com>
Date:   Sun, 5 Dec 2021 21:45:03 -0500
Message-ID: <CAHC9VhS+jaTFbca7OFxoZ6uoUyaRoxjtm0m-K92px=61XUja5Q@mail.gmail.com>
Subject: Re: [PATCH v30 24/28] Audit: Add framework for auxiliary records
To:     Casey Schaufler <casey@schaufler-ca.com>
Cc:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org,
        linux-audit@redhat.com, keescook@chromium.org,
        john.johansen@canonical.com, penguin-kernel@i-love.sakura.ne.jp,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Content-Type: text/plain; charset="UTF-8"
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, Nov 23, 2021 at 9:10 PM Casey Schaufler <casey@schaufler-ca.com> wrote:
>
> Add a list for auxiliary record data to the audit_buffer structure.
> Add the audit_stamp information to the audit_buffer as there's no
> guarantee that there will be an audit_context containing the stamp
> associated with the event. At audit_log_end() time create auxiliary
> records (none are currently defined) as have been added to the list.
>
> Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
> ---
>  kernel/audit.c   | 85 ++++++++++++++++++++++++++++++++++++++++++------
>  kernel/audit.h   |  1 +
>  kernel/auditsc.c |  2 ++
>  3 files changed, 78 insertions(+), 10 deletions(-)

...

> diff --git a/kernel/audit.c b/kernel/audit.c
> index 069cd4c81a61..2b22498d3532 100644
> --- a/kernel/audit.c
> +++ b/kernel/audit.c
> @@ -2393,6 +2403,61 @@ void audit_log_end(struct audit_buffer *ab)
>                 wake_up_interruptible(&kauditd_wait);
>         } else
>                 audit_log_lost("rate limit exceeded");
> +}
> +
> +/**
> + * audit_log_end - end one audit record
> + * @ab: the audit_buffer
> + *
> + * Let __audit_log_end() handle the message while the buffer housekeeping
> + * is done here.
> + * If there are other records that have been deferred for the event
> + * create them here.
> + */
> +void audit_log_end(struct audit_buffer *ab)
> +{
> +       struct audit_context_entry *entry;
> +       struct audit_context mcontext;
> +       struct audit_context *mctx;
> +       struct audit_buffer *mab;
> +       struct list_head *l;
> +       struct list_head *n;
> +
> +       if (!ab)
> +               return;
> +
> +       __audit_log_end(ab);
> +
> +       if (list_empty(&ab->aux_records)) {
> +               audit_buffer_free(ab);
> +               return;
> +       }
> +
> +       if (ab->ctx == NULL) {
> +               mcontext.context = AUDIT_CTX_AUXRECORD;

More on this below, but I don't think we need, or want, the line above.

> diff --git a/kernel/audit.h b/kernel/audit.h
> index 56560846f3b0..f87da8e0a5a4 100644
> --- a/kernel/audit.h
> +++ b/kernel/audit.h
> @@ -112,6 +112,7 @@ struct audit_context {
>                 AUDIT_CTX_UNUSED,       /* audit_context is currently unused */
>                 AUDIT_CTX_SYSCALL,      /* in use by syscall */
>                 AUDIT_CTX_URING,        /* in use by io_uring */
> +               AUDIT_CTX_AUXRECORD,    /* in use for auxiliary records */
>         } context;

We shouldn't need to do this here, and I wouldn't recommend this as a
solution even if we were running into problems in audit_log_exit().
The "context" field in the audit_context struct is to identify the
execution context of the task which is generating the audit record(s).

I'm trying to think of a case in this patchset where you would find
"audit_context->context == AUDIT_CTX_AUXRECORD" and I keep coming up
blank, are you certain you hit that case with the code you posted
here?  If so, could you help me understand that situation?

--
paul moore
www.paul-moore.com

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 2B2ACC433FE
	for <linux-kernel@archiver.kernel.org>; Mon,  6 Dec 2021 02:45:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235016AbhLFCtF (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Sun, 5 Dec 2021 21:49:05 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55572 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234998AbhLFCtD (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 5 Dec 2021 21:49:03 -0500
Received: from mail-ed1-x529.google.com (mail-ed1-x529.google.com [IPv6:2a00:1450:4864:20::529])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 635C8C061359
        for <linux-kernel@vger.kernel.org>; Sun,  5 Dec 2021 18:45:35 -0800 (PST)
Received: by mail-ed1-x529.google.com with SMTP id l25so36808986eda.11
        for <linux-kernel@vger.kernel.org>; Sun, 05 Dec 2021 18:45:35 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=paul-moore-com.20210112.gappssmtp.com; s=20210112;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc;
        bh=gpFcj1uUZYTNq0+KmLnzmL35K736w79jGUcUQG+j0+4=;
        b=TEFlHWEQTHdyXsexdSs/rCzUwNtGbKZys0hfRMniE+H1e+0lKMTxgggMB1oTe9OUCv
         DcenEaj6jut/2kjLO+mgIa0fQ5zYF+dmvyrhxp7ecuPeSq8kkJyEA6pgjvDhzmHCGtqE
         bG8ZWxbwbtYpAtUkyz2txFgXoX0M4BLxnyAeHb2rg2lLTADwtVbOGn2AIUnSVSOvKZ3l
         TjP6/Hzni7Xpl9C9sv6eixR5+po55Xy8O2TkADnUREkVYBgeGKIwixPcgZyh+PO5INLk
         RHYmvEpIAZK4tls7VMKzUaazrEz+2OvFYwBAyb57LIAX6sHYK2Dr3J0uiZZoxupUPUoS
         o5eg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc;
        bh=gpFcj1uUZYTNq0+KmLnzmL35K736w79jGUcUQG+j0+4=;
        b=xmUu5xUIqyjtR7OUUOWZfFDgLq78s8jBI2u8ipomy1zrZ+ftJqqA2RBRxMvbHCXWfs
         vbR0x9VRbG6kH12jadbhrMeQwH++aFpH4AC+d9NH7Lj/4FCIc7Q7UPvh+hdWuYj6Xh95
         lzDEx9fG22kZg6baUPtm7m+0i5hRXOw2+BUnOv1PxjKVeZxamKlQnqsbGGncHsuPBuVj
         1QIfk8sQx+a7XP9qcGKIYN3Vsmj2z/fHCdgGwDUfh3p/l/jlIZ0lxfGIgmnCfsFQAe41
         raW/l+qYLg2XdXhnGy5cIUEV17OAoIz3jCHVAl/uwxCdBpcc8O+s0D6ZPMnYBxgCeGZI
         olXw==
X-Gm-Message-State: AOAM532iQeXdmB/i88zLLesJw3uRDavmT2cgxNkmrctGXCdv8xNLITWK
        Ik5+qggKN5R8ENOUECZ64dM7hUhr3edbCmhcZuHGqcQeCw==
X-Google-Smtp-Source: ABdhPJyiHNaMyVS5PZYMibcIrBXPL0EeazoGYH7BTBz49n1/LTfHIDjvW+a3ZvHguWuXDXri2ZZVdc+BfdO+UUfzUTs=
X-Received: by 2002:a05:6402:34cd:: with SMTP id w13mr49333749edc.112.1638758733909;
 Sun, 05 Dec 2021 18:45:33 -0800 (PST)
MIME-Version: 1.0
References: <20211124014332.36128-1-casey@schaufler-ca.com> <20211124014332.36128-26-casey@schaufler-ca.com>
In-Reply-To: <20211124014332.36128-26-casey@schaufler-ca.com>
From:   Paul Moore <paul@paul-moore.com>
Date:   Sun, 5 Dec 2021 21:45:23 -0500
Message-ID: <CAHC9VhTYudezmRyZxEGRL=ivwSDBmeh4nZ_qBkBZR9+LJxC8xg@mail.gmail.com>
Subject: Re: [PATCH v30 25/28] Audit: Add record for multiple task security contexts
To:     Casey Schaufler <casey@schaufler-ca.com>
Cc:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org,
        linux-audit@redhat.com, keescook@chromium.org,
        john.johansen@canonical.com, penguin-kernel@i-love.sakura.ne.jp,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Content-Type: text/plain; charset="UTF-8"
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, Nov 23, 2021 at 9:11 PM Casey Schaufler <casey@schaufler-ca.com> wrote:
>
> Create a new audit record AUDIT_MAC_TASK_CONTEXTS.
> An example of the MAC_TASK_CONTEXTS (1420) record is:
>
>     type=UNKNOWN[1420]
>     msg=audit(1600880931.832:113)
>     subj_apparmor="=unconfined"
>     subj_smack="_"
>
> When an audit event includes a AUDIT_MAC_TASK_CONTEXTS record
> the "subj=" field in other records in the event will be "subj=?".
> A AUDIT_MAC_TASK_CONTEXTS record is supplied when the system has
> multiple security modules that may make access decisions based
> on a subject security context.
>
> Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
> ---
>  include/linux/security.h   |  9 ++++++
>  include/uapi/linux/audit.h |  1 +
>  kernel/audit.c             | 66 ++++++++++++++++++++++++++++++++------
>  3 files changed, 67 insertions(+), 9 deletions(-)
>
> diff --git a/include/linux/security.h b/include/linux/security.h
> index 763dca314c00..b98545d2ae04 100644
> --- a/include/linux/security.h
> +++ b/include/linux/security.h
> @@ -231,6 +231,15 @@ static inline bool lsmblob_equal(struct lsmblob *bloba, struct lsmblob *blobb)
>  extern int lsm_name_to_slot(char *name);
>  extern const char *lsm_slot_to_name(int slot);
>
> +static inline bool lsm_multiple_contexts(void)
> +{
> +#ifdef CONFIG_SECURITY
> +       return lsm_slot_to_name(1) != NULL;
> +#else
> +       return false;
> +#endif
> +}
> +
>  /**
>   * lsmblob_value - find the first non-zero value in an lsmblob structure.
>   * @blob: Pointer to the data
> diff --git a/include/uapi/linux/audit.h b/include/uapi/linux/audit.h
> index 9176a095fefc..86ad3da4f0d4 100644
> --- a/include/uapi/linux/audit.h
> +++ b/include/uapi/linux/audit.h
> @@ -143,6 +143,7 @@
>  #define AUDIT_MAC_UNLBL_STCDEL 1417    /* NetLabel: del a static label */
>  #define AUDIT_MAC_CALIPSO_ADD  1418    /* NetLabel: add CALIPSO DOI entry */
>  #define AUDIT_MAC_CALIPSO_DEL  1419    /* NetLabel: del CALIPSO DOI entry */
> +#define AUDIT_MAC_TASK_CONTEXTS        1420    /* Multiple LSM task contexts */
>
>  #define AUDIT_FIRST_KERN_ANOM_MSG   1700
>  #define AUDIT_LAST_KERN_ANOM_MSG    1799
> diff --git a/kernel/audit.c b/kernel/audit.c
> index 2b22498d3532..6c93545a14f3 100644
> --- a/kernel/audit.c
> +++ b/kernel/audit.c
> @@ -197,6 +197,9 @@ static struct audit_ctl_mutex {
>  struct audit_context_entry {
>         struct list_head        list;
>         int                     type;   /* Audit record type */
> +       union {
> +               struct lsmblob  mac_task_context;

The name "mac_task_context" is awfully long, why not something like
"lsm_subjs" or similar?

> +       };
>  };
>
>  /* The audit_buffer is used when formatting an audit record.  The caller
> @@ -2139,6 +2142,21 @@ void audit_log_key(struct audit_buffer *ab, char *key)
>                 audit_log_format(ab, "(null)");
>  }
>
> +static int audit_add_aux_task(struct audit_buffer *ab, struct lsmblob *blob)
> +{
> +       struct audit_context_entry *ace;
> +
> +       ace = kzalloc(sizeof(*ace), GFP_KERNEL);

Instead of using GFP_KERNEL I would recommend using ab->gfp_mask to
ensure we don't run into allocation problems depending on the calling
context.

> +       if (!ace)
> +               return -ENOMEM;
> +
> +       INIT_LIST_HEAD(&ace->list);
> +       ace->type = AUDIT_MAC_TASK_CONTEXTS;

I would suggest one of the following:

A) Add a "type" parameter to the function and use it here so that this
function truly generic.
B) Leave the ace->type assignment alone and change the function name
to audit_add_mac_task_contexts().
C) Fold this entire function into audit_log_task_context().

Of the three, I think choice B makes the least amount of sense; if
this is a dedicated AUDIT_MAC_TASK_CONTEXTS function then it should
probably just live inside audit_log_task_context() (choice C).
Choosing between A and C is really a matter of deciding if you are
going to use this function elsewhere, and it doesn't appear that you
do so in this patchset.  Sure, other patchsets might make use of this
someday (or not), but if they do they can also extract it back out
into a separate function (if needed).

> +       ace->mac_task_context = *blob;
> +       list_add(&ace->list, &ab->aux_records);
> +       return 0;
> +}
> +
>  int audit_log_task_context(struct audit_buffer *ab)
>  {
>         int error;
> @@ -2149,16 +2167,22 @@ int audit_log_task_context(struct audit_buffer *ab)
>         if (!lsmblob_is_set(&blob))
>                 return 0;
>
> -       error = security_secid_to_secctx(&blob, &context, LSMBLOB_FIRST);
> -       if (error) {
> -               if (error != -EINVAL)
> -                       goto error_path;
> +       if (!lsm_multiple_contexts()) {
> +               error = security_secid_to_secctx(&blob, &context,
> +                                                LSMBLOB_FIRST);
> +               if (error) {
> +                       if (error != -EINVAL)
> +                               goto error_path;
> +                       return 0;
> +               }
> +               audit_log_format(ab, " subj=%s", context.context);
> +               security_release_secctx(&context);
>                 return 0;
>         }
> -
> -       audit_log_format(ab, " subj=%s", context.context);
> -       security_release_secctx(&context);
> -       return 0;
> +       audit_log_format(ab, " subj=?");
> +       error = audit_add_aux_task(ab, &blob);
> +       if (!error)
> +               return 0;

This is very bikeshed-y, but from a style perspective I would prefer
to see something like this:

  if (!lsm_multiple_contexts()) {
    /* existing, single LSM code */
  } else {
    /* new, multiple LSM code */
  }
  return error;

IMO it makes it a bit more clear that each code path is equally likely
and neither is an exception.

>  error_path:
>         audit_panic("error in audit_log_task_context");
> @@ -2419,9 +2443,12 @@ void audit_log_end(struct audit_buffer *ab)
>         struct audit_context_entry *entry;
>         struct audit_context mcontext;
>         struct audit_context *mctx;
> +       struct lsmcontext lcontext;
>         struct audit_buffer *mab;
>         struct list_head *l;
>         struct list_head *n;
> +       int rc;
> +       int i;
>
>         if (!ab)
>                 return;
> @@ -2448,7 +2475,28 @@ void audit_log_end(struct audit_buffer *ab)
>                         continue;
>                 }
>                 switch (entry->type) {
> -               /* Don't know of any quite yet. */
> +               case AUDIT_MAC_TASK_CONTEXTS:
> +                       for (i = 0; i < LSMBLOB_ENTRIES; i++) {
> +                               if (entry->mac_task_context.secid[i] == 0)
> +                                       continue;
> +                               rc = security_secid_to_secctx(
> +                                               &entry->mac_task_context,
> +                                               &lcontext, i);
> +                               if (rc) {
> +                                       if (rc != -EINVAL)
> +                                               audit_panic("error in audit_log_end");
> +                                       audit_log_format(mab, "%ssubj_%s=\"?\"",

I don't believe you need the quotes around the question mark here, you
should be able to treat it just like it was "subj=?".

> +                                                        i ? " " : "",
> +                                                        lsm_slot_to_name(i));
> +                               } else {
> +                                       audit_log_format(mab, "%ssubj_%s=\"%s\"",

Same as above.

> +                                                        i ? " " : "",
> +                                                        lsm_slot_to_name(i),
> +                                                        lcontext.context);
> +                                       security_release_secctx(&lcontext);
> +                               }
> +                       }
> +                       break;
>                 default:
>                         audit_panic("Unknown type in audit_log_end");
>                         break;
> --
> 2.31.1

--
paul moore
www.paul-moore.com

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-kernel-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id DBC6DC433EF
	for <linux-kernel@archiver.kernel.org>; Mon,  6 Dec 2021 02:45:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235033AbhLFCtW (ORCPT <rfc822;linux-kernel@archiver.kernel.org>);
        Sun, 5 Dec 2021 21:49:22 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55638 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235087AbhLFCtQ (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 5 Dec 2021 21:49:16 -0500
Received: from mail-ed1-x535.google.com (mail-ed1-x535.google.com [IPv6:2a00:1450:4864:20::535])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 42F37C061A83
        for <linux-kernel@vger.kernel.org>; Sun,  5 Dec 2021 18:45:47 -0800 (PST)
Received: by mail-ed1-x535.google.com with SMTP id l25so36810236eda.11
        for <linux-kernel@vger.kernel.org>; Sun, 05 Dec 2021 18:45:47 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=paul-moore-com.20210112.gappssmtp.com; s=20210112;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc;
        bh=VAcTNxIoqCQKh3qNem4ztjrqCuOStoYB0zt6jOti2fM=;
        b=703KD5Dy4S07b9NOPcCmckxiV0xThMuw4v47XWcKh8lVlj3SkIuvNeZdbm6rtttJel
         CN1ckcWbD8/lbxT4Jwj+Y9gry7ibQtpUGc2tCO4pCZdTKs75VlJ4X/lX3aLz6kfxqH5s
         RVGGKWr5b9VnjrWfNG1lQe32LNCc7grW0slWsI2NP7mNnelc2IvDa0o0W+HAIGDA6yGd
         1PQHfOUJspyH3RGay4LqaD1Y2PpsBDnBH5I5x5jgc2eX+fBsApvjdfVlTLnwgcAQkZr/
         MBjazrjlZfjHGuF5GqpAmlnUYYIi+g3zgn5RR1ZcD25u2wOZvz+9wxnZc14HbFsN7+/J
         A1AA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc;
        bh=VAcTNxIoqCQKh3qNem4ztjrqCuOStoYB0zt6jOti2fM=;
        b=Xh0d7aUtofO0DM/Fhd0bMRUkV6JUNxgpyA+8sBdy286XGkGEiB7UPb8tAZ0lWn1Z3I
         4dJbUx+nZR/Hi6xbtmpCCCVMrxOn6OWLdBmNKE4A+fUs0EEc9WkJF5nNvcMkATB/kYzI
         c6B8Le1wm3SjMtwN4WHlvjMBg2JGLwiga3cqfG3Qa19mXZ1NOyBkYk5FEzZARGMmCjAN
         NjB8nnRUeO/ED+1f8VZ3XRNrCXgZVMOH2B8tg9tYyFbej5mJT36qrSZSt/oheWKMh7JQ
         ObWaEc6xY3hP2VI9dXV9wdVTDfQFRYl7LtqVeAQaJRpU3cKETAHcrv+Oirh6TCuXsS33
         XzAw==
X-Gm-Message-State: AOAM532yD0xTJvYd57r+D+ubC64yF/yVqUo2hUUEF6orj7UlRCfNy4DA
        mTI2qdRK02yDBVAQ+ImialCNPADF04hSliRQSkDw
X-Google-Smtp-Source: ABdhPJyE9y+VM2HvH+c1uVgAwAlchDezHWdVaNNETBQPLD1t/75CgFz9OPD/I9SGTBk/kp26WnSO6nK1FyFfZCw6tW0=
X-Received: by 2002:a05:6402:12d3:: with SMTP id k19mr50498858edx.244.1638758745874;
 Sun, 05 Dec 2021 18:45:45 -0800 (PST)
MIME-Version: 1.0
References: <20211124014332.36128-1-casey@schaufler-ca.com> <20211124014332.36128-27-casey@schaufler-ca.com>
In-Reply-To: <20211124014332.36128-27-casey@schaufler-ca.com>
From:   Paul Moore <paul@paul-moore.com>
Date:   Sun, 5 Dec 2021 21:45:35 -0500
Message-ID: <CAHC9VhQxS4W_WEcLavy9QY_-85sGNMY+DOgx_Ch_GpR8D_9qnw@mail.gmail.com>
Subject: Re: [PATCH v30 26/28] Audit: Add record for multiple object security contexts
To:     Casey Schaufler <casey@schaufler-ca.com>
Cc:     casey.schaufler@intel.com, jmorris@namei.org,
        linux-security-module@vger.kernel.org, selinux@vger.kernel.org,
        linux-audit@redhat.com, keescook@chromium.org,
        john.johansen@canonical.com, penguin-kernel@i-love.sakura.ne.jp,
        sds@tycho.nsa.gov, linux-kernel@vger.kernel.org
Content-Type: text/plain; charset="UTF-8"
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, Nov 23, 2021 at 9:12 PM Casey Schaufler <casey@schaufler-ca.com> wrote:
>
> Create a new audit record AUDIT_MAC_OBJ_CONTEXTS.
> An example of the MAC_OBJ_CONTEXTS (1421) record is:
>
>     type=UNKNOWN[1421]
>     msg=audit(1601152467.009:1050):
>     obj_selinux="unconfined_u:object_r:user_home_t:s0"
>
> When an audit event includes a AUDIT_MAC_OBJ_CONTEXTS record
> the "obj=" field in other records in the event will be "obj=?".
> A AUDIT_MAC_OBJ_CONTEXTS record is supplied when the system has
> multiple security modules that may make access decisions based
> on an object security context.
>
> Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
> ---
>  include/linux/audit.h      |  5 ++++
>  include/uapi/linux/audit.h |  1 +
>  kernel/audit.c             | 61 ++++++++++++++++++++++++++++++++++++++
>  kernel/auditsc.c           | 37 ++++-------------------
>  4 files changed, 72 insertions(+), 32 deletions(-)

My comments on 24/28 and 25/28 should also apply to this patch.

--
paul moore
www.paul-moore.com

