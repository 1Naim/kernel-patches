diff --git a/Documentation/ABI/testing/sysfs-block b/Documentation/ABI/testing/sysfs-block
index 80d4becc4e6d66ab397ce257036dd4056d04ce3f..26931894084bf6d44e37a46b92d30e97af45ad25 100644
--- a/Documentation/ABI/testing/sysfs-block
+++ b/Documentation/ABI/testing/sysfs-block
@@ -330,7 +330,7 @@ Description:
 		the request, to fail it or to start a device recovery strategy.
 
 What:		/sys/block/<disk>/linked_leds
-Date:		September 2021
+Date:		October 2021
 Contact:	Ian Pilcher <arequipeno@gmail.com>
 Description:
 		Directory containing links to all LEDs that are associated
diff --git a/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev b/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
index fe5184243e6423f9d5bae59909bffa3550ec46c0..ee80e97e0a03ec2c69d992b241eb3f122a832db4 100644
--- a/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
+++ b/Documentation/ABI/testing/sysfs-class-led-trigger-blkdev
@@ -1,21 +1,48 @@
 What:		/sys/class/leds/<led>/blink_time
-Date:		September 2021
+Date:		October 2021
 Contact:	Ian Pilcher <arequipeno@gmail.com>
 Description:
 		Time (in milliseconds) that the LED will be on during a single
 		"blink".
 
-What:		/sys/class/leds/<led>/mode
-Date:		September 2021
+What:		/sys/class/leds/<led>/check_interval
+Date:		October 2021
 Contact:	Ian Pilcher <arequipeno@gmail.com>
 Description:
-		Type of events for which LED will blink - read, write,
-		or rw (both).  Note that any activity that changes the state of
-		the device's non-volatile storage (including discards and cache
-		flushes) is considered to be a write.
+		Frequency (in milliseconds) with which block devices linked to
+		this LED will be checked for activity and the LED will
+		(potentially) be blinked.
+
+What:		/sys/class/leds/<led>/blink_on_read
+Date:		October 2021
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to read activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/blink_on_write
+Date:		October 2021
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to write activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/blink_on_discard
+Date:		October 2021
+Contact:	Ian Pilcher <arequipeno@gmail.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to discard activity on any of its linked block devices.
+
+What:		/sys/class/leds/<led>/blink_on_flush
+Date:		October 2021
+Contact:	Ian Pilcher <arequipeno@gamil.com>
+Description:
+		Boolean that determines whether the LED will blink in response
+		to cache flush activity on any of its linked block devices.
 
 What:		/sys/class/leds/<led>/link_device
-Date:		September 2021
+Date:		October 2021
 Contact:	Ian Pilcher <arequipeno@gmail.com>
 Description:
 		Associate a block device with this LED by writing the path to
@@ -23,7 +50,7 @@ Description:
 		Symbolic links are followed.
 
 What:		/sys/class/leds/<led>/unlink_device
-Date:		September 2021
+Date:		October 2021
 Contact:	Ian Pilcher <arequipeno@gmail.com>
 Description:
 		Remove the association between this LED and a block device by
@@ -31,7 +58,7 @@ Description:
 		this attribute.  Symbolic links are followed.
 
 What:		/sys/class/leds/<led>/linked_devices
-Date:		September 2021
+Date:		October 2021
 Contact:	Ian Pilcher <arequipeno@gmail.com>
 Description:
 		Directory containing links to all block devices that are
@@ -39,10 +66,3 @@ Description:
 		symbolic links in this directory are *kernel* names, which
 		may not match the device special file paths written to
 		link_device and unlink_device.)
-
-What:		/sys/class/ledtrig_blkdev/interval
-Date:		September 2021
-Contact:	Ian Pilcher <arequipeno@gmail.com>
-Description:
-		Frequency (in milliseconds) with which block devices associated
-		with the blkdev LED trigger will be checked for activity.
diff --git a/Documentation/leds/ledtrig-blkdev.rst b/Documentation/leds/ledtrig-blkdev.rst
index 5be141add33f5fc8af5250d6bc41b41c95b80232..14b598bb07e9880f1a08506783cd7e3fdcc12af8 100644
--- a/Documentation/leds/ledtrig-blkdev.rst
+++ b/Documentation/leds/ledtrig-blkdev.rst
@@ -44,14 +44,18 @@ Note that several new device attributes are available in the
   devices associated with this LED.  The LED will blink in response to read or
   write activity on its linked devices.
 
-* ``mode`` is used to control the type of device activity that will cause this
-  LED to blink - read activity, write activity, or both.  (Note that any
-  activity that changes the state of a device's non-volatile storage is
-  considered to be a write.  This includes discard and cache flush requests.)
+* ``blink_on_read``, ``blink_on_write``, ``blink_on_discard``, and
+  ``blink_on_flush`` are boolean values that determine whether the LED will
+  blink when a particular type of activity is detected on one of its linked
+  block devices.
 
 * ``blink_time`` is the duration (in milliseconds) of each blink of this LED.
   (The minimum value is 10 milliseconds.)
 
+* ``check_interval`` is the frequency (in milliseconds) with which block devices
+  linked to this LED will be checked for activity and the LED blinked (if the
+  correct type of activity has occurred).
+
 * The ``linked_devices`` directory will contain a symbolic link to every device
   that is associated with this LED.
 
@@ -66,10 +70,10 @@ Link a block device to the LED::
 file, such as ``/dev/sda``, that represents the block device - or the path of a
 symbolic link to such a device special file.)
 
-Read and write activity on the device should cause the LED to blink.  The
-duration of each blink (in milliseconds) can be adjusted by setting
-``/sys/class/leds/<LED>/blink_time``.  (But see **interval and blink_time**
-below.)
+Activity on the device should cause the LED to blink.  The duration of each
+blink (in milliseconds) can be adjusted by setting
+``/sys/class/leds/<LED>/blink_time``.  (But see **check_interval and
+blink_time** below.)
 
 Associate a second device with the LED::
 
@@ -91,33 +95,35 @@ the device's ``linked_leds`` directory::
 (The ``linked_leds`` directory only exists when the block device is linked to
 at least one LED.)
 
-``interval`` and ``blink_time``
-===============================
+``check_interval`` and ``blink_time``
+=====================================
 
 * By default, linked block devices are checked for activity every 100
-  milliseconds.  This frequency can be changed via the
-  ``/sys/class/ledtrig_blkdev/interval`` attribute.  (The minimum value is 25
+  milliseconds.  This frequency can be changed for an LED via the
+  ``/sys/class/leds/<led>/check_interval`` attribute.  (The minimum value is 25
   milliseconds.)
 
-* All associated devices are checked for activity every ``interval``
-  milliseconds, and a blink is triggered on appropriate LEDs.  The duration
-  of an LED's blink is determined by its ``blink_time`` attribute.  Thus
-  (assuming that activity of the relevant type has occurred on one of an LED's
-  linked devices), the LED will be on for ``blink_time`` milliseconds and off
-  for ``interval - blink_time`` milliseconds.
+* All block devices associated with an LED are checked for activity every
+  ``check_interval`` milliseconds, and a blink is triggered if the correct type
+  of activity (as determined by the LED's ``blink_on_*`` attributes) is
+  detected.  The duration of an LED's blink is determined by its ``blink_time``
+  attribute.  Thus (when the correct type of activity is detected), the LED will
+  be on for ``blink_time`` milliseconds and off for ``check_interval -
+  blink_time`` milliseconds.
 
 * The LED subsystem ignores new blink requests for an LED that is already in
   in the process of blinking, so setting a ``blink_time`` greater than or equal
-  to ``interval`` will cause some blinks to be missed.
+  to ``check_interval`` will cause some blinks to be missed.
 
 * Because of processing times, scheduling latencies, etc., avoiding missed
   blinks actually requires a difference of at least a few milliseconds between
-  the ``blink_time`` and ``interval``.  The required difference is likely to
-  vary from system to system.  As a  reference, a Thecus N5550 NAS requires a
-  difference of 7 milliseconds (``interval == 100``, ``blink_time == 93``).
+  the ``blink_time`` and ``check_interval``.  The required difference is likely
+  to vary from system to system.  As a  reference, a Thecus N5550 NAS requires a
+  difference of 7 milliseconds (``check_interval == 100``, ``blink_time ==
+  93``).
 
-* The default values (``interval == 100``, ``blink_time == 75``) cause the LED
-  associated with a continuously active device to blink rapidly.  For a more
+* The default values (``check_interval == 100``, ``blink_time == 75``) cause the
+  LED associated with a continuously active device to blink rapidly.  For a more
   "always on" effect, increase the ``blink_time`` (but not too much; see the
   previous bullet).
 
diff --git a/drivers/leds/trigger/ledtrig-blkdev.c b/drivers/leds/trigger/ledtrig-blkdev.c
index feead76c2e9dac7e38cdf88b1a95596ab27c4c6d..52ec11e4fc0bd8c6ae018019749ffbfde3be914b 100644
--- a/drivers/leds/trigger/ledtrig-blkdev.c
+++ b/drivers/leds/trigger/ledtrig-blkdev.c
@@ -12,152 +12,156 @@
 #include <linux/part_stat.h>
 #include <linux/xarray.h>
 
-/* Default blink time & check interval (milliseconds) */
-#define LED_BDEV_BLINK_MSEC	75
-#define LED_BDEV_INTERVAL	100
+/* Default, minimum & maximum blink duration (milliseconds) */
+#define BLKDEV_TRIG_BLINK_DEF	75
+#define BLKDEV_TRIG_BLINK_MIN	10
+#define BLKDEV_TRIG_BLINK_MAX	86400000  /* 24 hours */
 
-/* Minimum blink time & check interval (milliseconds) */
-#define LED_BDEV_MIN_BLINK	10
-#define LED_BDEV_MIN_INT	25
+/* Default, minimum & maximum activity check interval (milliseconds) */
+#define BLKDEV_TRIG_CHECK_DEF	100
+#define BLKDEV_TRIG_CHECK_MIN	25
+#define BLKDEV_TRIG_CHECK_MAX	86400000
+
+/*
+ * If blkdev_trig_check() can't lock the mutex, how long to wait before trying
+ * again (milliseconds)
+ */
+#define BLKDEV_TRIG_CHECK_RETRY	5
 
 /* Mode for blkdev_get_by_path() & blkdev_put() */
-#define LED_BDEV_FMODE		0
+#define BLKDEV_TRIG_FMODE	0
 
-/* Device activity type that will make LED blink */
-enum led_bdev_led_mode {
-	LED_BDEV_MODE_RO	= 0,
-	LED_BDEV_MODE_WO	= 1,
-	LED_BDEV_MODE_RW	= 2
-};
+/* Device activity type(s) that will make LED blink */
+#define BLKDEV_TRIG_READ	(1 << STAT_READ)
+#define BLKDEV_TRIG_WRITE	(1 << STAT_WRITE)
+#define BLKDEV_TRIG_DISCARD	(1 << STAT_DISCARD)
+#define BLKDEV_TRIG_FLUSH	(1 << STAT_FLUSH)
 
 /* When unlinking a block device from an LED, is the blkdev being released? */
-enum led_bdev_unlink_mode {
-	LED_BDEV_RELEASING,
-	LED_BDEV_NOT_RELEASING
+enum blkdev_trig_unlink_mode {
+	BLKDEV_TRIG_RELEASING,
+	BLKDEV_TRIG_NOT_RELEASING
 };
 
-/* An "LED block device" (LBD) - 1 per blkdev linked to at least 1 LED */
-struct led_bdev_lbd {
+/* Every block device linked to at least one LED gets a "BTB" */
+struct blkdev_trig_bdev {
+	unsigned long		last_checked;
+	unsigned long		last_activity[NR_STAT_GROUPS];
+	unsigned long		ios[NR_STAT_GROUPS];
 	unsigned long		index;
 	struct block_device	*bdev;
 	struct xarray		linked_leds;
-	unsigned long		read_ios;
-	unsigned long		write_ios;
-	unsigned int		generation;
-	bool			read_act;
-	bool			write_act;
 };
 
 /* Every LED associated with the blkdev trigger gets one of these */
-struct led_bdev_led {
+struct blkdev_trig_led {
+	unsigned long		last_checked;
 	unsigned long		index;
+	unsigned long		mode;  /* must be ulong for atomic bit ops */
 	struct led_classdev	*led_cdev;
 	unsigned int		blink_msec;
-	struct xarray		linked_lbds;
+	unsigned int		check_jiffies;
+	struct xarray		linked_btbs;
 	struct hlist_node	all_leds_node;
-	enum led_bdev_led_mode	mode;
 };
 
 /* Forward declarations to make this file compile in a more readable order */
-static void led_bdev_process(struct work_struct *work);
-static struct led_bdev_lbd *led_bdev_get_lbd(const char *buf, size_t size);
-static struct block_device *led_bdev_get_bdev(const char *buf, size_t size,
-					      fmode_t mode);
-static int led_bdev_link(struct led_bdev_led *led, struct led_bdev_lbd *lbd);
-static void led_bdev_put_lbd(struct led_bdev_lbd *lbd);
-static void led_bdev_lbd_release(struct device *dev, void *res);
-static void led_bdev_unlink(struct led_bdev_led *led,
-			    struct led_bdev_lbd *lbd,
-			    enum led_bdev_unlink_mode unlink_mode);
-static void led_bdev_update_lbd(struct led_bdev_lbd *lbd);
-static bool led_bdev_blink(const struct led_bdev_led *led,
-			   const struct led_bdev_lbd *lbd);
-
-/* Index for next LBD or LED */
-static unsigned long led_bdev_next_index;
-
-/* Protects everything except atomic sysfs attributes */
-static DEFINE_MUTEX(led_bdev_mutex);
+static void blkdev_trig_check(struct work_struct *work);
+static struct blkdev_trig_bdev *blkdev_trig_get_btb(const char *buf,
+						    size_t size);
+static struct block_device *blkdev_trig_get_bdev(const char *buf, size_t size,
+						 fmode_t mode);
+static int blkdev_trig_link(struct blkdev_trig_led *led,
+			    struct blkdev_trig_bdev *btb);
+static void blkdev_trig_put_btb(struct blkdev_trig_bdev *btb);
+static void blkdev_trig_btb_release(struct device *dev, void *res);
+static void blkdev_trig_unlink(struct blkdev_trig_led *led,
+			       struct blkdev_trig_bdev *btb,
+			       enum blkdev_trig_unlink_mode unlink_mode);
+static void blkdev_trig_update_btb(struct blkdev_trig_bdev *btb,
+				   unsigned long now);
+static bool blkdev_trig_blink(const struct blkdev_trig_led *led,
+			      const struct blkdev_trig_bdev *btb);
+static void blkdev_trig_sched_led(const struct blkdev_trig_led *led);
+
+/* Index for next BTB or LED */
+static unsigned long blkdev_trig_next_index;
+
+/* Protects everything except sysfs attributes */
+static DEFINE_MUTEX(blkdev_trig_mutex);
 
 /* All LEDs associated with the trigger */
-static HLIST_HEAD(led_bdev_all_leds);
-
-/* sysfs class for "global" trigger attributes (interval) */
-static struct class *led_bdev_class;
+static HLIST_HEAD(blkdev_trig_all_leds);
 
 /* Delayed work to periodically check for activity & blink LEDs */
-static DECLARE_DELAYED_WORK(led_bdev_work, led_bdev_process);
-
-/* How often to run the delayed work - in jiffies */
-static unsigned int led_bdev_interval;
+static DECLARE_DELAYED_WORK(blkdev_trig_work, blkdev_trig_check);
 
-/* Incremented every time the delayed work runs */
-static unsigned int led_bdev_generation;
+/* When is the delayed work scheduled to run next (jiffies) */
+static unsigned long blkdev_trig_next_check;
 
 /* Total number of device-to-LED associations (links) */
-static unsigned int led_bdev_link_count;
+static unsigned int blkdev_trig_link_count;
 
 /* Empty attribute list for the linked_leds & linked_devices "groups" */
-static struct attribute *led_bdev_attrs_empty[] = { NULL };
+static struct attribute *blkdev_trig_attrs_empty[] = { NULL };
 
 /* linked_leds sysfs directory for block devs linked to 1 or more LEDs */
-static const struct attribute_group led_bdev_linked_leds = {
+static const struct attribute_group blkdev_trig_linked_leds = {
 	.name	= "linked_leds",
-	.attrs	= led_bdev_attrs_empty,
+	.attrs	= blkdev_trig_attrs_empty,
 };
 
 /* linked_devices sysfs directory for each LED associated with the trigger */
-static const struct attribute_group led_bdev_linked_devs = {
+static const struct attribute_group blkdev_trig_linked_devs = {
 	.name	= "linked_devices",
-	.attrs	= led_bdev_attrs_empty,
+	.attrs	= blkdev_trig_attrs_empty,
 };
 
 /**
- * led_bdev_activate() - Called when an LED is associated with the trigger.
+ * blkdev_trig_activate() - Called when an LED is associated with the trigger.
  * @led_cdev:	The LED
  *
- * Allocates & initializes the @led_bdev_led structure, adds it to the
- * @led_bdev_all_leds list, and sets the LED's trigger data.
+ * Allocates & initializes the @blkdev_trig_led structure, adds it to the
+ * @blkdev_trig_all_leds list, and sets the LED's trigger data.
  *
- * Context:	Process context.  Takes and releases @led_bdev_mutex.
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
  * Return:	``0`` on success, ``-errno`` on error.
  */
-static int led_bdev_activate(struct led_classdev *const led_cdev)
+static int blkdev_trig_activate(struct led_classdev *led_cdev)
 {
-	struct led_bdev_led *led;
-	int ret;
+	struct blkdev_trig_led *led;
+	int err;
 
-	if (led_bdev_next_index == ULONG_MAX) {
-		ret = -EOVERFLOW;
-		goto exit_return;
-	}
+	led = kzalloc(sizeof(*led), GFP_KERNEL);
+	if (led == NULL)
+		return -ENOMEM;
+
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
+		goto exit_free;
 
-	led = kmalloc(sizeof(*led), GFP_KERNEL);
-	if (led == NULL) {
-		ret = -ENOMEM;
-		goto exit_return;
+	if (blkdev_trig_next_index == ULONG_MAX) {
+		err = -EOVERFLOW;
+		goto exit_unlock;
 	}
 
-	led->index = led_bdev_next_index++;
+	led->index = blkdev_trig_next_index++;
+	led->last_checked = jiffies;
+	led->mode = -1;  /* set all bits */
 	led->led_cdev = led_cdev;
-	led->blink_msec = LED_BDEV_BLINK_MSEC;
-	led->mode = LED_BDEV_MODE_RW;
-	xa_init(&led->linked_lbds);
+	led->blink_msec = BLKDEV_TRIG_BLINK_DEF;
+	led->check_jiffies = msecs_to_jiffies(BLKDEV_TRIG_CHECK_DEF);
+	xa_init(&led->linked_btbs);
 
-	ret = mutex_lock_interruptible(&led_bdev_mutex);
-	if (ret != 0)
-		goto exit_free;
-
-	hlist_add_head(&led->all_leds_node, &led_bdev_all_leds);
+	hlist_add_head(&led->all_leds_node, &blkdev_trig_all_leds);
 	led_set_trigger_data(led_cdev, led);
 
-	mutex_unlock(&led_bdev_mutex);
-
+exit_unlock:
+	mutex_unlock(&blkdev_trig_mutex);
 exit_free:
-	if (ret != 0)
+	if (err)
 		kfree(led);
-exit_return:
-	return ret;
+	return err;
 }
 
 /**
@@ -169,123 +173,114 @@ static int led_bdev_activate(struct led_classdev *const led_cdev)
  *		to the LED (e.g. /dev/sda)
  * @count:	The number of characters in @buf
  *
- * Calls led_bdev_get_lbd() to find or create the LBD for the block device,
+ * Calls blkdev_trig_get_btb() to find or create the BTB for the block device,
  * checks that the device isn't already linked to this LED, and calls
- * led_bdev_link() to create the link.
+ * blkdev_trig_link() to create the link.
  *
- * Context:	Process context.  Takes and releases @led_bdev_mutex.
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
  * Return:	@count on success, ``-errno`` on error.
  */
-static ssize_t link_device_store(struct device *const dev,
-				 struct device_attribute *const attr,
-				 const char *const buf, const size_t count)
+static ssize_t link_device_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
 {
-	struct led_bdev_led *const led = led_trigger_get_drvdata(dev);
-	struct led_bdev_lbd *lbd;
-	int ret;
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
+	struct blkdev_trig_bdev *btb;
+	int err;
 
-	ret = mutex_lock_interruptible(&led_bdev_mutex);
-	if (ret != 0)
-		goto exit_return;
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
+		return err;
 
-	lbd = led_bdev_get_lbd(buf, count);
-	if (IS_ERR(lbd)) {
-		ret = PTR_ERR(lbd);
+	btb = blkdev_trig_get_btb(buf, count);
+	if (IS_ERR(btb)) {
+		err = PTR_ERR(btb);
 		goto exit_unlock;
 	}
 
-	if (xa_load(&lbd->linked_leds, led->index) != NULL) {
-		ret = -EEXIST;
-		goto exit_put_lbd;
+	if (xa_load(&btb->linked_leds, led->index) != NULL) {
+		err = -EEXIST;
+		goto exit_put_btb;
 	}
 
-	ret = led_bdev_link(led, lbd);
+	err = blkdev_trig_link(led, btb);
 
-exit_put_lbd:
-	if (ret != 0)
-		led_bdev_put_lbd(lbd);
+exit_put_btb:
+	if (err)
+		blkdev_trig_put_btb(btb);
 exit_unlock:
-	mutex_unlock(&led_bdev_mutex);
-exit_return:
-	return (ret == 0) ? count : ret;
+	mutex_unlock(&blkdev_trig_mutex);
+	return err ? : count;
 }
 
 /**
- * led_bdev_get_lbd() - Find or create the LBD for a block device.
+ * blkdev_trig_get_btb() - Find or create the BTB for a block device.
  * @buf:	The value written to the ``link_device`` attribute, which should
  *		be the path to a special file that represents a block device
  * @count:	The number of characters in @buf
  *
- * Calls led_bdev_get() to get the block device represented by the path in @buf.
- * If the device already has an LBD (because it is already linked to an LED),
- * simply returns the existing LBD.
+ * Calls blkdev_trig_get_bdev() to get the block device represented by the path
+ * in @buf.  If the device already has a BTB (because it is already linked to
+ * an LED), simply returns the existing BTB.
  *
- * Otherwise, allocates a new LBD (as a device resource), creates the block
+ * Otherwise, allocates a new BTB (as a device resource), creates the block
  * device's ``linked_leds`` directory (attribute group), calls
- * led_bdev_update_lbd() to set the LBD's activity counters, and adds the LBD
- * resource to the block device.
+ * blkdev_trig_update_btb() to set the BTB's activity counters, and adds the
+ * BTB resource to the block device.
  *
- * Context:	Process context.  Caller must hold @led_bdev_mutex.
- * Return:	Pointer to the LBD, error pointer on error.
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ * Return:	Pointer to the BTB, error pointer on error.
  */
-static struct led_bdev_lbd *led_bdev_get_lbd(const char *const buf,
-					     const size_t count)
+static struct blkdev_trig_bdev *blkdev_trig_get_btb(const char *buf,
+						    size_t count)
 {
 	struct block_device *bdev;
-	struct led_bdev_lbd *lbd;
-	int ret;
+	struct blkdev_trig_bdev *btb;
+	int err;
 
-	bdev = led_bdev_get_bdev(buf, count, LED_BDEV_FMODE);
-	if (IS_ERR(bdev)) {
-		ret = PTR_ERR(bdev);
-		goto exit_return;
-	}
+	bdev = blkdev_trig_get_bdev(buf, count, BLKDEV_TRIG_FMODE);
+	if (IS_ERR(bdev))
+		return ERR_CAST(bdev);
 
-	lbd = devres_find(&bdev->bd_device, led_bdev_lbd_release, NULL, NULL);
-	if (lbd != NULL) {
-		ret = 0;
+	btb = devres_find(&bdev->bd_device, blkdev_trig_btb_release,
+			  NULL, NULL);
+	if (btb != NULL) {
+		err = 0;
 		goto exit_put_bdev;
 	}
 
-	if (led_bdev_next_index == ULONG_MAX) {
-		ret = -EOVERFLOW;
+	if (blkdev_trig_next_index == ULONG_MAX) {
+		err = -EOVERFLOW;
 		goto exit_put_bdev;
 	}
 
-	lbd = devres_alloc(led_bdev_lbd_release, sizeof(*lbd), GFP_KERNEL);
-	if (lbd == NULL) {
-		ret = -ENOMEM;
+	btb = devres_alloc(blkdev_trig_btb_release, sizeof(*btb), GFP_KERNEL);
+	if (btb == NULL) {
+		err = -ENOMEM;
 		goto exit_put_bdev;
 	}
 
-	ret = sysfs_create_group(bdev_kobj(bdev), &led_bdev_linked_leds);
-	if (ret != 0)
-		goto exit_free_lbd;
-
-	lbd->index = led_bdev_next_index++;
-	lbd->bdev = bdev;
-	xa_init(&lbd->linked_leds);
+	err = sysfs_create_group(bdev_kobj(bdev), &blkdev_trig_linked_leds);
+	if (err)
+		goto exit_free_btb;
 
-	/* Ensure that led_bdev_update_lbd() updates the LBD */
-	lbd->generation = led_bdev_generation - 1;
-	led_bdev_update_lbd(lbd);
-	/* Don't blink for activity that may have happened long ago */
-	lbd->read_act = false;
-	lbd->write_act = false;
+	btb->index = blkdev_trig_next_index++;
+	btb->bdev = bdev;
+	xa_init(&btb->linked_leds);
+	blkdev_trig_update_btb(btb, jiffies);
 
-	devres_add(&bdev->bd_device, lbd);
+	devres_add(&bdev->bd_device, btb);
 
-exit_free_lbd:
-	if (ret != 0)
-		devres_free(lbd);
+exit_free_btb:
+	if (err)
+		devres_free(btb);
 exit_put_bdev:
-	blkdev_put(bdev, LED_BDEV_FMODE);  /* Allow the device to be released */
-exit_return:
-	return (ret == 0) ? lbd : ERR_PTR(ret);
+	blkdev_put(bdev, BLKDEV_TRIG_FMODE);
+	return err ? ERR_PTR(err) : btb;
 }
 
 /**
- * led_bdev_get_bdev() - Get a block device by path.
+ * blkdev_trig_get_bdev() - Get a block device by path.
  * @buf:	The value written to the ``link_device`` or ``unlink_device``
  *		attribute, which should be the path to a special file that
  *		represents a block device
@@ -300,14 +295,13 @@ static struct led_bdev_lbd *led_bdev_get_lbd(const char *const buf,
  * Context:	Process context.
  * Return:	The block device, or an error pointer.
  */
-static struct block_device *led_bdev_get_bdev(const char *const buf,
-					      const size_t count,
-					      const fmode_t mode)
+static struct block_device *blkdev_trig_get_bdev(const char *buf, size_t count,
+						 fmode_t mode)
 {
 	struct block_device *bdev;
 	char *path;
 
-	path = kmemdup(buf, count + 1, GFP_KERNEL);  /* include null */
+	path = kmemdup(buf, count + 1, GFP_KERNEL);  /* +1 to include null */
 	if (path == NULL)
 		return ERR_PTR(-ENOMEM);
 
@@ -320,117 +314,141 @@ static struct block_device *led_bdev_get_bdev(const char *const buf,
 }
 
 /**
- * led_bdev_update_lbd() - Update an LBD's activity counters for the current
- *			   generation
- * @lbd:	The LBD
+ * blkdev_trig_update_btb() - Update a BTB's activity counters.
+ * @btb:	The BTB
  *
- * Does nothing if the LBD has already been updated during this generation.
+ * Checks each of the BTB's block device's I/O counters.  If the counter has
+ * changed since the last check, updates the counter and its timestamp in the
+ * BTB.
  *
- * Otherwise, updates the LBD's activity counters (@read_ios & @write_ios) and
- * @generation, and sets @read_act and/or @write_act if the corresponding
- * counters have changed.
- *
- * Context:	Process context.  Caller must hold @led_bdev_mutex.
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
  */
-static void led_bdev_update_lbd(struct led_bdev_lbd *const lbd)
+static void blkdev_trig_update_btb(struct blkdev_trig_bdev *btb,
+				   unsigned long now)
 {
-	unsigned long read_ios, write_ios;
-
-	if (lbd->generation != led_bdev_generation) {
-
-		read_ios = part_stat_read(lbd->bdev, ios[STAT_READ]);
+	unsigned long new_ios;
+	enum stat_group i;
 
-		write_ios = part_stat_read(lbd->bdev, ios[STAT_WRITE])
-				+ part_stat_read(lbd->bdev, ios[STAT_DISCARD])
-				+ part_stat_read(lbd->bdev, ios[STAT_FLUSH]);
+	for (i = STAT_READ; i <= STAT_FLUSH; ++i) {
 
-		if (lbd->read_ios != read_ios) {
-			lbd->read_act = true;
-			lbd->read_ios = read_ios;
-		} else {
-			lbd->read_act = false;
-		}
+		new_ios = part_stat_read(btb->bdev, ios[i]);
 
-		if (lbd->write_ios != write_ios) {
-			lbd->write_act = true;
-			lbd->write_ios = write_ios;
-		} else {
-			lbd->write_act = false;
+		if (new_ios != btb->ios[i]) {
+			btb->ios[i] = new_ios;
+			btb->last_activity[i] = now;
 		}
-
-		lbd->generation = led_bdev_generation;
 	}
+
+	btb->last_checked = now;
 }
 
 /**
- * led_bdev_link() - "Link" a block device to an LED.
+ * blkdev_trig_link() - "Link" a block device to an LED.
  * @led:	The LED
- * @lbd:	The block device
+ * @btb:	The block device
  *
  * Called from link_device_store() to create the link between an LED and a
  * block device.
  *
  *   * Adds block device symlink to LED's ``linked_devices`` directory.
  *   * Adds LED symlink to block devices's ``linked_leds`` directory.
- *   * Adds the LBD to the LED's @linked_lbds and adds the LED to the LBD's
+ *   * Adds the BTB to the LED's @linked_btbs and adds the LED to the BTB's
  *     @linked_leds.
+ *   * If this is the first block device linked to this LED, calls
+ *     blkdev_trig_new_sched() to (if needed) schedule or reschedule the delayed
+ *     work which periodically checks for block device activity and blinks LEDs.
  *
- * If the new link is the only one (i.e. no other block device/LED links
- * already exist), schedule delayed work to periodically check for block
- * device activity and blink LEDs.
- *
- * Context:	Process context.  Caller must hold @led_bdev_mutex.
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
  * Return:	0 on success, ``-errno`` on error.
  */
-static int led_bdev_link(struct led_bdev_led *const led,
-			 struct led_bdev_lbd *const lbd)
+static int blkdev_trig_link(struct blkdev_trig_led *led,
+			    struct blkdev_trig_bdev *btb)
 {
-	unsigned long delay;
-	int ret;
+	bool led_first_link;
+	int err;
+
+	led_first_link = xa_empty(&led->linked_btbs);
 
-	ret = xa_insert(&lbd->linked_leds, led->index, led, GFP_KERNEL);
-	if (ret != 0)
-		goto error_return;
+	err = xa_insert(&btb->linked_leds, led->index, led, GFP_KERNEL);
+	if (err)
+		return err;
 
-	ret = xa_insert(&led->linked_lbds, lbd->index, lbd, GFP_KERNEL);
-	if (ret != 0)
+	err = xa_insert(&led->linked_btbs, btb->index, btb, GFP_KERNEL);
+	if (err)
 		goto error_erase_led;
 
-	/* /sys/class/block/<bdev>/linked_leds/<led> */
-	ret = sysfs_add_link_to_group(bdev_kobj(lbd->bdev),
-				      led_bdev_linked_leds.name,
+	/* Create /sys/class/block/<bdev>/linked_leds/<led> symlink */
+	err = sysfs_add_link_to_group(bdev_kobj(btb->bdev),
+				      blkdev_trig_linked_leds.name,
 				      &led->led_cdev->dev->kobj,
 				      led->led_cdev->name);
-	if (ret != 0)
-		goto error_erase_lbd;
-
-	/* /sys/class/leds/<led>/linked_devices/<bdev> */
-	ret = sysfs_add_link_to_group(&led->led_cdev->dev->kobj,
-				      led_bdev_linked_devs.name,
-				      bdev_kobj(lbd->bdev),
-				      dev_name(&lbd->bdev->bd_device));
-	if (ret != 0)
+	if (err)
+		goto error_erase_btb;
+
+	/* Create /sys/class/leds/<led>/linked_devices/<bdev> symlink */
+	err = sysfs_add_link_to_group(&led->led_cdev->dev->kobj,
+				      blkdev_trig_linked_devs.name,
+				      bdev_kobj(btb->bdev),
+				      dev_name(&btb->bdev->bd_device));
+	if (err)
 		goto error_remove_symlink;
 
-	if (led_bdev_link_count == 0) {
-		delay = READ_ONCE(led_bdev_interval);
-		WARN_ON(!schedule_delayed_work(&led_bdev_work, delay));
-	}
+	/*
+	 * If this isn't the first block device linked to this LED, then the
+	 * delayed work schedule already reflects this LED.
+	 */
+	if (led_first_link)
+		blkdev_trig_sched_led(led);
 
-	++led_bdev_link_count;
+	++blkdev_trig_link_count;
 
 	return 0;
 
 error_remove_symlink:
-	sysfs_remove_link_from_group(bdev_kobj(lbd->bdev),
-				     led_bdev_linked_leds.name,
+	sysfs_remove_link_from_group(bdev_kobj(btb->bdev),
+				     blkdev_trig_linked_leds.name,
 				     led->led_cdev->name);
-error_erase_lbd:
-	xa_erase(&led->linked_lbds, lbd->index);
+error_erase_btb:
+	xa_erase(&led->linked_btbs, btb->index);
 error_erase_led:
-	xa_erase(&lbd->linked_leds, led->index);
-error_return:
-	return ret;
+	xa_erase(&btb->linked_leds, led->index);
+	return err;
+}
+
+/**
+ * blkdev_trig_sched_led() - Set the schedule of the delayed work when a new
+ *			     LED is added to the schedule.
+ * @led:	The LED
+ *
+ * Called from blkdev_trig_link() to set or adjust the schedule of the delayed
+ * work which periodically checks block devices for activity and blinks LEDs,
+ * if necessary.
+ *
+ *   * If no other links exist, the delayed work is scheduled.
+ *   * If the delayed work is already scheduled to run soon enough to
+ *     accommodate the newly linked LED's @check_jiffies, no change is made to
+ *     the delayed work's schedule.
+ *   * If the delayed work is already scheduled, but it isn't scheduled to
+ *     run soon enough, the schedule is modified.
+ *
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ */
+static void blkdev_trig_sched_led(const struct blkdev_trig_led *led)
+{
+	unsigned long delay = READ_ONCE(led->check_jiffies);
+	unsigned long check_by = jiffies + delay;
+
+	if (blkdev_trig_link_count == 0) {
+		WARN_ON(!schedule_delayed_work(&blkdev_trig_work, delay));
+		blkdev_trig_next_check = check_by;
+		return;
+	}
+
+	if (time_after_eq(check_by, blkdev_trig_next_check))
+		return;
+
+	WARN_ON(!mod_delayed_work(system_wq, &blkdev_trig_work, delay));
+	blkdev_trig_next_check = check_by;
 }
 
 /**
@@ -446,64 +464,63 @@ static int led_bdev_link(struct led_bdev_led *const led,
  * from the LED.  I.e. the LED will no longer blink to show activity on that
  * block device.
  *
- * Calls led_bdev_get() to get the block device represented by the path in @buf.
- * If the device has an LBD, searches the LBD's list of LEDs for a link to this
- * LED and (if found) calls led_bdev_unlink() to destroy the link.
+ * Calls blkdev_trig_get_bdev() to get the block device represented by the path
+ * in @buf.  If the device has a BTB, searches the BTB's list of LEDs for a
+ * link to this LED and (if found) calls blkdev_trig_unlink() to destroy the
+ * link.
  *
- * Context:	Process context.  Takes and releases @led_bdev_mutex.
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
  * Return:	@count on success, ``-errno`` on error.
  */
-static ssize_t unlink_device_store(struct device *const dev,
-				   struct device_attribute *const attr,
-				   const char *const buf, const size_t count)
+static ssize_t unlink_device_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
 {
-	struct led_bdev_led *const led = led_trigger_get_drvdata(dev);
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
 	struct block_device *bdev;
-	struct led_bdev_lbd *lbd;
-	int ret;
+	struct blkdev_trig_bdev *btb;
+	int err;
 
-	bdev = led_bdev_get_bdev(buf, count, LED_BDEV_FMODE);
-	if (IS_ERR(bdev)) {
-		ret = PTR_ERR(bdev);
-		goto exit_return;
-	}
+	bdev = blkdev_trig_get_bdev(buf, count, BLKDEV_TRIG_FMODE);
+	if (IS_ERR(bdev))
+		return PTR_ERR(bdev);
 
-	ret = mutex_lock_interruptible(&led_bdev_mutex);
-	if (ret != 0)
+	err = mutex_lock_interruptible(&blkdev_trig_mutex);
+	if (err)
 		goto exit_put_bdev;
 
-	lbd = devres_find(&bdev->bd_device, led_bdev_lbd_release, NULL, NULL);
-	if (lbd == NULL) {
-		ret = -EUNATCH;  /* bdev isn't linked to any LED */
+	btb = devres_find(&bdev->bd_device, blkdev_trig_btb_release,
+			  NULL, NULL);
+	if (btb == NULL) {
+		err = -EUNATCH;  /* bdev isn't linked to any LED */
 		goto exit_unlock;
 	}
 
-	if (xa_load(&lbd->linked_leds, led->index) == NULL) {
-		ret = -EUNATCH;  /* bdev isn't linked to this LED */
+	if (xa_load(&btb->linked_leds, led->index) == NULL) {
+		err = -EUNATCH;  /* bdev isn't linked to this LED */
 		goto exit_unlock;
 	}
 
-	led_bdev_unlink(led, lbd, LED_BDEV_NOT_RELEASING);
+	blkdev_trig_unlink(led, btb, BLKDEV_TRIG_NOT_RELEASING);
 
 exit_unlock:
-	mutex_unlock(&led_bdev_mutex);
+	mutex_unlock(&blkdev_trig_mutex);
 exit_put_bdev:
-	blkdev_put(bdev, LED_BDEV_FMODE);
-exit_return:
-	return (ret == 0) ? count : ret;
+	blkdev_put(bdev, BLKDEV_TRIG_FMODE);
+	return err ? : count;
 }
 
 /**
- * led_bdev_unlink() - "Unlink" a block device from an LED.
+ * blkdev_trig_unlink() - "Unlink" a block device from an LED.
  * @led:		The LED
- * @lbd:		The block device
- * @unlink_mode:	Indicates whether the LBD is being released (because the
- *			block device has been removed)
+ * @btb:		The block device
+ * @unlink_mode:	Indicates whether the BTB is being released (because
+ *			the block device has been removed)
  *
  * Removes the link between an LED and a block device.
  *
- *   * Removes the LBD from the LED's @linked_lbds and removes the LED from the
- *     LBD's @linked_leds.
+ *   * Removes the BTB from the LED's @linked_btbs and removes the LED from
+ *     the BTB's @linked_leds.
  *   * Removes the block device symlink from the LED's ``linked_devices``
  *     directory.
  *
@@ -511,7 +528,7 @@ static ssize_t unlink_device_store(struct device *const dev,
  *
  *   * Removes the LED symlink from the block device's ``linked_leds``
  *     directory.
- *   * Calls led_bdev_put_lbd() to clean up the LBD, if required.
+ *   * Calls blkdev_trig_put_btb() to clean up the BTB, if required.
  *
  * If the removed link was the only one (i.e. there are no existing block
  * device/LED links after its removal), cancels the periodic delayed work
@@ -520,188 +537,225 @@ static ssize_t unlink_device_store(struct device *const dev,
  * This function is called from multiple locations.
  *
  *   * unlink_device_store() calls this function when a block device is unlinked
- *     from an LED via the ``unlink_device`` sysfs attribute.   (@unlink_mode ==
- *     ``LED_BDEV_NOT_RELEASING``)
- *   * led_bdev_deactivate() calls this function for each block device linked to
- *     an LED that is being deactivated (disassociated from the trigger).
- *     (@unlink_mode == ``LED_BDEV_NOT_RELEASING``).
- *   * led_bdev_lbd_release() calls this function for each LED linked to a block
- *     device that has been removed from the system.  (@unlink_mode ==
- *     ``LED_BDEV_RELEASING).
- *
- * Context:	Process context.  Caller must hold @led_bdev_mutex.
- */
-static void led_bdev_unlink(struct led_bdev_led *const led,
-			    struct led_bdev_lbd *const lbd,
-			    const enum led_bdev_unlink_mode unlink_mode)
+ *     from an LED via the ``unlink_device`` sysfs attribute.  (@unlink_mode ==
+ *     ``BLKDEV_TRIG_NOT_RELEASING``)
+ *   * blkdev_trig_deactivate() calls this function for each block device linked
+ *     to an LED that is being deactivated (disassociated from the trigger).
+ *     (@unlink_mode == ``BLKDEV_TRIG_NOT_RELEASING``).
+ *   * blkdev_trig_btb_release() calls this function for each LED linked to a
+ *     block device that has been removed from the system.  (@unlink_mode ==
+ *     ``BLKDEV_TRIG_RELEASING).
+ *
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
+ */
+static void blkdev_trig_unlink(struct blkdev_trig_led *led,
+			       struct blkdev_trig_bdev *btb,
+			       enum blkdev_trig_unlink_mode unlink_mode)
 {
-	--led_bdev_link_count;
+	--blkdev_trig_link_count;
 
-	if (led_bdev_link_count == 0)
-		WARN_ON(!cancel_delayed_work_sync(&led_bdev_work));
+	if (blkdev_trig_link_count == 0)
+		WARN_ON(!cancel_delayed_work_sync(&blkdev_trig_work));
 
-	xa_erase(&lbd->linked_leds, led->index);
-	xa_erase(&led->linked_lbds, lbd->index);
+	xa_erase(&btb->linked_leds, led->index);
+	xa_erase(&led->linked_btbs, btb->index);
 
-	/* /sys/class/leds/<led>/linked_devices/<bdev> */
+	/* Remove /sys/class/leds/<led>/linked_devices/<bdev> symlink */
 	sysfs_remove_link_from_group(&led->led_cdev->dev->kobj,
-				     led_bdev_linked_devs.name,
-				     dev_name(&lbd->bdev->bd_device));
+				     blkdev_trig_linked_devs.name,
+				     dev_name(&btb->bdev->bd_device));
 
 	/*
-	 * If the LBD is being released, the device's attribute groups have
-	 * already been removed, and the LBD will be freed automatically.
+	 * If the BTB is being released, the device's attribute groups have
+	 * already been removed, and the BTB will be freed automatically, so
+	 * only do these steps if the BTB is not being released.
 	 */
-	if (unlink_mode == LED_BDEV_NOT_RELEASING) {
+	if (unlink_mode == BLKDEV_TRIG_NOT_RELEASING) {
 
-		/* /sys/class/block/<bdev>/linked_leds/<led> */
-		sysfs_remove_link_from_group(bdev_kobj(lbd->bdev),
-					     led_bdev_linked_leds.name,
+		/* Remove /sys/class/block/<bdev>/linked_leds/<led> symlink */
+		sysfs_remove_link_from_group(bdev_kobj(btb->bdev),
+					     blkdev_trig_linked_leds.name,
 					     led->led_cdev->name);
-		led_bdev_put_lbd(lbd);
+		blkdev_trig_put_btb(btb);
 	}
 }
 
 /**
- * led_bdev_put_lbd() - Remove and free an LBD, if it is no longer needed.
- * @lbd:	The LBD
+ * blkdev_trig_put_btb() - Remove and free a BTB, if it is no longer needed.
+ * @btb:	The BTB
  *
- * Does nothing if the LBD (block device) is still linked to at least one LED.
+ * Does nothing if the BTB (block device) is still linked to at least one LED.
  *
- * If the LBD is no longer linked to any LEDs, removes the block device's
- * ``linked_leds`` directory (attribute group), removes the LBD from the
- * block device's resource list, and frees the LBD.
+ * If the BTB is no longer linked to any LEDs, removes the block device's
+ * ``linked_leds`` directory (attribute group), removes the BTB from the
+ * block device's resource list, and frees the BTB.
  *
- * Called from led_bdev_unlink() (and in the link_device_store() error path).
+ * Called from blkdev_trig_unlink() (and in the link_device_store() error path).
  *
- * Context:	Process context.  Caller must hold @led_bdev_mutex.
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
  */
-static void led_bdev_put_lbd(struct led_bdev_lbd *const lbd)
+static void blkdev_trig_put_btb(struct blkdev_trig_bdev *btb)
 {
-	struct block_device *const bdev = lbd->bdev;
-	int ret;
+	struct block_device *bdev = btb->bdev;
+	int err;
 
-	if (xa_empty(&lbd->linked_leds)) {
+	if (xa_empty(&btb->linked_leds)) {
 
-		sysfs_remove_group(bdev_kobj(bdev), &led_bdev_linked_leds);
-		ret = devres_destroy(&bdev->bd_device, led_bdev_lbd_release,
+		sysfs_remove_group(bdev_kobj(bdev), &blkdev_trig_linked_leds);
+		err = devres_destroy(&bdev->bd_device, blkdev_trig_btb_release,
 				     NULL, NULL);
-		WARN_ON(ret != 0);
+		WARN_ON(err);
 	}
 }
 
 /**
- * led_bdev_deactivate() - Called when an LED is disassociated from the
- *			   trigger.
+ * blkdev_trig_deactivate() - Called when an LED is disassociated from the
+ *			      trigger.
  * @led_cdev:	The LED
  *
- * Calls led_bdev_unlink() for each block device linked to the LED, removes
- * the LED from the @led_bdev_all_leds list, and frees the @led_bdev_led.
+ * Calls blkdev_trig_unlink() for each block device linked to the LED, removes
+ * the LED from the @blkdevtrig_all_leds list, and frees the @blkdev_trig_led.
  *
- * Context:	Process context.  Takes and releases @led_bdev_mutex.
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
  */
-static void led_bdev_deactivate(struct led_classdev *const led_cdev)
+static void blkdev_trig_deactivate(struct led_classdev *led_cdev)
 {
-	struct led_bdev_led *const led = led_get_trigger_data(led_cdev);
-	struct led_bdev_lbd *lbd;
+	struct blkdev_trig_led *led = led_get_trigger_data(led_cdev);
+	struct blkdev_trig_bdev *btb;
 	unsigned long index;
 
-	mutex_lock(&led_bdev_mutex);
+	mutex_lock(&blkdev_trig_mutex);
 
-	xa_for_each (&led->linked_lbds, index, lbd)
-		led_bdev_unlink(led, lbd, LED_BDEV_NOT_RELEASING);
+	xa_for_each (&led->linked_btbs, index, btb)
+		blkdev_trig_unlink(led, btb, BLKDEV_TRIG_NOT_RELEASING);
 
 	hlist_del(&led->all_leds_node);
 	kfree(led);
 
-	mutex_unlock(&led_bdev_mutex);
+	mutex_unlock(&blkdev_trig_mutex);
 }
 
 /**
- * led_bdev_lbd_release() - LBD device resource release function.
+ * blkdev_trig_btb_release() - BTB device resource release function.
  * @dev:	The block device
- * @res:	The LBD
+ * @res:	The BTB
  *
- * Called by the driver core when a block device with an LBD is removed from the
- * system.  Calls led_bdev_unlink() for each LED linked to the block device.
+ * Called by the driver core when a block device with a BTB is removed from
+ * the system.  Calls blkdev_trig_unlink() for each LED linked to the block
+ * device.
  *
- * Context:	Process context.  Takes and releases @led_bdev_mutex.
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
  */
-static void led_bdev_lbd_release(struct device *const dev, void *const res)
+static void blkdev_trig_btb_release(struct device *dev, void *res)
 {
-	struct led_bdev_lbd *const lbd = res;
-	struct led_bdev_led *led;
+	struct blkdev_trig_bdev *btb = res;
+	struct blkdev_trig_led *led;
 	unsigned long index;
 
-	mutex_lock(&led_bdev_mutex);
+	mutex_lock(&blkdev_trig_mutex);
 
-	xa_for_each (&lbd->linked_leds, index, led)
-		led_bdev_unlink(led, lbd, LED_BDEV_RELEASING);
+	xa_for_each (&btb->linked_leds, index, led)
+		blkdev_trig_unlink(led, btb, BLKDEV_TRIG_RELEASING);
 
-	mutex_unlock(&led_bdev_mutex);
+	mutex_unlock(&blkdev_trig_mutex);
 }
 
 /**
- * led_bdev_process() - Check linked devices for activity and blink LEDs.
- * @work:	Delayed work (@led_bdev_work)
+ * blkdev_trig_check() - Check linked devices for activity and blink LEDs.
+ * @work:	Delayed work (@blkdev_trig_work)
  *
- * Iterates through block devices linked to LEDs and calls led_bdev_update_lbd()
- * to update the LBD's activity counters.  If a particular LED hasn't already
- * been blinked, calls led_bdev_blink() to blink the LED if appropriate for that
- * device's activity.
+ * Called periodically (as delayed work) to check linked block devices for
+ * activity and blink LEDs.
  *
- * When finished, schedules itself to run again after @led_bdev_interval
- * jiffies.
+ *   * Iterates through all LEDs associated with the trigger.
+ *   * If an LED is due to be checked, iterates through the block devices (BTBs)
+ *     linked to the LED.
+ *   * If a block device has not already been checked during this pass, calls
+ *     blkdev_trig_update_btb() to update the BTB's activity counters and
+ *     timestamps.
+ *   * If the LED has not already been blinked during this pass, calls
+ *     blkdev_trig_blink() to blink it if the correct type of activity has
+ *     occurred since the LED was last checked.
  *
- * Context:	Process context.  Takes and releases @led_bdev_mutex.
+ * When finished, schedules itself to run again when the next LED is due to be
+ * checked.
+ *
+ * Context:	Process context.  Takes and releases @blkdev_trig_mutex.
  */
-static void led_bdev_process(struct work_struct *const work)
+static void blkdev_trig_check(struct work_struct *work)
 {
-	struct led_bdev_led *led;
-	unsigned long delay;
+	struct blkdev_trig_led *led;
+	struct blkdev_trig_bdev *btb;
+	unsigned long index, delay, now, led_check, led_delay;
+	bool blinked;
 
-	if (!mutex_trylock(&led_bdev_mutex))
+	if (!mutex_trylock(&blkdev_trig_mutex)) {
+		delay = msecs_to_jiffies(BLKDEV_TRIG_CHECK_RETRY);
 		goto exit_reschedule;
+	}
+
+	now = jiffies;
+	delay = ULONG_MAX;
 
-	hlist_for_each_entry (led, &led_bdev_all_leds, all_leds_node) {
+	hlist_for_each_entry (led, &blkdev_trig_all_leds, all_leds_node) {
 
-		struct led_bdev_lbd *lbd;
-		unsigned long index;
-		bool blinked = false;
+		led_check = led->last_checked + led->check_jiffies;
 
-		xa_for_each (&led->linked_lbds, index, lbd) {
+		if (time_before_eq(led_check, now)) {
 
-			led_bdev_update_lbd(lbd);
-			if (!blinked)
-				blinked = led_bdev_blink(led, lbd);
+			blinked = false;
+
+			xa_for_each (&led->linked_btbs, index, btb) {
+
+				if (btb->last_checked != now)
+					blkdev_trig_update_btb(btb, now);
+				if (!blinked)
+					blinked = blkdev_trig_blink(led, btb);
+			}
+
+			led->last_checked = now;
+			led_delay = led->check_jiffies;
+
+		} else {
+			led_delay = led_check - now;
 		}
-	}
 
-	++led_bdev_generation;
+		if (led_delay < delay)
+			delay = led_delay;
+	}
 
-	mutex_unlock(&led_bdev_mutex);
+	mutex_unlock(&blkdev_trig_mutex);
 
 exit_reschedule:
-	delay = READ_ONCE(led_bdev_interval);
-	WARN_ON_ONCE(!schedule_delayed_work(&led_bdev_work, delay));
+	WARN_ON_ONCE(delay == ULONG_MAX);
+	WARN_ON_ONCE(!schedule_delayed_work(&blkdev_trig_work, delay));
 }
 
 /**
- * led_bdev_blink() - Blink an LED, if the correct type of activity has occurred
- *		      on the block device.
+ * blkdev_trig_blink() - Blink an LED, if the correct type of activity has
+ *			 occurred on the block device.
  * @led:	The LED
- * @lbd:	The block device
+ * @btb:	The block device
  *
- * Context:	Process context.  Caller must hold @led_bdev_mutex.
+ * Context:	Process context.  Caller must hold @blkdev_trig_mutex.
  * Return:	``true`` if the LED is blinked, ``false`` if not.
  */
-static bool led_bdev_blink(const struct led_bdev_led *const led,
-			   const struct led_bdev_lbd *const lbd)
+static bool blkdev_trig_blink(const struct blkdev_trig_led *led,
+			      const struct blkdev_trig_bdev *btb)
 {
 	unsigned long delay_on, delay_off;
+	enum stat_group i;
+	unsigned long mode, mask;
+
+	mode = READ_ONCE(led->mode);
+
+	for (i = STAT_READ, mask = 1; i <= STAT_FLUSH; ++i, mask <<= 1) {
+
+		if (!(mode & mask))
+			continue;
 
-	if ((lbd->read_act && led->mode != LED_BDEV_MODE_WO)
-			|| (lbd->write_act && led->mode != LED_BDEV_MODE_RO)) {
+		if (time_before_eq(btb->last_activity[i], led->last_checked))
+			continue;
 
 		delay_on = READ_ONCE(led->blink_msec);
 		delay_off = 1;	/* 0 leaves LED turned on */
@@ -724,11 +778,10 @@ static bool led_bdev_blink(const struct led_bdev_led *const led,
  * Context:	Process context.
  * Return:	The number of characters written to @buf.
  */
-static ssize_t blink_time_show(struct device *const dev,
-			       struct device_attribute *const attr,
-			       char *const buf)
+static ssize_t blink_time_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
 {
-	const struct led_bdev_led *const led = led_trigger_get_drvdata(dev);
+	const struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
 
 	return sprintf(buf, "%u\n", READ_ONCE(led->blink_msec));
 }
@@ -745,19 +798,19 @@ static ssize_t blink_time_show(struct device *const dev,
  * Context:	Process context.
  * Return:	@count on success, ``-errno`` on error.
  */
-static ssize_t blink_time_store(struct device *const dev,
-				struct device_attribute *const attr,
-				const char *const buf, const size_t count)
+static ssize_t blink_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
 {
-	struct led_bdev_led *const led = led_trigger_get_drvdata(dev);
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
 	unsigned int value;
-	int ret;
+	int err;
 
-	ret = kstrtouint(buf, 0, &value);
-	if (ret != 0)
-		return ret;
+	err = kstrtouint(buf, 0, &value);
+	if (err)
+		return err;
 
-	if (value < LED_BDEV_MIN_BLINK)
+	if (value < BLKDEV_TRIG_BLINK_MIN || value > BLKDEV_TRIG_BLINK_MAX)
 		return -ERANGE;
 
 	WRITE_ONCE(led->blink_msec, value);
@@ -765,200 +818,322 @@ static ssize_t blink_time_store(struct device *const dev,
 }
 
 /**
- * mode_show() - ``mode`` device attribute show function.
+ * check_interval_show() - ``check_interval`` device attribute show function.
  * @dev:	The LED device
- * @attr:	The ``mode`` attribute (@dev_attr_mode)
+ * @attr:	The ``check_interval`` attribute (@dev_attr_check_interval)
  * @buf:	Output buffer
  *
- * Writes the current value of the LED's @mode to @buf.
+ * Writes the current value of the LED's @check_jiffies (converted to
+ * milliseconds) to @buf.
  *
  * Context:	Process context.
  * Return:	The number of characters written to @buf.
  */
-static ssize_t mode_show(struct device *const dev,
-			 struct device_attribute *const attr, char *const buf)
+static ssize_t check_interval_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
 {
-	static const char modes[][sizeof("[read] write rw\n")] = {
-		[LED_BDEV_MODE_RO] = "[read] write rw\n",
-		[LED_BDEV_MODE_WO] = "read [write] rw\n",
-		[LED_BDEV_MODE_RW] = "read write [rw]\n"
-	};
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
 
-	const struct led_bdev_led *const led = led_trigger_get_drvdata(dev);
-
-	return sprintf(buf, modes[READ_ONCE(led->mode)]);
+	return sprintf(buf, "%u\n",
+		       jiffies_to_msecs(READ_ONCE(led->check_jiffies)));
 }
 
 /**
- * mode_store() - ``mode`` device attribute store function.
+ * check_interval_store() - ``check_interval`` device attribute store function
  * @dev:	The LED device
- * @attr:	The ``mode`` attribute (@dev_attr_mode)
+ * @attr:	The ``check_interval`` attribute (@dev_attr_check_interval)
  * @buf:	The new value (as written to the sysfs attribute)
  * @count:	The number of characters in @buf
  *
- * Sets the LED's @mode (``read``, ``write``, or ``rw``).
+ * Sets the LED's @check_jiffies (after converting from milliseconds).
  *
  * Context:	Process context.
  * Return:	@count on success, ``-errno`` on error.
  */
-static ssize_t mode_store(struct device *const dev,
-			  struct device_attribute *const attr,
-			  const char *const buf, const size_t count)
+static ssize_t check_interval_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
 {
-	static const char modes[][sizeof("write")] = {
-		[LED_BDEV_MODE_RO] = "read",
-		[LED_BDEV_MODE_WO] = "write",  /* longest */
-		[LED_BDEV_MODE_RW] = "rw"
-	};
+	struct blkdev_trig_led *led = led_trigger_get_drvdata(dev);
+	unsigned int value;
+	int err;
 
-	struct led_bdev_led *const led = led_trigger_get_drvdata(dev);
-	enum led_bdev_led_mode mode;
+	err = kstrtouint(buf, 0, &value);
+	if (err)
+		return err;
 
-	for (mode = LED_BDEV_MODE_RO; mode <= LED_BDEV_MODE_RW; ++mode) {
+	if (value < BLKDEV_TRIG_CHECK_MIN || value > BLKDEV_TRIG_CHECK_MAX)
+		return -ERANGE;
 
-		if (sysfs_streq(modes[mode], buf)) {
-			WRITE_ONCE(led->mode, mode);
-			return count;
-		}
-	}
+	WRITE_ONCE(led->check_jiffies, msecs_to_jiffies(value));
 
-	return -EINVAL;
+	return count;
 }
 
 /**
- * interval_show() - ``interval`` class attribute show function.
- * @class:	The ``ledtrig_blkdev`` class (@led_bdev_class)
- * @attr:	The ``interval`` attribute (@class_attr_interval)
+ * blkdev_trig_mode_show() - Helper for boolean attribute show functions.
+ * @led:	The LED
  * @buf:	Output buffer
+ * @mask:	Which bit to show (@BLKDEV_TRIG_READ, etc.)
  *
- * Writes the current value of @led_bdev_interval to @buf.
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static int blkdev_trig_mode_show(const struct blkdev_trig_led *led, char *buf,
+				 unsigned long mask)
+{
+	return sprintf(buf, READ_ONCE(led->mode) & mask ? "Y\n" : "N\n");
+}
+
+/**
+ * blkdev_trig_mode_store() - Helper for boolean attribute store functions.
+ * @led:	The LED
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ * @mask:	Which bit to set (@BLKDEV_TRIG_READ, etc.)
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static int blkdev_trig_mode_store(struct blkdev_trig_led *led,
+				  const char *buf, size_t count,
+				  enum stat_group bit)
+{
+	bool set;
+	int err;
+
+	err = kstrtobool(buf, &set);
+	if (err)
+		return err;
+
+	if (set)
+		set_bit(bit, &led->mode);
+	else
+		clear_bit(bit, &led->mode);
+
+	return count;
+}
+
+/**
+ * blink_on_read_show() - ``blink_on_read`` device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_read`` attribute (@dev_attr_blink_on_read)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @BLKDEV_TRIG_READ @mode bit to @buf.
  *
  * Context:	Process context.
  * Return:	The number of characters written to @buf.
  */
-static ssize_t interval_show(struct class *const class,
-			     struct class_attribute *const attr,
-			     char *const buf)
+static ssize_t blink_on_read_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%u\n",
-		       jiffies_to_msecs(READ_ONCE(led_bdev_interval)));
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev), buf,
+				     BLKDEV_TRIG_READ);
 }
 
 /**
- * interval_store() - ``interval`` class attribute store function
- * @class:	The ``ledtrig_blkdev`` class (@led_bdev_class)
- * @attr:	The ``interval`` attribute (@class_attr_interval)
+ * blink_on_read_store() - ``blink_on_read`` device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_read`` attribute (@dev_attr_blink_on_read)
  * @buf:	The new value (as written to the sysfs attribute)
  * @count:	The number of characters in @buf
  *
- * Sets @led_bdev_interval (after converting to jiffies).
+ * Sets or clears the LED's @BLKDEV_TRIG_READ @mode bit.
  *
  * Context:	Process context.
  * Return:	@count on success, ``-errno`` on error.
  */
-static ssize_t interval_store(struct class *const class,
-			      struct class_attribute *const attr,
-			      const char *const buf, const size_t count)
+static ssize_t blink_on_read_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
 {
-	unsigned int value;
-	int ret;
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev), buf, count,
+				      STAT_READ);
+}
 
-	ret = kstrtouint(buf, 0, &value);
-	if (ret != 0)
-		return ret;
+/**
+ * blink_on_write_show() - ``blink_on_write`` device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_write`` attribute (@dev_attr_blink_on_write)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @BLKDEV_TRIG_WRITE @mode bit to @buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static ssize_t blink_on_write_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev), buf,
+				     BLKDEV_TRIG_WRITE);
+}
 
-	if (value < LED_BDEV_MIN_INT)
-		return -ERANGE;
+/**
+ * blink_on_write_store() - ``blink_on_write`` device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_write`` attribute (@dev_attr_blink_on_write)
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ *
+ * Sets or clears the LED's @BLKDEV_TRIG_WRITE @mode bit.
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t blink_on_write_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev), buf, count,
+				      STAT_WRITE);
+}
 
-	WRITE_ONCE(led_bdev_interval, msecs_to_jiffies(value));
+/**
+ * blink_on_flush_show() - ``blink_on_flush`` device attribute show function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_flush`` attribute (@dev_attr_blink_on_flush)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @BLKDEV_TRIG_FLUSH @mode bit to @buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static ssize_t blink_on_flush_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev), buf,
+				     BLKDEV_TRIG_FLUSH);
+}
 
-	return count;
+/**
+ * blink_on_flush_store() - ``blink_on_flush`` device attribute store function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_flush`` attribute (@dev_attr_blink_on_flush)
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ *
+ * Sets or clears the LED's @BLKDEV_TRIG_FLUSH @mode bit.
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t blink_on_flush_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev), buf, count,
+				      STAT_FLUSH);
 }
 
-/* Device and class attributes */
+/**
+ * blink_on_discard_show() - ``blink_on_discard`` device attribute show
+ *			     function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_discard`` attribute (@dev_attr_blink_on_discard)
+ * @buf:	Output buffer
+ *
+ * Writes the current value of the LED's @BLKDEV_TRIG_DISCARD @mode bit to @buf.
+ *
+ * Context:	Process context.
+ * Return:	The number of characters written to @buf.
+ */
+static ssize_t blink_on_discard_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return blkdev_trig_mode_show(led_trigger_get_drvdata(dev), buf,
+				     BLKDEV_TRIG_DISCARD);
+}
+
+/**
+ * blink_on_discard_store() - ``blink_on_discard`` device attribute store
+ *			      function.
+ * @dev:	The LED device
+ * @attr:	The ``blink_on_discard`` attribute (@dev_attr_blink_on_discard)
+ * @buf:	The new value (as written to the sysfs attribute)
+ * @count:	The number of characters in @buf
+ *
+ * Sets the LED's @BLKDEV_TRIG_DISCARD @mode bit.
+ *
+ * Context:	Process context.
+ * Return:	@count on success, ``-errno`` on error.
+ */
+static ssize_t blink_on_discard_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	return blkdev_trig_mode_store(led_trigger_get_drvdata(dev), buf, count,
+				      STAT_DISCARD);
+}
+
+/* Device attributes */
 static DEVICE_ATTR_WO(link_device);
 static DEVICE_ATTR_WO(unlink_device);
 static DEVICE_ATTR_RW(blink_time);
-static DEVICE_ATTR_RW(mode);
-static CLASS_ATTR_RW(interval);
+static DEVICE_ATTR_RW(check_interval);
+static DEVICE_ATTR_RW(blink_on_read);
+static DEVICE_ATTR_RW(blink_on_write);
+static DEVICE_ATTR_RW(blink_on_flush);
+static DEVICE_ATTR_RW(blink_on_discard);
 
 /* Device attributes in LED directory (/sys/class/leds/<led>/...) */
-static struct attribute *led_bdev_attrs[] = {
+static struct attribute *blkdev_trig_attrs[] = {
 	&dev_attr_link_device.attr,
 	&dev_attr_unlink_device.attr,
 	&dev_attr_blink_time.attr,
-	&dev_attr_mode.attr,
+	&dev_attr_check_interval.attr,
+	&dev_attr_blink_on_read.attr,
+	&dev_attr_blink_on_write.attr,
+	&dev_attr_blink_on_flush.attr,
+	&dev_attr_blink_on_discard.attr,
 	NULL
 };
 
 /* Unnamed attribute group == no subdirectory */
-static const struct attribute_group led_bdev_attr_group = {
-	.attrs	= led_bdev_attrs,
+static const struct attribute_group blkdev_trig_attr_group = {
+	.attrs	= blkdev_trig_attrs,
 };
 
 /* Attribute groups for the trigger */
-static const struct attribute_group *led_bdev_attr_groups[] = {
-	&led_bdev_attr_group,   /* /sys/class/leds/<led>/... */
-	&led_bdev_linked_devs,  /* /sys/class/leds/<led>/linked_devices/ */
+static const struct attribute_group *blkdev_trig_attr_groups[] = {
+	&blkdev_trig_attr_group,   /* /sys/class/leds/<led>/... */
+	&blkdev_trig_linked_devs,  /* /sys/class/leds/<led>/linked_devices/ */
 	NULL
 };
 
 /* Trigger registration data */
-static struct led_trigger led_bdev_trigger = {
+static struct led_trigger blkdev_trig_trigger = {
 	.name		= "blkdev",
-	.activate	= led_bdev_activate,
-	.deactivate	= led_bdev_deactivate,
-	.groups		= led_bdev_attr_groups,
+	.activate	= blkdev_trig_activate,
+	.deactivate	= blkdev_trig_deactivate,
+	.groups		= blkdev_trig_attr_groups,
 };
 
 /**
- * led_bdev_init() - Block device LED trigger initialization.
+ * blkdev_trig_init() - Block device LED trigger initialization.
  *
- * Converts default @led_bdev_interval from milliseconds to jiffies, creates
- * the ``/sys/class/ledtrig_blkdev/interval`` attribute, and registers the LED
- * trigger.
+ * Registers the LED trigger.
  *
  * Return:	0 on success, ``-errno`` on failure.
  */
-static int __init led_bdev_init(void)
+static int __init blkdev_trig_init(void)
 {
-	int ret;
-
-	WRITE_ONCE(led_bdev_interval,
-		   msecs_to_jiffies(LED_BDEV_INTERVAL));
-
-	led_bdev_class = class_create(THIS_MODULE, "ledtrig_blkdev");
-	if (IS_ERR(led_bdev_class)) {
-		ret = PTR_ERR(led_bdev_class);
-		goto exit_return;
-	}
-
-	ret = class_create_file(led_bdev_class, &class_attr_interval);
-	if (ret != 0)
-		goto exit_destroy_class;
-
-	ret = led_trigger_register(&led_bdev_trigger);
-
-exit_destroy_class:
-	if (ret != 0)
-		class_destroy(led_bdev_class);  /* removes the attribute file */
-exit_return:
-	return ret;
+	return led_trigger_register(&blkdev_trig_trigger);
 }
-module_init(led_bdev_init);
+module_init(blkdev_trig_init);
 
 /**
- * led_bdev_exit() - Block device LED trigger module exit.
+ * blkdev_trig_exit() - Block device LED trigger module exit.
  *
- * Unregisters the LED trigger and removes the
- * ``/sys/class/ledtrig_blkdev/interval`` attribute.
+ * Unregisters the LED trigger.
  */
-static void __exit led_bdev_exit(void)
+static void __exit blkdev_trig_exit(void)
 {
-	led_trigger_unregister(&led_bdev_trigger);
-	class_destroy(led_bdev_class);
+	led_trigger_unregister(&blkdev_trig_trigger);
 }
-module_exit(led_bdev_exit);
+module_exit(blkdev_trig_exit);
 
 MODULE_DESCRIPTION("Block device LED trigger");
 MODULE_AUTHOR("Ian Pilcher <arequipeno@gmail.com>");
