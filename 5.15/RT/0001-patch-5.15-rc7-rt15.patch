From ed24444220db9f9edc325a72bd11a52b8222bf70 Mon Sep 17 00:00:00 2001
From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date: Fri, 29 Oct 2021 10:28:15 +0200
Subject: [ANNOUNCE] v5.15-rc7-rt15

Dear RT folks!

I'm pleased to announce the v5.15-rc7-rt15 patch set.

Changes since v5.15-rc7-rt14:

  - Avoid a sleeping-while-atomic warning in fscache. Reported by Gregor
    Beck.

  - Redo the synchronisation in fs/namespace and then remove cpu_chill()
    since it has finally no users.

  - Disable NUMA_BALANCING. It is problematic since it may block a task
    while moving memory from one NUMA node to another. This has been
    brought round by Mel Gorman while discussion a different issue.

  - Update the i915 patches to v2 which has been posted upstream.
    Testing on hardware is appreciated.

Known issues
     - netconsole triggers WARN.

     - The "Memory controller" (CONFIG_MEMCG) has been disabled.

     - Valentin Schneider reported a few splats on ARM64, see
          https://lkml.kernel.org/r/20210810134127.1394269-1-valentin.schneider@arm.com

The delta patch against v5.15-rc7-rt14 is appended below and can be found here:

     https://cdn.kernel.org/pub/linux/kernel/projects/rt/5.15/incr/patch-5.15-rc7-rt14-rt15.patch.xz

You can get this release via the git tree at:

    git://git.kernel.org/pub/scm/linux/kernel/git/rt/linux-rt-devel.git v5.15-rc7-rt15

The RT patch against v5.15-rc7 can be found here:

    https://cdn.kernel.org/pub/linux/kernel/projects/rt/5.15/older/patch-5.15-rc7-rt15.patch.xz

The split quilt queue is available at:

    https://cdn.kernel.org/pub/linux/kernel/projects/rt/5.15/older/patches-5.15-rc7-rt15.tar.xz

Sebastian

Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
---
 ...lftests-Properly-reset-mock-object-proper.patch |  53 +++++++
 ...d_clean_up_the_might_sleep_underscore_zoo.patch |   4 +-
 ...rm-Increase-DRM_OBJECT_MAX_PROPERTY-by-18.patch |  28 ----
 ...n-t-disable-interrupts-and-pretend-a-lock.patch | 137 ++++++++++++++++
 ...reempt_offset_argument_from___might_sleep.patch |   4 +-
 .../0004_sched_cleanup_might_sleep_printks.patch   |   2 +-
 ...i915-Disable-tracing-points-on-PREEMPT_RT.patch |  44 ------
 ...n-t-check-for-atomic-context-on-PREEMPT_R.patch |  29 ++++
 ...ed_make_might_sleep_output_less_confusing.patch |   6 +-
 ...i915-Disable-tracing-points-on-PREEMPT_RT.patch |  44 ++++++
 ...ip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch |  28 ----
 ...cu_nest_depth_distinct_in___might_resched.patch |  10 +-
 ...5-gt-Queue-and-wait-for-the-irq_work-item.patch |  41 -----
 ...ip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch |  28 ++++
 ...5-gt-Queue-and-wait-for-the-irq_work-item.patch |  41 +++++
 ...-Use-spin_lock_irq-instead-of-local_irq_d.patch |  88 -----------
 ...009-drm-i915-Drop-the-irqs_disabled-check.patch |  38 -----
 ...-Use-spin_lock_irq-instead-of-local_irq_d.patch |  88 +++++++++++
 ...n-t-disable-interrupts-and-pretend-a-lock.patch | 176 ---------------------
 ...010-drm-i915-Drop-the-irqs_disabled-check.patch |  38 +++++
 patches/ARM__Allow_to_enable_RT.patch              |   2 +-
 patches/Add_localversion_for_-RT_release.patch     |   2 +-
 patches/arm__Add_support_for_lazy_preemption.patch |   2 +-
 ...e-Boost-the-mount_lock.lock-owner-instead.patch |  57 +++++++
 ...namespace__Use_cpu_chill_in_trylock_loops.patch |  42 -----
 ...che-Use-only-one-fscache_object_cong_wait.patch | 117 ++++++++++++++
 ...onfig_options_which_are_not_RT_compatible.patch |  26 ---
 ...NUMA_BALANCING_DEFAULT_ENABLED-and-TRANSP.patch |  54 +++++++
 patches/random__Make_it_work_on_rt.patch           |   2 +-
 patches/rt__Introduce_cpu_chill.patch              | 149 -----------------
 patches/series                                     |  22 +--
 patches/signal__Revert_ptrace_preempt_magic.patch  |   2 +-
 ...gnal_x86__Delay_calling_signals_in_atomic.patch |   2 +-
 patches/x86__kvm_Require_const_tsc_for_RT.patch    |   2 +-
 34 files changed, 717 insertions(+), 691 deletions(-)
 create mode 100644 patches/0001-drm-i915-selftests-Properly-reset-mock-object-proper.patch
 delete mode 100644 patches/0002-drm-Increase-DRM_OBJECT_MAX_PROPERTY-by-18.patch
 create mode 100644 patches/0002-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch
 delete mode 100644 patches/0005-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch
 create mode 100644 patches/0005-drm-i915-Don-t-check-for-atomic-context-on-PREEMPT_R.patch
 create mode 100644 patches/0006-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch
 delete mode 100644 patches/0006-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch
 delete mode 100644 patches/0007-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch
 create mode 100644 patches/0007-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch
 create mode 100644 patches/0008-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch
 delete mode 100644 patches/0008-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch
 delete mode 100644 patches/0009-drm-i915-Drop-the-irqs_disabled-check.patch
 create mode 100644 patches/0009-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch
 delete mode 100644 patches/0010-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch
 create mode 100644 patches/0010-drm-i915-Drop-the-irqs_disabled-check.patch
 create mode 100644 patches/fs-namespace-Boost-the-mount_lock.lock-owner-instead.patch
 delete mode 100644 patches/fs__namespace__Use_cpu_chill_in_trylock_loops.patch
 create mode 100644 patches/fscache-Use-only-one-fscache_object_cong_wait.patch
 delete mode 100644 patches/kconfig__Disable_config_options_which_are_not_RT_compatible.patch
 create mode 100644 patches/mm-Disable-NUMA_BALANCING_DEFAULT_ENABLED-and-TRANSP.patch
 delete mode 100644 patches/rt__Introduce_cpu_chill.patch

diff --git a/patches/0001-drm-i915-selftests-Properly-reset-mock-object-proper.patch b/patches/0001-drm-i915-selftests-Properly-reset-mock-object-proper.patch
new file mode 100644
index 0000000000000..5812ad1cbbecf
--- /dev/null
+++ b/patches/0001-drm-i915-selftests-Properly-reset-mock-object-proper.patch
@@ -0,0 +1,53 @@
+From: Daniel Vetter <daniel.vetter@ffwll.ch>
+Date: Thu, 21 Oct 2021 22:20:48 +0200
+Subject: [PATCH 01/10] drm/i915/selftests: Properly reset mock object propers
+ for each test
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+I forgot to do this properly in
+
+commit 6f11f37459d8f9f74ff1c299c0bedd50b458057a
+Author: Daniel Vetter <daniel.vetter@ffwll.ch>
+Date:   Fri Jul 23 10:34:55 2021 +0200
+
+    drm/plane: remove drm_helper_get_plane_damage_clips
+
+intel-gfx CI didn't spot this because we run each selftest in each own
+invocations, which means reloading i915.ko. But if you just run all
+the selftests in one go at boot-up, then it falls apart and eventually
+we cross over the hardcoded limited of how many properties can be
+attached to a single object.
+
+Fix this by resetting the property count. Nothing else to clean up
+since it's all static storage anyway.
+
+Reported-and-tested-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Fixes: 6f11f37459d8 ("drm/plane: remove drm_helper_get_plane_damage_clips")
+Cc: José Roberto de Souza <jose.souza@intel.com>
+Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
+Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
+Cc: Hans de Goede <hdegoede@redhat.com>
+Cc: Daniel Vetter <daniel.vetter@intel.com>
+Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
+Cc: Maxime Ripard <mripard@kernel.org>
+Cc: Thomas Zimmermann <tzimmermann@suse.de>
+Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Link: https://lore.kernel.org/r/20211021202048.2638668-1-daniel.vetter@ffwll.ch
+---
+ drivers/gpu/drm/selftests/test-drm_damage_helper.c |    1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/gpu/drm/selftests/test-drm_damage_helper.c
++++ b/drivers/gpu/drm/selftests/test-drm_damage_helper.c
+@@ -30,6 +30,7 @@ static void mock_setup(struct drm_plane_
+ 	mock_device.driver = &mock_driver;
+ 	mock_device.mode_config.prop_fb_damage_clips = &mock_prop;
+ 	mock_plane.dev = &mock_device;
++	mock_obj_props.count = 0;
+ 	mock_plane.base.properties = &mock_obj_props;
+ 	mock_prop.base.id = 1; /* 0 is an invalid id */
+ 	mock_prop.dev = &mock_device;
diff --git a/patches/0001_sched_clean_up_the_might_sleep_underscore_zoo.patch b/patches/0001_sched_clean_up_the_might_sleep_underscore_zoo.patch
index a15ecaf76f30f..d6e612c2cdd81 100644
--- a/patches/0001_sched_clean_up_the_might_sleep_underscore_zoo.patch
+++ b/patches/0001_sched_clean_up_the_might_sleep_underscore_zoo.patch
@@ -107,7 +107,7 @@ Link: https://lore.kernel.org/r/20210923165357.928693482@linutronix.de
  	rcu_read_lock();
 --- a/kernel/sched/core.c
 +++ b/kernel/sched/core.c
-@@ -9488,11 +9488,11 @@ void __might_sleep(const char *file, int
+@@ -9489,11 +9489,11 @@ void __might_sleep(const char *file, int
  			(void *)current->task_state_change,
  			(void *)current->task_state_change);

@@ -121,7 +121,7 @@ Link: https://lore.kernel.org/r/20210923165357.928693482@linutronix.de
  {
  	/* Ratelimiting timestamp: */
  	static unsigned long prev_jiffy;
-@@ -9537,7 +9537,7 @@ void ___might_sleep(const char *file, in
+@@ -9538,7 +9538,7 @@ void ___might_sleep(const char *file, in
  	dump_stack();
  	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
  }
diff --git a/patches/0002-drm-Increase-DRM_OBJECT_MAX_PROPERTY-by-18.patch b/patches/0002-drm-Increase-DRM_OBJECT_MAX_PROPERTY-by-18.patch
deleted file mode 100644
index 2e0a3d61e4180..0000000000000
--- a/patches/0002-drm-Increase-DRM_OBJECT_MAX_PROPERTY-by-18.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Date: Sat, 2 Oct 2021 12:03:48 +0200
-Subject: [PATCH 02/10] drm: Increase DRM_OBJECT_MAX_PROPERTY by 18.
-
-The warning poped up, it says it increase it by the number of occurence.
-I saw it 18 times so here it is.
-It started to up since commit
-   2f425cf5242a0 ("drm: Fix oops in damage self-tests by mocking damage property")
-
-Increase DRM_OBJECT_MAX_PROPERTY by 18.
-
-Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Link: https://lkml.kernel.org/r/20211005065151.828922-1-bigeasy@linutronix.de
----
- include/drm/drm_mode_object.h |    2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/include/drm/drm_mode_object.h
-+++ b/include/drm/drm_mode_object.h
-@@ -60,7 +60,7 @@ struct drm_mode_object {
- 	void (*free_cb)(struct kref *kref);
- };
-
--#define DRM_OBJECT_MAX_PROPERTY 24
-+#define DRM_OBJECT_MAX_PROPERTY 42
- /**
-  * struct drm_object_properties - property tracking for &drm_mode_object
-  */
diff --git a/patches/0002-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch b/patches/0002-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch
new file mode 100644
index 0000000000000..a9ffde835fd76
--- /dev/null
+++ b/patches/0002-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch
@@ -0,0 +1,137 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Tue, 7 Jul 2020 12:25:11 +0200
+Subject: [PATCH 02/10] drm/i915: Don't disable interrupts and pretend a lock
+ as been acquired in __timeline_mark_lock().
+
+This is a revert of commits
+   d67739268cf0e ("drm/i915/gt: Mark up the nested engine-pm timeline lock as irqsafe")
+   6c69a45445af9 ("drm/i915/gt: Mark context->active_count as protected by timeline->mutex")
+
+The existing code leads to a different behaviour depending on whether
+lockdep is enabled or not. Any following lock that is acquired without
+disabling interrupts (but needs to) will not be noticed by lockdep.
+
+This it not just a lockdep annotation but is used but an actual mutex_t
+that is properly used as a lock but in case of __timeline_mark_lock()
+lockdep is only told that it is acquired but no lock has been acquired.
+
+It appears that its purpose is just satisfy the lockdep_assert_held()
+check in intel_context_mark_active(). The other problem with disabling
+interrupts is that on PREEMPT_RT interrupts are also disabled which
+leads to problems for instance later during memory allocation.
+
+Add a CONTEXT_IS_PARKED bit to intel_engine_cs and set_bit/clear_bit it
+instead of mutex_acquire/mutex_release. Use test_bit in the two
+identified spots which relied on the lockdep annotation.
+
+Cc: Peter Zijlstra <peterz@infradead.org>
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+---
+ drivers/gpu/drm/i915/gt/intel_context.h       |    3 +-
+ drivers/gpu/drm/i915/gt/intel_context_types.h |    1
+ drivers/gpu/drm/i915/gt/intel_engine_pm.c     |   38 +-------------------------
+ drivers/gpu/drm/i915/i915_request.h           |    3 +-
+ 4 files changed, 7 insertions(+), 38 deletions(-)
+
+--- a/drivers/gpu/drm/i915/gt/intel_context.h
++++ b/drivers/gpu/drm/i915/gt/intel_context.h
+@@ -163,7 +163,8 @@ static inline void intel_context_enter(s
+
+ static inline void intel_context_mark_active(struct intel_context *ce)
+ {
+-	lockdep_assert_held(&ce->timeline->mutex);
++	lockdep_assert(lockdep_is_held(&ce->timeline->mutex) ||
++		       test_bit(CONTEXT_IS_PARKED, &ce->flags));
+ 	++ce->active_count;
+ }
+
+--- a/drivers/gpu/drm/i915/gt/intel_context_types.h
++++ b/drivers/gpu/drm/i915/gt/intel_context_types.h
+@@ -112,6 +112,7 @@ struct intel_context {
+ #define CONTEXT_FORCE_SINGLE_SUBMISSION	7
+ #define CONTEXT_NOPREEMPT		8
+ #define CONTEXT_LRCA_DIRTY		9
++#define CONTEXT_IS_PARKED		10
+
+ 	struct {
+ 		u64 timeout_us;
+--- a/drivers/gpu/drm/i915/gt/intel_engine_pm.c
++++ b/drivers/gpu/drm/i915/gt/intel_engine_pm.c
+@@ -80,39 +80,6 @@ static int __engine_unpark(struct intel_
+ 	return 0;
+ }
+
+-#if IS_ENABLED(CONFIG_LOCKDEP)
+-
+-static unsigned long __timeline_mark_lock(struct intel_context *ce)
+-{
+-	unsigned long flags;
+-
+-	local_irq_save(flags);
+-	mutex_acquire(&ce->timeline->mutex.dep_map, 2, 0, _THIS_IP_);
+-
+-	return flags;
+-}
+-
+-static void __timeline_mark_unlock(struct intel_context *ce,
+-				   unsigned long flags)
+-{
+-	mutex_release(&ce->timeline->mutex.dep_map, _THIS_IP_);
+-	local_irq_restore(flags);
+-}
+-
+-#else
+-
+-static unsigned long __timeline_mark_lock(struct intel_context *ce)
+-{
+-	return 0;
+-}
+-
+-static void __timeline_mark_unlock(struct intel_context *ce,
+-				   unsigned long flags)
+-{
+-}
+-
+-#endif /* !IS_ENABLED(CONFIG_LOCKDEP) */
+-
+ static void duration(struct dma_fence *fence, struct dma_fence_cb *cb)
+ {
+ 	struct i915_request *rq = to_request(fence);
+@@ -159,7 +126,6 @@ static bool switch_to_kernel_context(str
+ {
+ 	struct intel_context *ce = engine->kernel_context;
+ 	struct i915_request *rq;
+-	unsigned long flags;
+ 	bool result = true;
+
+ 	/* GPU is pointing to the void, as good as in the kernel context. */
+@@ -201,7 +167,7 @@ static bool switch_to_kernel_context(str
+ 	 * engine->wakeref.count, we may see the request completion and retire
+ 	 * it causing an underflow of the engine->wakeref.
+ 	 */
+-	flags = __timeline_mark_lock(ce);
++	set_bit(CONTEXT_IS_PARKED, &ce->flags);
+ 	GEM_BUG_ON(atomic_read(&ce->timeline->active_count) < 0);
+
+ 	rq = __i915_request_create(ce, GFP_NOWAIT);
+@@ -233,7 +199,7 @@ static bool switch_to_kernel_context(str
+
+ 	result = false;
+ out_unlock:
+-	__timeline_mark_unlock(ce, flags);
++	clear_bit(CONTEXT_IS_PARKED, &ce->flags);
+ 	return result;
+ }
+
+--- a/drivers/gpu/drm/i915/i915_request.h
++++ b/drivers/gpu/drm/i915/i915_request.h
+@@ -609,7 +609,8 @@ i915_request_timeline(const struct i915_
+ {
+ 	/* Valid only while the request is being constructed (or retired). */
+ 	return rcu_dereference_protected(rq->timeline,
+-					 lockdep_is_held(&rcu_access_pointer(rq->timeline)->mutex));
++					 lockdep_is_held(&rcu_access_pointer(rq->timeline)->mutex) ||
++					 test_bit(CONTEXT_IS_PARKED, &rq->context->flags));
+ }
+
+ static inline struct i915_gem_context *
diff --git a/patches/0003_sched_remove_preempt_offset_argument_from___might_sleep.patch b/patches/0003_sched_remove_preempt_offset_argument_from___might_sleep.patch
index 39373c8785e29..b6960b2ec26d6 100644
--- a/patches/0003_sched_remove_preempt_offset_argument_from___might_sleep.patch
+++ b/patches/0003_sched_remove_preempt_offset_argument_from___might_sleep.patch
@@ -45,7 +45,7 @@ Link: https://lore.kernel.org/r/20210923165358.054321586@linutronix.de
  # define cant_migrate()		do { } while (0)
 --- a/kernel/sched/core.c
 +++ b/kernel/sched/core.c
-@@ -9474,7 +9474,7 @@ static inline int preempt_count_equals(i
+@@ -9475,7 +9475,7 @@ static inline int preempt_count_equals(i
  	return (nested == preempt_offset);
  }

@@ -54,7 +54,7 @@ Link: https://lore.kernel.org/r/20210923165358.054321586@linutronix.de
  {
  	unsigned int state = get_current_state();
  	/*
-@@ -9488,7 +9488,7 @@ void __might_sleep(const char *file, int
+@@ -9489,7 +9489,7 @@ void __might_sleep(const char *file, int
  			(void *)current->task_state_change,
  			(void *)current->task_state_change);

diff --git a/patches/0004_sched_cleanup_might_sleep_printks.patch b/patches/0004_sched_cleanup_might_sleep_printks.patch
index 881ac58805386..caf4ca41ac4b4 100644
--- a/patches/0004_sched_cleanup_might_sleep_printks.patch
+++ b/patches/0004_sched_cleanup_might_sleep_printks.patch
@@ -13,7 +13,7 @@ Link: https://lore.kernel.org/r/20210923165358.117496067@linutronix.de

 --- a/kernel/sched/core.c
 +++ b/kernel/sched/core.c
-@@ -9515,16 +9515,14 @@ void __might_resched(const char *file, i
+@@ -9516,16 +9516,14 @@ void __might_resched(const char *file, i
  	/* Save this before calling printk(), since that will clobber it: */
  	preempt_disable_ip = get_preempt_disable_ip(current);

diff --git a/patches/0005-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch b/patches/0005-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch
deleted file mode 100644
index b53679b5e75a9..0000000000000
--- a/patches/0005-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Date: Thu, 6 Dec 2018 09:52:20 +0100
-Subject: [PATCH 05/10] drm/i915: Disable tracing points on PREEMPT_RT
-
-Luca Abeni reported this:
-| BUG: scheduling while atomic: kworker/u8:2/15203/0x00000003
-| CPU: 1 PID: 15203 Comm: kworker/u8:2 Not tainted 4.19.1-rt3 #10
-| Call Trace:
-|  rt_spin_lock+0x3f/0x50
-|  gen6_read32+0x45/0x1d0 [i915]
-|  g4x_get_vblank_counter+0x36/0x40 [i915]
-|  trace_event_raw_event_i915_pipe_update_start+0x7d/0xf0 [i915]
-
-The tracing events use trace_i915_pipe_update_start() among other events
-use functions acquire spinlock_t locks which are transformed into
-sleeping locks on PREEMPT_RT. A few trace points use
-intel_get_crtc_scanline(), others use ->get_vblank_counter() wich also
-might acquire a sleeping locks on PREEMPT_RT.
-At the time the arguments are evaluated within trace point, preemption
-is disabled and so the locks must not be acquired on PREEMPT_RT.
-
-Based on this I don't see any other way than disable trace points on
-PREMPT_RT.
-
-Reported-by: Luca Abeni <lucabe72@gmail.com>
-Cc: Steven Rostedt <rostedt@goodmis.org>
-Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
----
- drivers/gpu/drm/i915/i915_trace.h |    4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/drivers/gpu/drm/i915/i915_trace.h
-+++ b/drivers/gpu/drm/i915/i915_trace.h
-@@ -2,6 +2,10 @@
- #if !defined(_I915_TRACE_H_) || defined(TRACE_HEADER_MULTI_READ)
- #define _I915_TRACE_H_
-
-+#ifdef CONFIG_PREEMPT_RT
-+#define NOTRACE
-+#endif
-+
- #include <linux/stringify.h>
- #include <linux/types.h>
- #include <linux/tracepoint.h>
diff --git a/patches/0005-drm-i915-Don-t-check-for-atomic-context-on-PREEMPT_R.patch b/patches/0005-drm-i915-Don-t-check-for-atomic-context-on-PREEMPT_R.patch
new file mode 100644
index 0000000000000..88fd283330f10
--- /dev/null
+++ b/patches/0005-drm-i915-Don-t-check-for-atomic-context-on-PREEMPT_R.patch
@@ -0,0 +1,29 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Mon, 25 Oct 2021 15:05:18 +0200
+Subject: [PATCH 05/10] drm/i915: Don't check for atomic context on PREEMPT_RT
+
+The !in_atomic() check in _wait_for_atomic() triggers on PREEMPT_RT
+because the uncore::lock is a spinlock_t and does not disable
+preemption or interrupts.
+
+Changing the uncore:lock to a raw_spinlock_t doubles the worst case
+latency on an otherwise idle testbox during testing. Therefore I'm
+currently unsure about changing this.
+
+Link: https://lore.kernel.org/all/20211006164628.s2mtsdd2jdbfyf7g@linutronix.de/
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+---
+ drivers/gpu/drm/i915/i915_utils.h |    2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/i915/i915_utils.h
++++ b/drivers/gpu/drm/i915/i915_utils.h
+@@ -343,7 +343,7 @@ wait_remaining_ms_from_jiffies(unsigned
+ #define wait_for(COND, MS)		_wait_for((COND), (MS) * 1000, 10, 1000)
+
+ /* If CONFIG_PREEMPT_COUNT is disabled, in_atomic() always reports false. */
+-#if defined(CONFIG_DRM_I915_DEBUG) && defined(CONFIG_PREEMPT_COUNT)
++#if defined(CONFIG_DRM_I915_DEBUG) && defined(CONFIG_PREEMPT_COUNT) && !defined(CONFIG_PREEMPT_RT)
+ # define _WAIT_FOR_ATOMIC_CHECK(ATOMIC) WARN_ON_ONCE((ATOMIC) && !in_atomic())
+ #else
+ # define _WAIT_FOR_ATOMIC_CHECK(ATOMIC) do { } while (0)
diff --git a/patches/0005_sched_make_might_sleep_output_less_confusing.patch b/patches/0005_sched_make_might_sleep_output_less_confusing.patch
index 45261f00d3c39..69bd3d8fe71a4 100644
--- a/patches/0005_sched_make_might_sleep_output_less_confusing.patch
+++ b/patches/0005_sched_make_might_sleep_output_less_confusing.patch
@@ -83,7 +83,7 @@ Link: https://lore.kernel.org/r/20210923165358.181022656@linutronix.de

 --- a/kernel/sched/core.c
 +++ b/kernel/sched/core.c
-@@ -9492,6 +9492,18 @@ void __might_sleep(const char *file, int
+@@ -9493,6 +9493,18 @@ void __might_sleep(const char *file, int
  }
  EXPORT_SYMBOL(__might_sleep);

@@ -102,7 +102,7 @@ Link: https://lore.kernel.org/r/20210923165358.181022656@linutronix.de
  void __might_resched(const char *file, int line, int preempt_offset)
  {
  	/* Ratelimiting timestamp: */
-@@ -9520,6 +9532,13 @@ void __might_resched(const char *file, i
+@@ -9521,6 +9533,13 @@ void __might_resched(const char *file, i
  	pr_err("in_atomic(): %d, irqs_disabled(): %d, non_block: %d, pid: %d, name: %s\n",
  	       in_atomic(), irqs_disabled(), current->non_block_count,
  	       current->pid, current->comm);
@@ -116,7 +116,7 @@ Link: https://lore.kernel.org/r/20210923165358.181022656@linutronix.de

  	if (task_stack_end_corrupted(current))
  		pr_emerg("Thread overran stack, or stack corrupted\n");
-@@ -9527,11 +9546,9 @@ void __might_resched(const char *file, i
+@@ -9528,11 +9547,9 @@ void __might_resched(const char *file, i
  	debug_show_held_locks(current);
  	if (irqs_disabled())
  		print_irqtrace_events(current);
diff --git a/patches/0006-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch b/patches/0006-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch
new file mode 100644
index 0000000000000..ce5b4a1d7c986
--- /dev/null
+++ b/patches/0006-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch
@@ -0,0 +1,44 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Thu, 6 Dec 2018 09:52:20 +0100
+Subject: [PATCH 06/10] drm/i915: Disable tracing points on PREEMPT_RT
+
+Luca Abeni reported this:
+| BUG: scheduling while atomic: kworker/u8:2/15203/0x00000003
+| CPU: 1 PID: 15203 Comm: kworker/u8:2 Not tainted 4.19.1-rt3 #10
+| Call Trace:
+|  rt_spin_lock+0x3f/0x50
+|  gen6_read32+0x45/0x1d0 [i915]
+|  g4x_get_vblank_counter+0x36/0x40 [i915]
+|  trace_event_raw_event_i915_pipe_update_start+0x7d/0xf0 [i915]
+
+The tracing events use trace_i915_pipe_update_start() among other events
+use functions acquire spinlock_t locks which are transformed into
+sleeping locks on PREEMPT_RT. A few trace points use
+intel_get_crtc_scanline(), others use ->get_vblank_counter() wich also
+might acquire a sleeping locks on PREEMPT_RT.
+At the time the arguments are evaluated within trace point, preemption
+is disabled and so the locks must not be acquired on PREEMPT_RT.
+
+Based on this I don't see any other way than disable trace points on
+PREMPT_RT.
+
+Reported-by: Luca Abeni <lucabe72@gmail.com>
+Cc: Steven Rostedt <rostedt@goodmis.org>
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+---
+ drivers/gpu/drm/i915/i915_trace.h |    4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/gpu/drm/i915/i915_trace.h
++++ b/drivers/gpu/drm/i915/i915_trace.h
+@@ -2,6 +2,10 @@
+ #if !defined(_I915_TRACE_H_) || defined(TRACE_HEADER_MULTI_READ)
+ #define _I915_TRACE_H_
+
++#ifdef CONFIG_PREEMPT_RT
++#define NOTRACE
++#endif
++
+ #include <linux/stringify.h>
+ #include <linux/types.h>
+ #include <linux/tracepoint.h>
diff --git a/patches/0006-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch b/patches/0006-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch
deleted file mode 100644
index d014fd1619681..0000000000000
--- a/patches/0006-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Date: Wed, 19 Dec 2018 10:47:02 +0100
-Subject: [PATCH 06/10] drm/i915: skip DRM_I915_LOW_LEVEL_TRACEPOINTS with
- NOTRACE
-
-The order of the header files is important. If this header file is
-included after tracepoint.h was included then the NOTRACE here becomes a
-nop. Currently this happens for two .c files which use the tracepoitns
-behind DRM_I915_LOW_LEVEL_TRACEPOINTS.
-
-Cc: Steven Rostedt <rostedt@goodmis.org>
-Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
----
- drivers/gpu/drm/i915/i915_trace.h |    2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/gpu/drm/i915/i915_trace.h
-+++ b/drivers/gpu/drm/i915/i915_trace.h
-@@ -826,7 +826,7 @@ DEFINE_EVENT(i915_request, i915_request_
- 	     TP_ARGS(rq)
- );
-
--#if defined(CONFIG_DRM_I915_LOW_LEVEL_TRACEPOINTS)
-+#if defined(CONFIG_DRM_I915_LOW_LEVEL_TRACEPOINTS) && !defined(NOTRACE)
- DEFINE_EVENT(i915_request, i915_request_guc_submit,
- 	     TP_PROTO(struct i915_request *rq),
- 	     TP_ARGS(rq)
diff --git a/patches/0006_sched_make_rcu_nest_depth_distinct_in___might_resched.patch b/patches/0006_sched_make_rcu_nest_depth_distinct_in___might_resched.patch
index 2a8d202bb9e61..c3943c2ecb367 100644
--- a/patches/0006_sched_make_rcu_nest_depth_distinct_in___might_resched.patch
+++ b/patches/0006_sched_make_rcu_nest_depth_distinct_in___might_resched.patch
@@ -56,7 +56,7 @@ Link: https://lore.kernel.org/r/20210923165358.243232823@linutronix.de
  	__cond_resched_lock(lock);					\
 --- a/kernel/sched/core.c
 +++ b/kernel/sched/core.c
-@@ -9467,12 +9467,6 @@ void __init sched_init(void)
+@@ -9468,12 +9468,6 @@ void __init sched_init(void)
  }

  #ifdef CONFIG_DEBUG_ATOMIC_SLEEP
@@ -69,7 +69,7 @@ Link: https://lore.kernel.org/r/20210923165358.243232823@linutronix.de

  void __might_sleep(const char *file, int line)
  {
-@@ -9504,7 +9498,16 @@ static void print_preempt_disable_ip(int
+@@ -9505,7 +9499,16 @@ static void print_preempt_disable_ip(int
  	print_ip_sym(KERN_ERR, ip);
  }

@@ -87,7 +87,7 @@ Link: https://lore.kernel.org/r/20210923165358.243232823@linutronix.de
  {
  	/* Ratelimiting timestamp: */
  	static unsigned long prev_jiffy;
-@@ -9514,7 +9517,7 @@ void __might_resched(const char *file, i
+@@ -9515,7 +9518,7 @@ void __might_resched(const char *file, i
  	/* WARN_ON_ONCE() by default, no rate limit required: */
  	rcu_sleep_check();

@@ -96,7 +96,7 @@ Link: https://lore.kernel.org/r/20210923165358.243232823@linutronix.de
  	     !is_idle_task(current) && !current->non_block_count) ||
  	    system_state == SYSTEM_BOOTING || system_state > SYSTEM_RUNNING ||
  	    oops_in_progress)
-@@ -9533,11 +9536,11 @@ void __might_resched(const char *file, i
+@@ -9534,11 +9537,11 @@ void __might_resched(const char *file, i
  	       in_atomic(), irqs_disabled(), current->non_block_count,
  	       current->pid, current->comm);
  	pr_err("preempt_count: %x, expected: %x\n", preempt_count(),
@@ -111,7 +111,7 @@ Link: https://lore.kernel.org/r/20210923165358.243232823@linutronix.de
  	}

  	if (task_stack_end_corrupted(current))
-@@ -9547,7 +9550,8 @@ void __might_resched(const char *file, i
+@@ -9548,7 +9551,8 @@ void __might_resched(const char *file, i
  	if (irqs_disabled())
  		print_irqtrace_events(current);

diff --git a/patches/0007-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch b/patches/0007-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch
deleted file mode 100644
index 35d8d17801474..0000000000000
--- a/patches/0007-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch
+++ /dev/null
@@ -1,41 +0,0 @@
-From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Date: Wed, 8 Sep 2021 17:18:00 +0200
-Subject: [PATCH 07/10] drm/i915/gt: Queue and wait for the irq_work item.
-
-Disabling interrupts and invoking the irq_work function directly breaks
-on PREEMPT_RT.
-PREEMPT_RT does not invoke all irq_work from hardirq context because
-some of the user have spinlock_t locking in the callback function.
-These locks are then turned into a sleeping locks which can not be
-acquired with disabled interrupts.
-
-Using irq_work_queue() has the benefit that the irqwork will be invoked
-in the regular context. In general there is "no" delay between enqueuing
-the callback and its invocation because the interrupt is raised right
-away on architectures which support it (which includes x86).
-
-Use irq_work_queue() + irq_work_sync() instead invoking the callback
-directly.
-
-Reported-by: Clark Williams <williams@redhat.com>
-Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
----
- drivers/gpu/drm/i915/gt/intel_breadcrumbs.c |    5 ++---
- 1 file changed, 2 insertions(+), 3 deletions(-)
-
---- a/drivers/gpu/drm/i915/gt/intel_breadcrumbs.c
-+++ b/drivers/gpu/drm/i915/gt/intel_breadcrumbs.c
-@@ -311,10 +311,9 @@ void __intel_breadcrumbs_park(struct int
- 	/* Kick the work once more to drain the signalers, and disarm the irq */
- 	irq_work_sync(&b->irq_work);
- 	while (READ_ONCE(b->irq_armed) && !atomic_read(&b->active)) {
--		local_irq_disable();
--		signal_irq_work(&b->irq_work);
--		local_irq_enable();
-+		irq_work_queue(&b->irq_work);
- 		cond_resched();
-+		irq_work_sync(&b->irq_work);
- 	}
- }
-
diff --git a/patches/0007-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch b/patches/0007-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch
new file mode 100644
index 0000000000000..f04c7d1224c93
--- /dev/null
+++ b/patches/0007-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch
@@ -0,0 +1,28 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Wed, 19 Dec 2018 10:47:02 +0100
+Subject: [PATCH 07/10] drm/i915: skip DRM_I915_LOW_LEVEL_TRACEPOINTS with
+ NOTRACE
+
+The order of the header files is important. If this header file is
+included after tracepoint.h was included then the NOTRACE here becomes a
+nop. Currently this happens for two .c files which use the tracepoitns
+behind DRM_I915_LOW_LEVEL_TRACEPOINTS.
+
+Cc: Steven Rostedt <rostedt@goodmis.org>
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
+---
+ drivers/gpu/drm/i915/i915_trace.h |    2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/i915/i915_trace.h
++++ b/drivers/gpu/drm/i915/i915_trace.h
+@@ -826,7 +826,7 @@ DEFINE_EVENT(i915_request, i915_request_
+ 	     TP_ARGS(rq)
+ );
+
+-#if defined(CONFIG_DRM_I915_LOW_LEVEL_TRACEPOINTS)
++#if defined(CONFIG_DRM_I915_LOW_LEVEL_TRACEPOINTS) && !defined(NOTRACE)
+ DEFINE_EVENT(i915_request, i915_request_guc_submit,
+ 	     TP_PROTO(struct i915_request *rq),
+ 	     TP_ARGS(rq)
diff --git a/patches/0008-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch b/patches/0008-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch
new file mode 100644
index 0000000000000..89d12313d2873
--- /dev/null
+++ b/patches/0008-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch
@@ -0,0 +1,41 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Wed, 8 Sep 2021 17:18:00 +0200
+Subject: [PATCH 08/10] drm/i915/gt: Queue and wait for the irq_work item.
+
+Disabling interrupts and invoking the irq_work function directly breaks
+on PREEMPT_RT.
+PREEMPT_RT does not invoke all irq_work from hardirq context because
+some of the user have spinlock_t locking in the callback function.
+These locks are then turned into a sleeping locks which can not be
+acquired with disabled interrupts.
+
+Using irq_work_queue() has the benefit that the irqwork will be invoked
+in the regular context. In general there is "no" delay between enqueuing
+the callback and its invocation because the interrupt is raised right
+away on architectures which support it (which includes x86).
+
+Use irq_work_queue() + irq_work_sync() instead invoking the callback
+directly.
+
+Reported-by: Clark Williams <williams@redhat.com>
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
+---
+ drivers/gpu/drm/i915/gt/intel_breadcrumbs.c |    5 ++---
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+--- a/drivers/gpu/drm/i915/gt/intel_breadcrumbs.c
++++ b/drivers/gpu/drm/i915/gt/intel_breadcrumbs.c
+@@ -311,10 +311,9 @@ void __intel_breadcrumbs_park(struct int
+ 	/* Kick the work once more to drain the signalers, and disarm the irq */
+ 	irq_work_sync(&b->irq_work);
+ 	while (READ_ONCE(b->irq_armed) && !atomic_read(&b->active)) {
+-		local_irq_disable();
+-		signal_irq_work(&b->irq_work);
+-		local_irq_enable();
++		irq_work_queue(&b->irq_work);
+ 		cond_resched();
++		irq_work_sync(&b->irq_work);
+ 	}
+ }
+
diff --git a/patches/0008-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch b/patches/0008-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch
deleted file mode 100644
index ba915643b99ab..0000000000000
--- a/patches/0008-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch
+++ /dev/null
@@ -1,88 +0,0 @@
-From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Date: Wed, 8 Sep 2021 19:03:41 +0200
-Subject: [PATCH 08/10] drm/i915/gt: Use spin_lock_irq() instead of
- local_irq_disable() + spin_lock()
-
-execlists_dequeue() is invoked from a function which uses
-local_irq_disable() to disable interrupts so the spin_lock() behaves
-like spin_lock_irq().
-This breaks PREEMPT_RT because local_irq_disable() + spin_lock() is not
-the same as spin_lock_irq().
-
-execlists_dequeue_irq() and execlists_dequeue() has each one caller
-only. If intel_engine_cs::active::lock is acquired and released with the
-_irq suffix then it behaves almost as if execlists_dequeue() would be
-invoked with disabled interrupts. The difference is the last part of the
-function which is then invoked with enabled interrupts.
-I can't tell if this makes a difference. From looking at it, it might
-work to move the last unlock at the end of the function as I didn't find
-anything that would acquire the lock again.
-
-Reported-by: Clark Williams <williams@redhat.com>
-Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
----
- drivers/gpu/drm/i915/gt/intel_execlists_submission.c |   17 +++++------------
- 1 file changed, 5 insertions(+), 12 deletions(-)
-
---- a/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
-+++ b/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
-@@ -1283,7 +1283,7 @@ static void execlists_dequeue(struct int
- 	 * and context switches) submission.
- 	 */
-
--	spin_lock(&sched_engine->lock);
-+	spin_lock_irq(&sched_engine->lock);
-
- 	/*
- 	 * If the queue is higher priority than the last
-@@ -1383,7 +1383,7 @@ static void execlists_dequeue(struct int
- 				 * Even if ELSP[1] is occupied and not worthy
- 				 * of timeslices, our queue might be.
- 				 */
--				spin_unlock(&sched_engine->lock);
-+				spin_unlock_irq(&sched_engine->lock);
- 				return;
- 			}
- 		}
-@@ -1409,7 +1409,7 @@ static void execlists_dequeue(struct int
-
- 		if (last && !can_merge_rq(last, rq)) {
- 			spin_unlock(&ve->base.sched_engine->lock);
--			spin_unlock(&engine->sched_engine->lock);
-+			spin_unlock_irq(&engine->sched_engine->lock);
- 			return; /* leave this for another sibling */
- 		}
-
-@@ -1571,7 +1571,7 @@ static void execlists_dequeue(struct int
- 	 */
- 	sched_engine->queue_priority_hint = queue_prio(sched_engine);
- 	i915_sched_engine_reset_on_empty(sched_engine);
--	spin_unlock(&sched_engine->lock);
-+	spin_unlock_irq(&sched_engine->lock);
-
- 	/*
- 	 * We can skip poking the HW if we ended up with exactly the same set
-@@ -1597,13 +1597,6 @@ static void execlists_dequeue(struct int
- 	}
- }
-
--static void execlists_dequeue_irq(struct intel_engine_cs *engine)
--{
--	local_irq_disable(); /* Suspend interrupts across request submission */
--	execlists_dequeue(engine);
--	local_irq_enable(); /* flush irq_work (e.g. breadcrumb enabling) */
--}
--
- static void clear_ports(struct i915_request **ports, int count)
- {
- 	memset_p((void **)ports, NULL, count);
-@@ -2427,7 +2420,7 @@ static void execlists_submission_tasklet
- 	}
-
- 	if (!engine->execlists.pending[0]) {
--		execlists_dequeue_irq(engine);
-+		execlists_dequeue(engine);
- 		start_timeslice(engine);
- 	}
-
diff --git a/patches/0009-drm-i915-Drop-the-irqs_disabled-check.patch b/patches/0009-drm-i915-Drop-the-irqs_disabled-check.patch
deleted file mode 100644
index 8fc17fbdd8f84..0000000000000
--- a/patches/0009-drm-i915-Drop-the-irqs_disabled-check.patch
+++ /dev/null
@@ -1,38 +0,0 @@
-From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Date: Fri, 1 Oct 2021 20:01:03 +0200
-Subject: [PATCH 09/10] drm/i915: Drop the irqs_disabled() check
-
-The !irqs_disabled() check triggers on PREEMPT_RT even with
-i915_sched_engine::lock acquired. The reason is the lock is transformed
-into a sleeping lock on PREEMPT_RT and does not disable interrupts.
-
-There is no need to check for disabled interrupts. The lockdep
-annotation below already check if the lock has been acquired by the
-caller and will yell if the interrupts are not disabled.
-
-Remove the !irqs_disabled() check.
-
-Reported-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
-Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
----
- drivers/gpu/drm/i915/i915_request.c |    2 --
- 1 file changed, 2 deletions(-)
-
---- a/drivers/gpu/drm/i915/i915_request.c
-+++ b/drivers/gpu/drm/i915/i915_request.c
-@@ -559,7 +559,6 @@ bool __i915_request_submit(struct i915_r
-
- 	RQ_TRACE(request, "\n");
-
--	GEM_BUG_ON(!irqs_disabled());
- 	lockdep_assert_held(&engine->sched_engine->lock);
-
- 	/*
-@@ -668,7 +667,6 @@ void __i915_request_unsubmit(struct i915
- 	 */
- 	RQ_TRACE(request, "\n");
-
--	GEM_BUG_ON(!irqs_disabled());
- 	lockdep_assert_held(&engine->sched_engine->lock);
-
- 	/*
diff --git a/patches/0009-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch b/patches/0009-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch
new file mode 100644
index 0000000000000..59dcdda0f7e45
--- /dev/null
+++ b/patches/0009-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch
@@ -0,0 +1,88 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Wed, 8 Sep 2021 19:03:41 +0200
+Subject: [PATCH 09/10] drm/i915/gt: Use spin_lock_irq() instead of
+ local_irq_disable() + spin_lock()
+
+execlists_dequeue() is invoked from a function which uses
+local_irq_disable() to disable interrupts so the spin_lock() behaves
+like spin_lock_irq().
+This breaks PREEMPT_RT because local_irq_disable() + spin_lock() is not
+the same as spin_lock_irq().
+
+execlists_dequeue_irq() and execlists_dequeue() has each one caller
+only. If intel_engine_cs::active::lock is acquired and released with the
+_irq suffix then it behaves almost as if execlists_dequeue() would be
+invoked with disabled interrupts. The difference is the last part of the
+function which is then invoked with enabled interrupts.
+I can't tell if this makes a difference. From looking at it, it might
+work to move the last unlock at the end of the function as I didn't find
+anything that would acquire the lock again.
+
+Reported-by: Clark Williams <williams@redhat.com>
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
+---
+ drivers/gpu/drm/i915/gt/intel_execlists_submission.c |   17 +++++------------
+ 1 file changed, 5 insertions(+), 12 deletions(-)
+
+--- a/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
++++ b/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
+@@ -1283,7 +1283,7 @@ static void execlists_dequeue(struct int
+ 	 * and context switches) submission.
+ 	 */
+
+-	spin_lock(&sched_engine->lock);
++	spin_lock_irq(&sched_engine->lock);
+
+ 	/*
+ 	 * If the queue is higher priority than the last
+@@ -1383,7 +1383,7 @@ static void execlists_dequeue(struct int
+ 				 * Even if ELSP[1] is occupied and not worthy
+ 				 * of timeslices, our queue might be.
+ 				 */
+-				spin_unlock(&sched_engine->lock);
++				spin_unlock_irq(&sched_engine->lock);
+ 				return;
+ 			}
+ 		}
+@@ -1409,7 +1409,7 @@ static void execlists_dequeue(struct int
+
+ 		if (last && !can_merge_rq(last, rq)) {
+ 			spin_unlock(&ve->base.sched_engine->lock);
+-			spin_unlock(&engine->sched_engine->lock);
++			spin_unlock_irq(&engine->sched_engine->lock);
+ 			return; /* leave this for another sibling */
+ 		}
+
+@@ -1571,7 +1571,7 @@ static void execlists_dequeue(struct int
+ 	 */
+ 	sched_engine->queue_priority_hint = queue_prio(sched_engine);
+ 	i915_sched_engine_reset_on_empty(sched_engine);
+-	spin_unlock(&sched_engine->lock);
++	spin_unlock_irq(&sched_engine->lock);
+
+ 	/*
+ 	 * We can skip poking the HW if we ended up with exactly the same set
+@@ -1597,13 +1597,6 @@ static void execlists_dequeue(struct int
+ 	}
+ }
+
+-static void execlists_dequeue_irq(struct intel_engine_cs *engine)
+-{
+-	local_irq_disable(); /* Suspend interrupts across request submission */
+-	execlists_dequeue(engine);
+-	local_irq_enable(); /* flush irq_work (e.g. breadcrumb enabling) */
+-}
+-
+ static void clear_ports(struct i915_request **ports, int count)
+ {
+ 	memset_p((void **)ports, NULL, count);
+@@ -2427,7 +2420,7 @@ static void execlists_submission_tasklet
+ 	}
+
+ 	if (!engine->execlists.pending[0]) {
+-		execlists_dequeue_irq(engine);
++		execlists_dequeue(engine);
+ 		start_timeslice(engine);
+ 	}
+
diff --git a/patches/0010-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch b/patches/0010-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch
deleted file mode 100644
index 0021138be3655..0000000000000
--- a/patches/0010-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch
+++ /dev/null
@@ -1,176 +0,0 @@
-From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Date: Tue, 7 Jul 2020 12:25:11 +0200
-Subject: [PATCH 10/10] drm/i915: Don't disable interrupts and pretend a lock
- as been acquired in __timeline_mark_lock().
-
-This is a revert of commits
-   d67739268cf0e ("drm/i915/gt: Mark up the nested engine-pm timeline lock as irqsafe")
-   6c69a45445af9 ("drm/i915/gt: Mark context->active_count as protected by timeline->mutex")
-
-The existing code leads to a different behaviour depending on wheather
-lockdep is enabled or not. Any following lock that is acquired without
-disabling interrupts (but needs to) will not be noticed by lockdep.
-
-This it not just a lockdep annotation but is used but an actual mutex_t
-that is properly used as a lock but in case of __timeline_mark_lock()
-lockdep is only told that it is acquired but no lock has been acquired.
-
-It appears that its purporse is just satisfy the lockdep_assert_held()
-check in intel_context_mark_active(). The other problem with disabling
-interrupts is that on PREEMPT_RT interrupts are also disabled which
-leads to problems for instance later during memory allocation.
-
-Add an argument to intel_context_mark_active() which is true if the lock
-must have been acquired, false if other magic is involved and the lock
-is not needed. Use the `false' argument only from within
-switch_to_kernel_context() and remove __timeline_mark_lock().
-
-Cc: Peter Zijlstra <peterz@infradead.org>
-Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
----
- drivers/gpu/drm/i915/gt/intel_context.h          |    6 ++-
- drivers/gpu/drm/i915/gt/intel_engine_heartbeat.c |    2 -
- drivers/gpu/drm/i915/gt/intel_engine_pm.c        |   38 -----------------------
- drivers/gpu/drm/i915/i915_request.c              |    7 ++--
- drivers/gpu/drm/i915/i915_request.h              |    3 +
- 5 files changed, 12 insertions(+), 44 deletions(-)
-
---- a/drivers/gpu/drm/i915/gt/intel_context.h
-+++ b/drivers/gpu/drm/i915/gt/intel_context.h
-@@ -161,9 +161,11 @@ static inline void intel_context_enter(s
- 		ce->ops->enter(ce);
- }
-
--static inline void intel_context_mark_active(struct intel_context *ce)
-+static inline void intel_context_mark_active(struct intel_context *ce,
-+					     bool timeline_mutex_needed)
- {
--	lockdep_assert_held(&ce->timeline->mutex);
-+	if (timeline_mutex_needed)
-+		lockdep_assert_held(&ce->timeline->mutex);
- 	++ce->active_count;
- }
-
---- a/drivers/gpu/drm/i915/gt/intel_engine_heartbeat.c
-+++ b/drivers/gpu/drm/i915/gt/intel_engine_heartbeat.c
-@@ -42,7 +42,7 @@ heartbeat_create(struct intel_context *c
- 	struct i915_request *rq;
-
- 	intel_context_enter(ce);
--	rq = __i915_request_create(ce, gfp);
-+	rq = __i915_request_create(ce, gfp, true);
- 	intel_context_exit(ce);
-
- 	return rq;
---- a/drivers/gpu/drm/i915/gt/intel_engine_pm.c
-+++ b/drivers/gpu/drm/i915/gt/intel_engine_pm.c
-@@ -80,39 +80,6 @@ static int __engine_unpark(struct intel_
- 	return 0;
- }
-
--#if IS_ENABLED(CONFIG_LOCKDEP)
--
--static unsigned long __timeline_mark_lock(struct intel_context *ce)
--{
--	unsigned long flags;
--
--	local_irq_save(flags);
--	mutex_acquire(&ce->timeline->mutex.dep_map, 2, 0, _THIS_IP_);
--
--	return flags;
--}
--
--static void __timeline_mark_unlock(struct intel_context *ce,
--				   unsigned long flags)
--{
--	mutex_release(&ce->timeline->mutex.dep_map, _THIS_IP_);
--	local_irq_restore(flags);
--}
--
--#else
--
--static unsigned long __timeline_mark_lock(struct intel_context *ce)
--{
--	return 0;
--}
--
--static void __timeline_mark_unlock(struct intel_context *ce,
--				   unsigned long flags)
--{
--}
--
--#endif /* !IS_ENABLED(CONFIG_LOCKDEP) */
--
- static void duration(struct dma_fence *fence, struct dma_fence_cb *cb)
- {
- 	struct i915_request *rq = to_request(fence);
-@@ -159,7 +126,6 @@ static bool switch_to_kernel_context(str
- {
- 	struct intel_context *ce = engine->kernel_context;
- 	struct i915_request *rq;
--	unsigned long flags;
- 	bool result = true;
-
- 	/* GPU is pointing to the void, as good as in the kernel context. */
-@@ -201,10 +167,9 @@ static bool switch_to_kernel_context(str
- 	 * engine->wakeref.count, we may see the request completion and retire
- 	 * it causing an underflow of the engine->wakeref.
- 	 */
--	flags = __timeline_mark_lock(ce);
- 	GEM_BUG_ON(atomic_read(&ce->timeline->active_count) < 0);
-
--	rq = __i915_request_create(ce, GFP_NOWAIT);
-+	rq = __i915_request_create(ce, GFP_NOWAIT, false);
- 	if (IS_ERR(rq))
- 		/* Context switch failed, hope for the best! Maybe reset? */
- 		goto out_unlock;
-@@ -233,7 +198,6 @@ static bool switch_to_kernel_context(str
-
- 	result = false;
- out_unlock:
--	__timeline_mark_unlock(ce, flags);
- 	return result;
- }
-
---- a/drivers/gpu/drm/i915/i915_request.c
-+++ b/drivers/gpu/drm/i915/i915_request.c
-@@ -833,7 +833,8 @@ static void __i915_request_ctor(void *ar
- }
-
- struct i915_request *
--__i915_request_create(struct intel_context *ce, gfp_t gfp)
-+__i915_request_create(struct intel_context *ce, gfp_t gfp,
-+		      bool timeline_mutex_needed)
- {
- 	struct intel_timeline *tl = ce->timeline;
- 	struct i915_request *rq;
-@@ -957,7 +958,7 @@ struct i915_request *
-
- 	rq->infix = rq->ring->emit; /* end of header; start of user payload */
-
--	intel_context_mark_active(ce);
-+	intel_context_mark_active(ce, timeline_mutex_needed);
- 	list_add_tail_rcu(&rq->link, &tl->requests);
-
- 	return rq;
-@@ -993,7 +994,7 @@ i915_request_create(struct intel_context
- 		i915_request_retire(rq);
-
- 	intel_context_enter(ce);
--	rq = __i915_request_create(ce, GFP_KERNEL);
-+	rq = __i915_request_create(ce, GFP_KERNEL, true);
- 	intel_context_exit(ce); /* active reference transferred to request */
- 	if (IS_ERR(rq))
- 		goto err_unlock;
---- a/drivers/gpu/drm/i915/i915_request.h
-+++ b/drivers/gpu/drm/i915/i915_request.h
-@@ -320,7 +320,8 @@ static inline bool dma_fence_is_i915(con
- struct kmem_cache *i915_request_slab_cache(void);
-
- struct i915_request * __must_check
--__i915_request_create(struct intel_context *ce, gfp_t gfp);
-+__i915_request_create(struct intel_context *ce, gfp_t gfp,
-+		      bool timeline_mutex_needed);
- struct i915_request * __must_check
- i915_request_create(struct intel_context *ce);
-
diff --git a/patches/0010-drm-i915-Drop-the-irqs_disabled-check.patch b/patches/0010-drm-i915-Drop-the-irqs_disabled-check.patch
new file mode 100644
index 0000000000000..941c5be424a5c
--- /dev/null
+++ b/patches/0010-drm-i915-Drop-the-irqs_disabled-check.patch
@@ -0,0 +1,38 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Fri, 1 Oct 2021 20:01:03 +0200
+Subject: [PATCH 10/10] drm/i915: Drop the irqs_disabled() check
+
+The !irqs_disabled() check triggers on PREEMPT_RT even with
+i915_sched_engine::lock acquired. The reason is the lock is transformed
+into a sleeping lock on PREEMPT_RT and does not disable interrupts.
+
+There is no need to check for disabled interrupts. The lockdep
+annotation below already check if the lock has been acquired by the
+caller and will yell if the interrupts are not disabled.
+
+Remove the !irqs_disabled() check.
+
+Reported-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+---
+ drivers/gpu/drm/i915/i915_request.c |    2 --
+ 1 file changed, 2 deletions(-)
+
+--- a/drivers/gpu/drm/i915/i915_request.c
++++ b/drivers/gpu/drm/i915/i915_request.c
+@@ -559,7 +559,6 @@ bool __i915_request_submit(struct i915_r
+
+ 	RQ_TRACE(request, "\n");
+
+-	GEM_BUG_ON(!irqs_disabled());
+ 	lockdep_assert_held(&engine->sched_engine->lock);
+
+ 	/*
+@@ -668,7 +667,6 @@ void __i915_request_unsubmit(struct i915
+ 	 */
+ 	RQ_TRACE(request, "\n");
+
+-	GEM_BUG_ON(!irqs_disabled());
+ 	lockdep_assert_held(&engine->sched_engine->lock);
+
+ 	/*
diff --git a/patches/ARM__Allow_to_enable_RT.patch b/patches/ARM__Allow_to_enable_RT.patch
index 5661ec31a24ac..f8a0839c8d60f 100644
--- a/patches/ARM__Allow_to_enable_RT.patch
+++ b/patches/ARM__Allow_to_enable_RT.patch
@@ -24,7 +24,7 @@ Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
  	select ARCH_USE_BUILTIN_BSWAP
  	select ARCH_USE_CMPXCHG_LOCKREF
  	select ARCH_USE_MEMTEST
-@@ -124,6 +125,7 @@ config ARM
+@@ -125,6 +126,7 @@ config ARM
  	select OLD_SIGSUSPEND3
  	select PCI_SYSCALL if PCI
  	select PERF_USE_VMALLOC
diff --git a/patches/Add_localversion_for_-RT_release.patch b/patches/Add_localversion_for_-RT_release.patch
index a3ac9f9ca746c..2361800c1e6b5 100644
--- a/patches/Add_localversion_for_-RT_release.patch
+++ b/patches/Add_localversion_for_-RT_release.patch
@@ -15,4 +15,4 @@ Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
 --- /dev/null
 +++ b/localversion-rt
 @@ -0,0 +1 @@
-+-rt14
++-rt15
diff --git a/patches/arm__Add_support_for_lazy_preemption.patch b/patches/arm__Add_support_for_lazy_preemption.patch
index dfae248340719..981c88cffa1e3 100644
--- a/patches/arm__Add_support_for_lazy_preemption.patch
+++ b/patches/arm__Add_support_for_lazy_preemption.patch
@@ -19,7 +19,7 @@ Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
 ---
 --- a/arch/arm/Kconfig
 +++ b/arch/arm/Kconfig
-@@ -108,6 +108,7 @@ config ARM
+@@ -109,6 +109,7 @@ config ARM
  	select HAVE_PERF_EVENTS
  	select HAVE_PERF_REGS
  	select HAVE_PERF_USER_STACK_DUMP
diff --git a/patches/fs-namespace-Boost-the-mount_lock.lock-owner-instead.patch b/patches/fs-namespace-Boost-the-mount_lock.lock-owner-instead.patch
new file mode 100644
index 0000000000000..42ae4096d22b6
--- /dev/null
+++ b/patches/fs-namespace-Boost-the-mount_lock.lock-owner-instead.patch
@@ -0,0 +1,57 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Mon, 25 Oct 2021 16:49:35 +0200
+Subject: [PATCH] fs/namespace: Boost the mount_lock.lock owner instead of
+ spinning on PREEMPT_RT.
+
+The MNT_WRITE_HOLD flag is used to hold back any new writers while the
+mount point is about to be made read-only. __mnt_want_write() then loops
+with disabled preemption until this flag disappears. Callers of
+mnt_hold_writers() (which sets the flag) hold the spinlock_t of
+mount_lock (seqlock_t) which disables preemption on !PREEMPT_RT and
+ensures the task is not scheduled away so that the spinning side spins
+for a long time.
+
+On PREEMPT_RT the spinlock_t does not disable preemption and so it is
+possible that the task setting MNT_WRITE_HOLD is preempted by task with
+higher priority which then spins infinitely waiting for MNT_WRITE_HOLD
+to get removed.
+
+Acquire mount_lock::lock which is held by setter of MNT_WRITE_HOLD. This
+will PI-boost the owner and wait until the lock is dropped and which
+means that MNT_WRITE_HOLD is cleared again.
+
+Link: https://lkml.kernel.org/r/20211025152218.opvcqfku2lhqvp4o@linutronix.de
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+---
+ fs/namespace.c |   20 ++++++++++++++++++--
+ 1 file changed, 18 insertions(+), 2 deletions(-)
+
+--- a/fs/namespace.c
++++ b/fs/namespace.c
+@@ -343,8 +343,24 @@ int __mnt_want_write(struct vfsmount *m)
+ 	 * incremented count after it has set MNT_WRITE_HOLD.
+ 	 */
+ 	smp_mb();
+-	while (READ_ONCE(mnt->mnt.mnt_flags) & MNT_WRITE_HOLD)
+-		cpu_relax();
++	might_lock(&mount_lock.lock);
++	while (READ_ONCE(mnt->mnt.mnt_flags) & MNT_WRITE_HOLD) {
++		if (!IS_ENABLED(CONFIG_PREEMPT_RT)) {
++			cpu_relax();
++		} else {
++			/*
++			 * This prevents priority inversion, if the task
++			 * setting MNT_WRITE_HOLD got preempted on a remote
++			 * CPU, and it prevents life lock if the task setting
++			 * MNT_WRITE_HOLD has a lower priority and is bound to
++			 * the same CPU as the task that is spinning here.
++			 */
++			preempt_enable();
++			lock_mount_hash();
++			unlock_mount_hash();
++			preempt_disable();
++		}
++	}
+ 	/*
+ 	 * After the slowpath clears MNT_WRITE_HOLD, mnt_is_readonly will
+ 	 * be set to match its requirements. So we must not load that until
diff --git a/patches/fs__namespace__Use_cpu_chill_in_trylock_loops.patch b/patches/fs__namespace__Use_cpu_chill_in_trylock_loops.patch
deleted file mode 100644
index decaf083e6405..0000000000000
--- a/patches/fs__namespace__Use_cpu_chill_in_trylock_loops.patch
+++ /dev/null
@@ -1,42 +0,0 @@
-Subject: fs: namespace: Use cpu_chill() in trylock loops
-From: Thomas Gleixner <tglx@linutronix.de>
-Date: Wed Mar  7 21:00:34 2012 +0100
-
-From: Thomas Gleixner <tglx@linutronix.de>
-
-Retry loops on RT might loop forever when the modifying side was
-preempted. Use cpu_chill() instead of cpu_relax() to let the system
-make progress.
-
-Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
-
-
-
----
- fs/namespace.c |    8 ++++++--
- 1 file changed, 6 insertions(+), 2 deletions(-)
----
---- a/fs/namespace.c
-+++ b/fs/namespace.c
-@@ -14,6 +14,7 @@
- #include <linux/mnt_namespace.h>
- #include <linux/user_namespace.h>
- #include <linux/namei.h>
-+#include <linux/hrtimer.h>
- #include <linux/security.h>
- #include <linux/cred.h>
- #include <linux/idr.h>
-@@ -343,8 +344,11 @@ int __mnt_want_write(struct vfsmount *m)
- 	 * incremented count after it has set MNT_WRITE_HOLD.
- 	 */
- 	smp_mb();
--	while (READ_ONCE(mnt->mnt.mnt_flags) & MNT_WRITE_HOLD)
--		cpu_relax();
-+	while (READ_ONCE(mnt->mnt.mnt_flags) & MNT_WRITE_HOLD) {
-+		preempt_enable();
-+		cpu_chill();
-+		preempt_disable();
-+	}
- 	/*
- 	 * After the slowpath clears MNT_WRITE_HOLD, mnt_is_readonly will
- 	 * be set to match its requirements. So we must not load that until
diff --git a/patches/fscache-Use-only-one-fscache_object_cong_wait.patch b/patches/fscache-Use-only-one-fscache_object_cong_wait.patch
new file mode 100644
index 0000000000000..6a8f1b05a566c
--- /dev/null
+++ b/patches/fscache-Use-only-one-fscache_object_cong_wait.patch
@@ -0,0 +1,117 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Thu, 28 Oct 2021 17:30:50 +0200
+Subject: [PATCH] fscache: Use only one fscache_object_cong_wait.
+
+In the commit mentioned below, fscache was converted from slow-work to
+workqueue. slow_work_enqueue() and slow_work_sleep_till_thread_needed()
+did not use a per-CPU workqueue. They choose from two global waitqueues
+depending on the SLOW_WORK_VERY_SLOW bit which was not set so it always
+one waitqueue.
+
+I can't find out how it is ensured that a waiter on certain CPU is woken
+up be the other side. My guess is that the timeout in schedule_timeout()
+ensures that it does not wait forever (or a random wake up).
+
+fscache_object_sleep_till_congested() must be invoked from preemptible
+context in order for schedule() to work. In this case this_cpu_ptr()
+should complain with CONFIG_DEBUG_PREEMPT enabled except the thread is
+bound to one CPU.
+
+wake_up() wakes only one waiter and I'm not sure if it is guaranteed
+that only one waiter exists.
+
+Replace the per-CPU waitqueue with one global waitqueue.
+
+Fixes: 8b8edefa2fffb ("fscache: convert object to use workqueue instead of slow-work")
+Reported-by: Gregor Beck <gregor.beck@gmail.com>
+Cc: stable-rt@vger.kernel.org
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+---
+ fs/fscache/internal.h |    1 -
+ fs/fscache/main.c     |    6 ------
+ fs/fscache/object.c   |   11 +++++------
+ 3 files changed, 5 insertions(+), 13 deletions(-)
+
+--- a/fs/fscache/internal.h
++++ b/fs/fscache/internal.h
+@@ -81,7 +81,6 @@ extern unsigned fscache_debug;
+ extern struct kobject *fscache_root;
+ extern struct workqueue_struct *fscache_object_wq;
+ extern struct workqueue_struct *fscache_op_wq;
+-DECLARE_PER_CPU(wait_queue_head_t, fscache_object_cong_wait);
+
+ extern unsigned int fscache_hash(unsigned int salt, unsigned int *data, unsigned int n);
+
+--- a/fs/fscache/main.c
++++ b/fs/fscache/main.c
+@@ -41,8 +41,6 @@ struct kobject *fscache_root;
+ struct workqueue_struct *fscache_object_wq;
+ struct workqueue_struct *fscache_op_wq;
+
+-DEFINE_PER_CPU(wait_queue_head_t, fscache_object_cong_wait);
+-
+ /* these values serve as lower bounds, will be adjusted in fscache_init() */
+ static unsigned fscache_object_max_active = 4;
+ static unsigned fscache_op_max_active = 2;
+@@ -138,7 +136,6 @@ unsigned int fscache_hash(unsigned int s
+ static int __init fscache_init(void)
+ {
+ 	unsigned int nr_cpus = num_possible_cpus();
+-	unsigned int cpu;
+ 	int ret;
+
+ 	fscache_object_max_active =
+@@ -161,9 +158,6 @@ static int __init fscache_init(void)
+ 	if (!fscache_op_wq)
+ 		goto error_op_wq;
+
+-	for_each_possible_cpu(cpu)
+-		init_waitqueue_head(&per_cpu(fscache_object_cong_wait, cpu));
+-
+ 	ret = fscache_proc_init();
+ 	if (ret < 0)
+ 		goto error_proc;
+--- a/fs/fscache/object.c
++++ b/fs/fscache/object.c
+@@ -798,6 +798,8 @@ void fscache_object_destroy(struct fscac
+ }
+ EXPORT_SYMBOL(fscache_object_destroy);
+
++static DECLARE_WAIT_QUEUE_HEAD(fscache_object_cong_wait);
++
+ /*
+  * enqueue an object for metadata-type processing
+  */
+@@ -806,12 +808,10 @@ void fscache_enqueue_object(struct fscac
+ 	_enter("{OBJ%x}", object->debug_id);
+
+ 	if (fscache_get_object(object, fscache_obj_get_queue) >= 0) {
+-		wait_queue_head_t *cong_wq =
+-			&get_cpu_var(fscache_object_cong_wait);
+
+ 		if (queue_work(fscache_object_wq, &object->work)) {
+ 			if (fscache_object_congested())
+-				wake_up(cong_wq);
++				wake_up(&fscache_object_cong_wait);
+ 		} else
+ 			fscache_put_object(object, fscache_obj_put_queue);
+
+@@ -833,16 +833,15 @@ void fscache_enqueue_object(struct fscac
+  */
+ bool fscache_object_sleep_till_congested(signed long *timeoutp)
+ {
+-	wait_queue_head_t *cong_wq = this_cpu_ptr(&fscache_object_cong_wait);
+ 	DEFINE_WAIT(wait);
+
+ 	if (fscache_object_congested())
+ 		return true;
+
+-	add_wait_queue_exclusive(cong_wq, &wait);
++	add_wait_queue_exclusive(&fscache_object_cong_wait, &wait);
+ 	if (!fscache_object_congested())
+ 		*timeoutp = schedule_timeout(*timeoutp);
+-	finish_wait(cong_wq, &wait);
++	finish_wait(&fscache_object_cong_wait, &wait);
+
+ 	return fscache_object_congested();
+ }
diff --git a/patches/kconfig__Disable_config_options_which_are_not_RT_compatible.patch b/patches/kconfig__Disable_config_options_which_are_not_RT_compatible.patch
deleted file mode 100644
index 9c59aa09849bd..0000000000000
--- a/patches/kconfig__Disable_config_options_which_are_not_RT_compatible.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-Subject: kconfig: Disable config options which are not RT compatible
-From: Thomas Gleixner <tglx@linutronix.de>
-Date: Sun Jul 24 12:11:43 2011 +0200
-
-From: Thomas Gleixner <tglx@linutronix.de>
-
-Disable stuff which is known to have issues on RT
-
-Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
-
-
----
- mm/Kconfig |    2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
----
---- a/mm/Kconfig
-+++ b/mm/Kconfig
-@@ -371,7 +371,7 @@ config NOMMU_INITIAL_TRIM_EXCESS
-
- config TRANSPARENT_HUGEPAGE
- 	bool "Transparent Hugepage Support"
--	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE
-+	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE && !PREEMPT_RT
- 	select COMPACTION
- 	select XARRAY_MULTI
- 	help
diff --git a/patches/mm-Disable-NUMA_BALANCING_DEFAULT_ENABLED-and-TRANSP.patch b/patches/mm-Disable-NUMA_BALANCING_DEFAULT_ENABLED-and-TRANSP.patch
new file mode 100644
index 0000000000000..e38b2fce0ceb6
--- /dev/null
+++ b/patches/mm-Disable-NUMA_BALANCING_DEFAULT_ENABLED-and-TRANSP.patch
@@ -0,0 +1,54 @@
+From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Date: Thu, 28 Oct 2021 16:33:27 +0200
+Subject: [PATCH] mm: Disable NUMA_BALANCING_DEFAULT_ENABLED and
+ TRANSPARENT_HUGEPAGE on PREEMPT_RT
+
+TRANSPARENT_HUGEPAGE:
+There are potential non-deterministic delays to an RT thread if a critical
+memory region is not THP-aligned and a non-RT buffer is located in the same
+hugepage-aligned region. It's also possible for an unrelated thread to migrate
+pages belonging to an RT task incurring unexpected page faults due to memory
+defragmentation even if khugepaged is disabled.
+
+Regular HUGEPAGEs are not affected by this can be used.
+
+NUMA_BALANCING:
+There is a non-deterministic delay to mark PTEs PROT_NONE to gather NUMA fault
+samples, increased page faults of regions even if mlocked and non-deterministic
+delays when migrating pages.
+
+[Mel Gorman worded 99% of the commit description].
+
+Link: https://lore.kernel.org/all/20200304091159.GN3818@techsingularity.net/
+Link: https://lore.kernel.org/all/20211026165100.ahz5bkx44lrrw5pt@linutronix.de/
+Cc: Mel Gorman <mgorman@techsingularity.net>
+Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+Acked-by: Mel Gorman <mgorman@techsingularity.net>
+Link: https://lore.kernel.org/r/20211028143327.hfbxjze7palrpfgp@linutronix.de
+---
+ init/Kconfig |    2 +-
+ mm/Kconfig   |    2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -901,7 +901,7 @@ config NUMA_BALANCING
+ 	bool "Memory placement aware NUMA scheduler"
+ 	depends on ARCH_SUPPORTS_NUMA_BALANCING
+ 	depends on !ARCH_WANT_NUMA_VARIABLE_LOCALITY
+-	depends on SMP && NUMA && MIGRATION
++	depends on SMP && NUMA && MIGRATION && !PREEMPT_RT
+ 	help
+ 	  This option adds support for automatic NUMA aware memory/task placement.
+ 	  The mechanism is quite primitive and is based on migrating memory when
+--- a/mm/Kconfig
++++ b/mm/Kconfig
+@@ -371,7 +371,7 @@ config NOMMU_INITIAL_TRIM_EXCESS
+
+ config TRANSPARENT_HUGEPAGE
+ 	bool "Transparent Hugepage Support"
+-	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE
++	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE && !PREEMPT_RT
+ 	select COMPACTION
+ 	select XARRAY_MULTI
+ 	help
diff --git a/patches/random__Make_it_work_on_rt.patch b/patches/random__Make_it_work_on_rt.patch
index a8c7bad3a7b34..2b921cb263fa4 100644
--- a/patches/random__Make_it_work_on_rt.patch
+++ b/patches/random__Make_it_work_on_rt.patch
@@ -76,7 +76,7 @@ Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
  	add_interrupt_bench(cycles);
 --- a/drivers/hv/hyperv_vmbus.h
 +++ b/drivers/hv/hyperv_vmbus.h
-@@ -18,6 +18,7 @@
+@@ -19,6 +19,7 @@
  #include <linux/atomic.h>
  #include <linux/hyperv.h>
  #include <linux/interrupt.h>
diff --git a/patches/rt__Introduce_cpu_chill.patch b/patches/rt__Introduce_cpu_chill.patch
deleted file mode 100644
index a35f9d32c1e70..0000000000000
--- a/patches/rt__Introduce_cpu_chill.patch
+++ /dev/null
@@ -1,149 +0,0 @@
-Subject: rt: Introduce cpu_chill()
-From: Thomas Gleixner <tglx@linutronix.de>
-Date: Wed Mar  7 20:51:03 2012 +0100
-
-From: Thomas Gleixner <tglx@linutronix.de>
-
-Retry loops on RT might loop forever when the modifying side was
-preempted. Add cpu_chill() to replace cpu_relax(). cpu_chill()
-defaults to cpu_relax() for non RT. On RT it puts the looping task to
-sleep for a tick so the preempted task can make progress.
-
-Steven Rostedt changed it to use a hrtimer instead of msleep():
-|
-|Ulrich Obergfell pointed out that cpu_chill() calls msleep() which is woken
-|up by the ksoftirqd running the TIMER softirq. But as the cpu_chill() is
-|called from softirq context, it may block the ksoftirqd() from running, in
-|which case, it may never wake up the msleep() causing the deadlock.
-
-+ bigeasy later changed to schedule_hrtimeout()
-|If a task calls cpu_chill() and gets woken up by a regular or spurious
-|wakeup and has a signal pending, then it exits the sleep loop in
-|do_nanosleep() and sets up the restart block. If restart->nanosleep.type is
-|not TI_NONE then this results in accessing a stale user pointer from a
-|previously interrupted syscall and a copy to user based on the stale
-|pointer or a BUG() when 'type' is not supported in nanosleep_copyout().
-
-+ bigeasy: add PF_NOFREEZE:
-| [....] Waiting for /dev to be fully populated...
-| =====================================
-| [ BUG: udevd/229 still has locks held! ]
-| 3.12.11-rt17 #23 Not tainted
-| -------------------------------------
-| 1 lock held by udevd/229:
-|  #0:  (&type->i_mutex_dir_key#2){+.+.+.}, at: lookup_slow+0x28/0x98
-|
-| stack backtrace:
-| CPU: 0 PID: 229 Comm: udevd Not tainted 3.12.11-rt17 #23
-| (unwind_backtrace+0x0/0xf8) from (show_stack+0x10/0x14)
-| (show_stack+0x10/0x14) from (dump_stack+0x74/0xbc)
-| (dump_stack+0x74/0xbc) from (do_nanosleep+0x120/0x160)
-| (do_nanosleep+0x120/0x160) from (hrtimer_nanosleep+0x90/0x110)
-| (hrtimer_nanosleep+0x90/0x110) from (cpu_chill+0x30/0x38)
-| (cpu_chill+0x30/0x38) from (dentry_kill+0x158/0x1ec)
-| (dentry_kill+0x158/0x1ec) from (dput+0x74/0x15c)
-| (dput+0x74/0x15c) from (lookup_real+0x4c/0x50)
-| (lookup_real+0x4c/0x50) from (__lookup_hash+0x34/0x44)
-| (__lookup_hash+0x34/0x44) from (lookup_slow+0x38/0x98)
-| (lookup_slow+0x38/0x98) from (path_lookupat+0x208/0x7fc)
-| (path_lookupat+0x208/0x7fc) from (filename_lookup+0x20/0x60)
-| (filename_lookup+0x20/0x60) from (user_path_at_empty+0x50/0x7c)
-| (user_path_at_empty+0x50/0x7c) from (user_path_at+0x14/0x1c)
-| (user_path_at+0x14/0x1c) from (vfs_fstatat+0x48/0x94)
-| (vfs_fstatat+0x48/0x94) from (SyS_stat64+0x14/0x30)
-| (SyS_stat64+0x14/0x30) from (ret_fast_syscall+0x0/0x48)
-
-Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
-Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
-Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
-Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
-
-
----
- include/linux/hrtimer.h |    8 ++++++++
- kernel/time/hrtimer.c   |   31 ++++++++++++++++++++++++++++++-
- 2 files changed, 38 insertions(+), 1 deletion(-)
----
---- a/include/linux/hrtimer.h
-+++ b/include/linux/hrtimer.h
-@@ -42,6 +42,7 @@ enum hrtimer_mode {
- 	HRTIMER_MODE_PINNED	= 0x02,
- 	HRTIMER_MODE_SOFT	= 0x04,
- 	HRTIMER_MODE_HARD	= 0x08,
-+	HRTIMER_MODE_CHILL	= 0x10,
-
- 	HRTIMER_MODE_ABS_PINNED = HRTIMER_MODE_ABS | HRTIMER_MODE_PINNED,
- 	HRTIMER_MODE_REL_PINNED = HRTIMER_MODE_REL | HRTIMER_MODE_PINNED,
-@@ -124,6 +125,7 @@ struct hrtimer {
- 	u8				is_rel;
- 	u8				is_soft;
- 	u8				is_hard;
-+	u8				is_chill;
- };
-
- /**
-@@ -536,4 +538,10 @@ int hrtimers_dead_cpu(unsigned int cpu);
- #define hrtimers_dead_cpu	NULL
- #endif
-
-+#ifdef CONFIG_PREEMPT_RT
-+extern void cpu_chill(void);
-+#else
-+# define cpu_chill()	cpu_relax()
-+#endif
-+
- #endif
---- a/kernel/time/hrtimer.c
-+++ b/kernel/time/hrtimer.c
-@@ -1570,6 +1570,7 @@ static void __hrtimer_init(struct hrtime
- 	base += hrtimer_clockid_to_base(clock_id);
- 	timer->is_soft = softtimer;
- 	timer->is_hard = !!(mode & HRTIMER_MODE_HARD);
-+	timer->is_chill = !!(mode & HRTIMER_MODE_CHILL);
- 	timer->base = &cpu_base->clock_base[base];
- 	timerqueue_init(&timer->node);
- }
-@@ -1936,7 +1937,7 @@ static enum hrtimer_restart hrtimer_wake
-
- 	t->task = NULL;
- 	if (task)
--		wake_up_process(task);
-+		wake_up_state(task, timer->is_chill ? TASK_RTLOCK_WAIT : TASK_NORMAL);
-
- 	return HRTIMER_NORESTART;
- }
-@@ -2154,6 +2155,34 @@ SYSCALL_DEFINE2(nanosleep_time32, struct
- }
- #endif
-
-+#ifdef CONFIG_PREEMPT_RT
-+/*
-+ * Sleep for 1 ms in hope whoever holds what we want will let it go.
-+ */
-+void cpu_chill(void)
-+{
-+	unsigned int freeze_flag = current->flags & PF_NOFREEZE;
-+	ktime_t chill_time;
-+
-+	local_irq_disable();
-+	current_save_and_set_rtlock_wait_state();
-+	local_irq_enable();
-+
-+	chill_time = ktime_set(0, NSEC_PER_MSEC);
-+
-+	current->flags |= PF_NOFREEZE;
-+	schedule_hrtimeout(&chill_time,
-+			   HRTIMER_MODE_REL_HARD| HRTIMER_MODE_CHILL);
-+	if (!freeze_flag)
-+		current->flags &= ~PF_NOFREEZE;
-+
-+	local_irq_disable();
-+	current_restore_rtlock_saved_state();
-+	local_irq_enable();
-+}
-+EXPORT_SYMBOL(cpu_chill);
-+#endif
-+
- /*
-  * Functions related to boot-time initialization:
-  */
diff --git a/patches/series b/patches/series
index e1d4d3cc3d63e..49e122927596a 100644
--- a/patches/series
+++ b/patches/series
@@ -43,6 +43,7 @@ crypto_testmgr_only_disable_migration_in_crypto_disable_simd_for_test.patch
 mm_allow_only_slub_on_preempt_rt.patch
 mm_page_alloc_use_migrate_disable_in_drain_local_pages_wq.patch
 mm_scatterlist_replace_the_preemptible_warning_in_sg_miter_stop.patch
+mm-Disable-NUMA_BALANCING_DEFAULT_ENABLED-and-TRANSP.patch

 # KCOV (akpm)
 0001_documentation_kcov_include_types_h_in_the_example.patch
@@ -79,6 +80,8 @@ net-stats-Read-the-statistics-in-___gnet_stats_copy_.patch
 irq_poll-Use-raise_softirq_irqoff-in-cpu_dead-notifi.patch
 smp_wake_ksoftirqd_on_preempt_rt_instead_do_softirq.patch
 x86-softirq-Disable-softirq-stacks-on-PREEMPT_RT.patch
+fs-namespace-Boost-the-mount_lock.lock-owner-instead.patch
+fscache-Use-only-one-fscache_object_cong_wait.patch

 # sched
 0001_sched_clean_up_the_might_sleep_underscore_zoo.patch
@@ -107,7 +110,6 @@ tcp__Remove_superfluous_BH-disable_around_listening_hash.patch
 # Kconfig bits:
 ###########################################################################
 jump-label__disable_if_stop_machine_is_used.patch
-kconfig__Disable_config_options_which_are_not_RT_compatible.patch

 ###########################################################################
 # Locking: RT bits. Need review
@@ -174,9 +176,6 @@ ptrace__fix_ptrace_vs_tasklist_lock_race.patch
 fs_dcache__use_swait_queue_instead_of_waitqueue.patch
 fs_dcache__disable_preemption_on_i_dir_seqs_write_side.patch

-rt__Introduce_cpu_chill.patch
-fs__namespace__Use_cpu_chill_in_trylock_loops.patch
-
 ###########################################################################
 # RCU
 ###########################################################################
@@ -200,15 +199,16 @@ random__Make_it_work_on_rt.patch
 ###########################################################################
 # DRM:
 ###########################################################################
-0002-drm-Increase-DRM_OBJECT_MAX_PROPERTY-by-18.patch
+0001-drm-i915-selftests-Properly-reset-mock-object-proper.patch
+0002-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch
 0003-drm-i915-Use-preempt_disable-enable_rt-where-recomme.patch
 0004-drm-i915-Don-t-disable-interrupts-on-PREEMPT_RT-duri.patch
-0005-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch
-0006-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch
-0007-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch
-0008-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch
-0009-drm-i915-Drop-the-irqs_disabled-check.patch
-0010-drm-i915-Don-t-disable-interrupts-and-pretend-a-lock.patch
+0005-drm-i915-Don-t-check-for-atomic-context-on-PREEMPT_R.patch
+0006-drm-i915-Disable-tracing-points-on-PREEMPT_RT.patch
+0007-drm-i915-skip-DRM_I915_LOW_LEVEL_TRACEPOINTS-with-NO.patch
+0008-drm-i915-gt-Queue-and-wait-for-the-irq_work-item.patch
+0009-drm-i915-gt-Use-spin_lock_irq-instead-of-local_irq_d.patch
+0010-drm-i915-Drop-the-irqs_disabled-check.patch

 ###########################################################################
 # X86:
diff --git a/patches/signal__Revert_ptrace_preempt_magic.patch b/patches/signal__Revert_ptrace_preempt_magic.patch
index 417a296885147..2e08ecc7e4038 100644
--- a/patches/signal__Revert_ptrace_preempt_magic.patch
+++ b/patches/signal__Revert_ptrace_preempt_magic.patch
@@ -17,7 +17,7 @@ Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
 ---
 --- a/kernel/signal.c
 +++ b/kernel/signal.c
-@@ -2288,16 +2288,8 @@ static void ptrace_stop(int exit_code, i
+@@ -2275,16 +2275,8 @@ static void ptrace_stop(int exit_code, i
  		if (gstop_done && ptrace_reparented(current))
  			do_notify_parent_cldstop(current, false, why);

diff --git a/patches/signal_x86__Delay_calling_signals_in_atomic.patch b/patches/signal_x86__Delay_calling_signals_in_atomic.patch
index 59b41b6892220..3a00c187b7c13 100644
--- a/patches/signal_x86__Delay_calling_signals_in_atomic.patch
+++ b/patches/signal_x86__Delay_calling_signals_in_atomic.patch
@@ -96,7 +96,7 @@ Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

 --- a/kernel/signal.c
 +++ b/kernel/signal.c
-@@ -1330,6 +1330,34 @@ force_sig_info_to_task(struct kernel_sig
+@@ -1317,6 +1317,34 @@ force_sig_info_to_task(struct kernel_sig
  	struct k_sigaction *action;
  	int sig = info->si_signo;

diff --git a/patches/x86__kvm_Require_const_tsc_for_RT.patch b/patches/x86__kvm_Require_const_tsc_for_RT.patch
index 4508ca75cedf0..bfc3f90e5be89 100644
--- a/patches/x86__kvm_Require_const_tsc_for_RT.patch
+++ b/patches/x86__kvm_Require_const_tsc_for_RT.patch
@@ -18,7 +18,7 @@ Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
 ---
 --- a/arch/x86/kvm/x86.c
 +++ b/arch/x86/kvm/x86.c
-@@ -8416,6 +8416,14 @@ int kvm_arch_init(void *opaque)
+@@ -8433,6 +8433,14 @@ int kvm_arch_init(void *opaque)
  		goto out;
  	}

--
cgit 1.2.3-1.el7

